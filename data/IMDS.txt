Integrated Model of Distributed Systems
By Wiktor B. Daszczuk 
Institute of Computer Science, Warsaw University of Technology
Nowowiejska Str. 15/19, 00-665 Warsaw, Poland
wbd@ii.pw.edu.pl
I dedicate this monograph to my friend Jurek Mieścicki
 
 
pamięci Jurka

gdzie wędrował?
trawa lekko skoszona jego stopami
a gwiazdy tłumnie umierały
robiąc miejsce dla zmyślonego smoka 
połykającego swój ogon
połykającego świat cały

mrówki jego myśli toczyły wieczną bitwę
nacierając pod sztandarem mądrości
który padał zadeptany następną myślą
a sen o pajęczynie pamięci
uświadamiał spisek przyzwyczajeń

podróżując aleją
wzdłuż żywopłotu sekund
wyciągał rękę 
a małe zdarzenia 
łaskotały
i raniły
przykuwały codziennością konieczności 
koniecznością codzienności 

chciał tylko minąć następny kamień
lecz ten nie wydawał się inny od poprzednich
ani bardziej szczęśliwy
ani bardziej mokry
ani bardziej egipski

szczęśliwa gwiazda spadła
robiąc wiele spustoszenia
zaśmiała się niecierpliwie
na pogrzebie jutra
in memory of Jurek

where he wandered?
grass mowed slightly by his feet 
and the stars were dying in droves
making room for imaginary dragon
swallowing its tail
swallowing the whole world

ants of his thoughts took an eternal battle
assaulting under the banner of wisdom
which felt trampled by a next thought
and a dream of a spider's web of memory
made someone conscious of conspiracy habits

traveling an alley
along the hedge of seconds
he extended his hand
and small events
were tickling
and hurting
attracted an everyday necessity
a necessity of everyday life

he just wanted to get passed the next stone
but this did not seem different from previous ones
nor more happy
nor wetter
nor more Egyptian

a lucky star felt down
doing a lot of havoc
it laughed impatiently
at the funeral of the next day 
 
Preface
Deadlock, a situation in which the system or part of it just stops and cannot continue successfully is a typical error identified in distributed computer systems. However, verification of computer systems often requires some knowledge about the mathematical background and formal meth-ods from the designer. In many institutions, formal verification is necessarily required, for exam-ple in avionics or NASA projects. On the other hand, many engineers and students give up for-mal verification because time and effort must be sacrificed to study formalism. In many cases, they only decide to test, without formal proofs of proper cooperation in distributed systems. 
The author offers original formalism - Integrated Distributed Systems Model (IMDS) - combined with model checking based on temporal logic. The formalism allows the designer a specification that emphasizes the natural features of distributed systems and provides automatic verification of the typical features of such systems, such as deadlock and termination. The verified system is defined in a uniform model that can be observed in two general perspectives highlighting different aspects of the system. The server view involves servers’ states and message exchange. The agent view presents distributed agents traveling by means of messages and collaborating through shared resources.
The introduced IMDS formalism exploits natural features of distributed systems:
•	Locality: individual actions that are part of the processes are executed based on the local server’s state and the set of currently pending messages at this server, regardless of what is happening in other servers. No incident from outside the server – except for messages sent to it – can influence the operation of the server. Servers have no access to any global or non-local variables.
•	Autonomy: every decision about executing an action on the server – including the choice between many possible actions – is made autonomously. The only manner to influence the behavior of the server is to send a message to it, which may enable a previously impossible action.
•	Asynchrony: any required synchronization is hidden inside processes, therefore processes are perceived as asynchronous. In addition, unidirectional communication channels between servers are naturally observed as asynchronous. Ergo, asynchrony is built into the grounds of IMDS.
Many modeling formalisms are based on synchronous actions performed by processes or on synchronous communication. In the author’s opinion, asynchronous behavior is more realistic in the description of distributed systems, in which the only way to contact another server is to send a message and wait for response. The IMDS formalism emphasizes the enumerated character-istics of distributed systems: locality, autonomy and asynchrony.
The main research contribution of this monograph is the formulation of IMDS, in which commu-nication duality is exposed, and which supports locality, autonomy and asynchrony in the speci-fication of distributed systems.
Integration of IMDS with model checking allows detecting different types of deadlock and check-ing distributed termination using general formulas. These general formulas are not related to any specific structure of the model being verified. Communication deadlocks are observed in the server view while resource deadlocks are observed in the agent view. This dichotomy is a rarity among commonly used formalisms. An important feature of IMDS is also the automatic distinc-tion between deadlocks and distributed termination, in which processes stop deliberately. 
General formulas for deadlock detection and termination checking enable automatic verification of these features. Many formalisms include automatic verification of total features, which involve all processes in the system. Partial deadlocks and partial termination – involving only a subset of all processes – must be individually determined by the designer in terms of features of the sys-tem under check. This requires the designer's knowledge, time and effort. Some formalisms support the design process by automatic detection of partial deadlocks and/or termination, but at the expense of limiting themselves to a certain class of verified systems, for example only cy-cling systems. This monograph analyzes some of such approaches with their limitations. IMDS in conjunction with model checking is free from such restrictions, because a large class of systems can be automatically checked for partial and total deadlocks and termination. The obvious limitations of the introduced formalism are the finiteness of the model (for the purpose of static model checking) and the lack of broadcast communication (because messages are process car-riers).
In automatic verification, temporal formulas specifying the features are generated by the Dedan program, developed by the author. The user does not need to know any temporal logic. The De-dan tool reports an error and provides a counterexample leading to a deadlock or a non-terminating loop. In this way, the designer can work in the style of “specify and push the button”. The integration of IMDS with model checking and elaboration of general temporal formulas to verify deadlocks and termination, including their partial form, are both the research and the prac-tical contribution of the author.
For the presented IMDS formalism, the textual specification language is developed as well as a graphical form of distributed automata is introduced. In addition, the conversion to equivalent Petri nets is defined. These three equivalent specification methods are used for various kinds of analysis: 
•	basic textual form for model checking and simulation over global reachability space, 
•	distributed automata for simulation over individual distributed components,
•	Petri net for finding structural properties of the verified system, such as separation of com-ponents or unreachable actions; in Petri net analysis many deadlocks may be found using single verification, while model checking finds only one of possibly many deadlocks.
The Dedan program, developed by the author, is based on the introduced methodology of specification in IMDS and on temporal verification. The program supports the specification of distributed systems, in textual or graphical form. A conversion from the server view of the system to the agent view is done algorithmically. Temporal verification is hidden inside the program, the user sees the results in an easily readable form of sequence-diagram-like counterexamples. The internal TempoRG verifier and external, commonly used temporal verifiers are used for model checking. In addition, a global reachability space of a checked system may be explored manually and its behavior may be observed in several simulation modes. Conversions of system specification to Petri net or to distributed automata model are supported. The translation of IMDS into Petri net and to distributed automata DA3, invented by the author, and the development of the Dedan program are the practical contribution.
External verifiers used in Dedan do not support some kinds of fairness, which sometimes results in reporting false deadlocks. The author’s original verification algorithm CBS (Checking by Spheres) is free from the mentioned disadvantage. The algorithm was improved for Dedan pro-gram using reverse reachability, which supports identification of individual cases in the reacha-bility space.
The imposition of time constraints on the actions executed in the verified system, and on the message passing channels, may change the behavior of the system. For example, some dead-locks may disappear while other deadlocks may arise. The timed version of IMDS formalism is presented (T IMDS), with conversion rules to Timed Automata, in order to verify distributed sys-tems with real-time constraints. This conversion preserves the mentioned features of distributed systems: locality, autonomy and asynchrony.
In order to verify very large systems whose reachability spaces cannot be built even under ex-ternal, efficient verifiers, the non-exhaustive search algorithm “2-vagabonds” was developed. It is unique in partial deadlock and partial termination checking. The first vagabond puts hypotheses about deadlock/lack of termination, while the second vagabond verifies these hypotheses. The algorithm has a very limited set of parameters, in contrast to typical non-exhaustive algorithms.
The strong-fairness-aware algorithm, the timed model of distributed systems, preserving com-munication duality, locality, autonomy and asynchrony, and the non-exhaustive search algorithm for partial deadlock and termination checking are research and practical contributions.

Highlights
•	IMDS Formalism for specification of distributed systems, based on servers with their states and agents with their messages. Behavior modeled as actions over states and messages.
•	Communication duality: the IMDS system decomposed into server processes com-municating by messages or into agent processes communicating by servers’ states. Two views of a system: server view and agent view.
•	IMDS exposes natural features of distributed systems: locality of actions on servers, no global variables, autonomy of servers, asynchrony of processes and of communi-cation.
•	IMDS combined with model checking provides automatic verification of deadlocks: in communication or over resources, total and partial, and of distributed termination: total and partial.
•	The Dedan program developed for specification, verification and simulation of distrib-uted systems, based on IMDS formalism and model checking.
•	Alternative formulation of IMDS in Petri nets for structural analysis: finding separate subsystems, unreachable actions, multiple deadlocks.
•	Distributed automata DA3, equivalent to IMDS – simulation over distributed compo-nents, preserved communication duality (two kinds of automata: server-based and agent-based).
•	CBS, original verification algorithm, supporting strong fairness (compassion).
•	Cooperation of Dedan with external model checkers: Spin, NuSMV, Timeless Uppaal.
•	Real time-constrained version of IMDS (T-IMDS) cooperating with external timed verifier Uppaal, translation of T-IMDS to Uppaal Timed Automata.
•	2-vagabonds: non-exhaustive verification algorithm for partial deadlock detection and partial termination checking.
Acknowledgments
Stanisław Chrobot, Włodzimierz Zuberek and Jerzy Mieścicki helped to formulate the current version of Integrated Model of Distributed Systems. Janusz Sosnowski, Piotr Parewicz, Andrzej Pająk and Bogdan Czejdo gave important advice.
The following fragments are taken from the following publications (with major or minor changes):
•	Chapter 2: [Daszczuk, 2017a] permission by Oxford University Press, Great Clarendon Street, Oxford, UK, OX2 6DP,
Chapters 3 and 4, Figures in Chapter 1: [Daszczuk, 2018b] CC BY 4.0 license by MDPI, St. Alban-Anlage 66, 4052 Basel, Switzerland,
•	Fig. 5.9: [Czejdo et al., 2016] CC BY 4.0 license by Instutyt Wydawnicy Spatium Sp. z o.o., 25 Czerwca lok. 62, 26-600 Radom, Poland,
•	Section 6.5: [Daszczuk, 2019a], permission license by Springer Nature,
•	Fig. 7.1, Sections 7.2 and 7.3: [Daszczuk and Zuberek, 2018], permission license by Springer Nature,
•	Chapter 9: [Daszczuk and Zuberek, 2018], permission license by Springer Nature,
•	Fig. 12.1 – permission by Maria Daszczuk.


Table of contents
1.	Introduction	9
1.1.	Overview of the formalism	9
1.2.	Modeling of distributed systems with communication duality	15
1.3.	Distributed deadlock and termination	17
1.4.	Practical outcome	18
1.5.	The organization of the monograph	20
2.	Related work on deadlock and termination detection techniques	21
3.	Integrated Model of Distributed Systems	28
3.1.	Basic IMDS definition	28
3.2.	IMDS system behavior	29
3.3.	IMDS processes	30
3.4.	Views of a distributed system	33
3.5.	IMDS as a Programming Language	37
3.6.	Semantics	42
3.7.	Deadlock and termination	46
4.	Model Checking of IMDS specifications in the Dedan environment	47
5.	Deadlock detection examples: the Dedan environment at work	50
5.1.	“Two semaphores” model	50
5.2.	Dijkstra’s philosophers	59
5.3.	Intersection	64
5.4.	Automatic vehicle guidance system	67
5.5.	Resource deadlock without communication deadlock	69
5.6.	Production cell	70
5.7.	Time of verification	76
5.8.	Use in teaching – the Rybu preprocessor	77
6.	Using the Dedan program	79
6.1.	Program structure	79
6.2.	Main window	80
6.3.	Files	82
6.4.	Model name	82
6.5.	Server type definition	82
6.6.	Agent type definition	83
6.7.	Instances declaration	83
6.8.	Initialization part	83
6.9.	Macrogenerator	84
6.10.	Verification	84
6.11.	Agent view	87
7.	Deadlock detection in Petri net equivalent to IMDS	89
7.1.	Petri net equivalent to IMDS	89
7.2.	Deadlock detection using siphons	94
7.3.	Problem with not purely cyclic systems	97
7.4.	Translation from Petri net to IMDS	99
8.	Distributed Autonomous and Asynchronous Automata (DA3)	112
8.1.	Server automata S-DA3	113
8.2.	Agent automata A-DA3	116
8.3.	Using DA3 in the Dedan program	121
9.	Fairness in distributed systems verification	123
9.1.	The benchmark – bounded buffer	125
9.2.	LTL model checking in Spin	127
9.3.	CTL and LTL model checking in NuSMV	130
9.4.	CTL model checking in Uppaal	134
9.5.	Fair verification algorithm	138
10.	Timed IMDS	142
10.1.	Timed Automata	142
10.2.	Timed extensions to IMDS (T-IMDS)	148
10.3.	Conversion of T-IMDS to Uppaal Timed Automata	152
10.4.	Formal translation of CT-IMDS to Uppaal Timed Automata	159
10.5.	Example of Timed IMDS system – two semaphores	167
10.6.	Example of Timed IMDS system – automatic vehicle guidance system	169
10.7.	Verification of the Production Cell	169
11.	2-vagabonds: non-exhaustive verification algorithm	171
11.1.	Related work	172
11.2.	2-vagabonds algorithm	173
11.3.	Experimental results	179
11.4.	Parallel verification	187
11.5.	Limitations	187
12.	Conclusions and further work	191
References	197
Appendix A – Acronyms, shortcuts and symbols used in the text	218
Appendix B – IMDS formal definition	225
Appendix C – IMDS syntax	227

1.	Introduction
1.1.	Overview of the formalism
The author’s experience with building industrial and research distributed systems showed that proper modeling and verification of such systems is crucial for their quality [Schaefer and Hahnle, 2011]. Parallelism of tasks in a concurrent system creates difficulties due to the possibly infinite set of their common executions. In ICS, WUT, a verification methodology based of the original CSM (Concurrent State Machines, invented by Jerzy Mieścicki [Mieścicki, 2006]) was developed and implemented in COSMA design tool [Mieścicki et al., 1996] [Daszczuk, 2001] [Daszczuk, 2000] [Daszczuk, 2002]. The CSM is based on the principle that signals caused by the system component are apparent to other components as long as they are being generated. This feature can be treated as a kind of synchrony or a non-local state in the system: the internal state of the component is visible to the entire system. The modules can make their decisions based on the actual states of other modules.
The author built temporal verifier TempoRG [Daszczuk, 2003] in the COSMA environment [Mieścicki, 2006], and carried out many verification experiments. Parts of several real-life sys-tems developed in ICS, WUT were subject to temporal verification in the COSMA tool by the author and his collaborators [Grabski et al., 1999] [Daszczuk, Grabski, et al., 2001] [Daszczuk, Mieścicki, et al., 2001] [Mieścicki et al., 2003] [Mieścicki et al., 2004] [Mieścicki and Daszczuk, 2006]: 
•	KURMAN distributed system for identification and on-line control of industrial plants [Mieścicki et al., 1992] [Daszczuk, Mieścicki, Kochan, et al., 1998], implementing the original MIKOZ plant identification method [Mieścicki et al., 1995], 
•	ESS industrial plant monitoring distributed system [Daszczuk et al., 1995], for many years working in Polish energy plants, awarded Siemens Prize 1996; this system was later the basis for the research on distributed SCADA systems in inter-faculty project PATIA,
•	remote monitoring protocols using SMS GSM messages and data mode [Mieścicki et al., 1998] [Daszczuk, Mieścicki, Krystosik, et al., 1998], in cooperation with DeTeMobil (currently T-Mobile),
•	embodied mobile cooperating agents built by ICS, WUT students [Daszczuk and Mieścicki, 2001].
The verification process identified several behavioral errors and communication errors in these systems.
Modern systems add a new difficulty dimension to parallelism: independent nodes cooperating in the distributed environment. The level of parallelism is much higher than in centralized systems, and there is no real global state of calculations in such a system. There are no global/non-local variables as well as no global state of the system exists. The only manner of communication between tasks is message passing over the network. The server cannot even expect that a re-sponse to a sent message would ever come With the exception of strictly related systems using the common bus, system components communicate with messages sent asynchronously.  
Such an environment should be considered in modern systems of grid computing, mobile sys-tems, distributed sensor networks, cloud computing, etc. A new Internet of Things (IoT) paradigm was introduced, in which independent, autonomous nodes communicate using simple protocols to agree their coordinated behavior [Lee et al., 2013]. 
The verification of many systems under COSMA, mentioned above, and many others, was suc-cessful, but the author realized that old-fashioned models based on synchronous actions in sep-arate servers were not suitable for distributed systems. In a distributed system there is neither a global nor a non-local state, therefore no coordinated action between two or more servers can be performed synchronously. The server can inform another server about its state and its intentions by means of a message. Then the server can wait for the response to its request, again passed by a message. Each server operates autonomously, deciding on its individual behavior, observing local variables that store the server state value and contain messages pending locally. Asynchrony means that usually the server is waiting for a message, or the message pends wait-ing for acceptance by the server. Message passing is also asynchronous, based on sending messages along unidirectional asynchronous channels, and possible responses are passed through separate channels in the opposite direction. 
The new IMDS (Integrated Model of Distributed Systems) formalism was proposed by the author and Stanisław Chrobot [Chrobot and Daszczuk, 2006], then the research was continued by the author alone [Daszczuk, 2008] [Daszczuk, 2017a]. The IMDS is a closed model of a distributed system, i.e., it models resources and their users: no external influence is accepted. Resources and users are modeled as distributed servers, and distributed computations over the servers are modeled as traveling agents. The modeling of closed systems is a typical basis for verification of synchronization solutions, in particular the technique of static model checking [E.M. Clarke et al., 1999], used in this monograph. The IMDS formalism highlights the natural features of distributed systems, rarely found in other models: servers locality, autonomy of their decisions and asyn-chrony of performed actions and communication. However, the most important feature of IMDS is communication duality, which allows the observation of a uniformly specified distributed sys-tem in one of two perspectives: servers communicating by messages or agents communicating via the servers’ states.
The IMDS formalism is founded on the basic observation of the server operation in a distributed environment, namely that the server remains in a certain state p, determined by the values of its internal variables (Fig. 1.1a). If the message m appears at the server in the context of an agent (Fig. 1.1b), it can be accepted, which means that the action invoked by this message is execut-ed. The execution of the action is performed entirely in the context of this server (without any external intervention). As a result of the action, the server variables get new values, which means the next server state p’ (Fig. 1.1c). In addition, another message m’ is generated which continues the calculation represented by the agent (Fig. 1.1d). This simple scheme of the server and agent activity in the distributed environment leads to the definition of IMDS. Two basic sets are defined: states and messages. The set of actions is defined as the relation between the input pairs (message, state) and output pairs (next message, next state). The only exception to this rule is the agent-terminating action, in which only the new server state appears, but there is no next agent message on the output of the action (the action does not have the feature presented in Fig. 1.1d).
Note that the scheme presented in Fig. 1.1(b-d) is only an illustration to give the reader an intui-tion of the action. In IMDS, the execution of the action is instant and indivisible, with no phases shown in the figure. 
 
The distributed system is defined over servers and agents – distributed computations performed in the system. Messages are passed between servers in the context of individual agents, just as the states are replaced by next states in the context of individual agents. This duality is the basis for the verification of behavioral features: communication deadlock, resource deadlock and dis-tributed termination (Chapter 4).
The present formulation of IMDS, described in [Daszczuk, 2018b] (Chapter 3), differs from pre-vious articles [Chrobot and Daszczuk, 2006] [Daszczuk, 2008] [Daszczuk, 2017a], where distrib-uted systems were defined over four sets: servers, values of their states, services offered, and agents. Processes were defined as sets of states and messages. In the present formulation, the basic concepts are states and messages, and the processes are defined as sets of actions. The new formulation is more convenient for readers. However, the two formulations are equivalent in the case for asynchronous sequential processes. Other types of processes can be defined in the previous formulation, but we do not deal with them in this monograph. In addition, in the papers [Chrobot and Daszczuk, 2006] [Daszczuk, 2008] dynamic creation of servers and agents was allowed in actions, but for the purpose of static model checking we restrict the creation of servers and agents to the start of the system.
Communication in distributed systems is described in the literature in two basic models that are alternative to each other. A client-server model [Jia and Zhou, 2005] shows independent servers, actively cooperating by message passing. Servers change their states upon messages received. Processes in such a model are identified with the servers. 
On the other hand, a distributed system can be described in the paradigm of Remote Procedure Call (RPC), with processes traveling between the servers via procedure invocations and returns [Jia and Zhou, 2005]. Many such processes can originate on a single server, and they migrate to other servers treated passively as shared resources. This model can be extended to processes traveling through servers, without having to return to the server from which they originate. 
The main research contribution of this monograph is the Integrated model of Distributed Systems which covers the two views in a uniform specification. A distributed system is defined as a set of actions of servers and agents. The two system views can be extracted from a single action-based specification, simply by grouping the servers’ actions. This corresponds to the client-servers paradigm [Jia and Zhou, 2005]. The server view is obtained by grouping the actions of individual servers. Processes are identified with servers and communicate using messages. The agent view is retrieved by grouping actions of individual agents. Processes represent distributed computations (as in the RPC model) called agents. Agents collaborate by shared variables which are represented by servers’ states. Combining two views - cooperating servers or migrating agents - into a uniform specification is defined by the author as “communication duality”. The two concepts, servers and agents, can usually be assigned to observable system elements. For example in the automatic vehicle guidance system, described in Section 5.4 [Czejdo et al., 2016], servers are road segments controllers while agents are vehicles. In the production cell example (Section 5.6 [Daszczuk, 2019a]), servers are subcontrollers of the devices, and agents are identified with metal plates traveling through the cell.
There are several models of parallel execution in computer systems [Kessler and Keller, 2007]. They can be generally divided into synchronous and asynchronous models [Milner, 1983] [Savoiu et al., 2002] [R. van Glabbeek et al., 2008]. In synchronous models, cooperating processes (or threads, tasks or other activities running in parallel) must simultaneously communicate being in specific states. Therefore, at least cooperative processes must reconcile their states or, alternatively, participate in a required manner in the global state of the system. Examples of synchronous formalisms are: LOTOS [Rosa and Cunha, 2004], Büchi automata [Holzmann, 1995] used for verification of systems using linear temporal logic LTL [E.M. Clarke et al., 1999], Zielonka’s automata [Zielonka, 1987] or Timed Automata [Alur and Dill, 1994]. In each of these models, the automata synchronize using common symbols on transitions. On the other hand, CSP [Hoare, 1978] and Uppaal timed automata [Behrmann, David, et al., 2006] synchronization is performed by execution of simultaneous send and receive operations. Likewise, synchronous operations on complementary input and output ports in CCS [Milner, 1984] and Occam [May, 1983] require the agreement of the processes.
We argue that the above models are inadequate for modeling of distributed systems, because such systems do not have a global (or non-local) state. In reality, the processes cannot agree their states. The only way to influence the behavior of another server is sending a message to it. On the other hand, receiving a reply does not guarantee that the responding server is still in the state reported in the response. Therefore, asynchronous formalisms in which the processes do not agree on common states are more realistic in modeling of distributed systems [Johnsen et al., 2009]. 
Message Passing Automata (MPA [Bollig and Leucker, 2004]) and Pushdown Distributed Au-tomata (PDA [Balan, 2009]) are really asynchronous, because the received messages are wait-ing for acceptance in specific structures: queues or stacks. The locality of actions is assured, because the acceptance of the message depends only on the local state of receiving automaton and the locally stored message: the one waiting for the longest time in a queue or, respectively, for the shortest time on a stack. However, in both formalisms, the automata are not fully auton-omous, because they do not decide locally which message is accepted first (it is decided upon the underlying rule: FIFO or LIFO). 
Many modeling environments use one of the mentioned communication paradigms: message passing in client-server paradigm or RPC paradigm with messages serving as process migration means. None of them provides duality of communication in a unified formalism. IMDS offers this duality as the two projections of a modeled system: on servers or on agents. The projections simply consist in grouping the actions: in individual servers or in individual agents. This is always possible because each action has a pair of state and message on input. This duality allows the expression of various features that manifest in individual views: communication deadlocks in the server view, resource deadlocks and distributed termination in the agent view (Chapter 4). 
In IMDS, actions are executed on the server basing on its local state and on messages pending at it. This allows modeling of distributed systems in an asynchronous way, which is realistic and natural. We argue that IMDS is well-suited for modeling of distributed systems, because the ac-tions in servers preserve:
•	locality of the execution of actions, which depends only on the local state and messages pending locally; the server does not have access to a global or non-local state;
•	autonomy of decisions: the local structure of the server determines which of the messag-es pending at the server will be accepted first, no order among the pending messages is assumed;
•	asynchrony of actions: received messages are pending and they wait for acceptance; if there is no pending message or the server cannot accept any of the pending messages in the current state, then the server waits for the appropriate message; on the other hand, pending messages wait for the appropriate server state;
•	asynchrony of communication: a message is sent along unidirectional asynchronous channel; the sender doesn’t know when the message reaches the target server and when the response can be expected (if the calculation provides a response).
This integration of communication duality, locality, autonomy and asynchrony in a one model is unique among formalisms. 
Intensive testing of computer systems can improve the reliability of the software, but it does not guarantee its correctness. In distributed systems, where parallelism is very intense, reachability space (and the number of possible behaviors) could be huge, and testing does not provide de-pendability. What's more, there is no global system state, which further aggravates verification. For such systems, formal proofs of correctness and formal verification are needed to create trustable programs. Formal models are needed to express the properties of distributed systems and to verify them [Schaefer and Hahnle, 2011].
Model checking and other formal methods are widely and effectively used in the verification of computer systems, for example in avionic systems [Moy et al., 2013] or NASA projects [NASA, 2007]. Formal verification came even to everyday work in industry [Miller et al., 2010] [Fahland et al., 2011]. However, the author's experience with formal methods showed that the verification procedure should be automatized as much as possible, allowing designers to check their projects without any assistance of verification specialists. For this purpose, a formalism for automatic deadlock detection and termination checking was developed [Daszczuk, 2017a]. It combines IMDS with the model checking technique. In the author’s opinion, the most important features are the deadlock freedom and the inevitable termination (in the case of non-cyclic systems). There are many automated deadlock and termination verification methods (these are listed in Chapter 2), but generally they focus on the total features, which involve all system’s processes. On the other hand, partial features (regarding a subset of processes) can be checked in a num-ber of methods, but only in the case of systems with a very limited structure. The second re-search contribution of the author is the combination of the two approaches: automated verifica-tion of partial (and total) features in systems having arbitrary shape, restricted only by the IMDS principle. This principle is the definition of a distributed system as a set of actions, which are the relation between state and message pairs (or a state only in the case of agent-terminating ac-tions).
General temporal formulas, unrelated to individual system structures, were developed to detect deadlocks and check distributed termination. Communication duality allows expressing the fea-tures of a distributed system in two aspects: communication deadlocks in the server view and resource deadlocks and distributed termination in the agent view. Because the formulas concern the behavior of individual processes, partial deadlocks and termination (for a subset of the pro-cesses in the system) can be identified. 
1.2.	Modeling of distributed systems with communication duality 
As mentioned in the previous section, the distributed system is usually described as Client-Server or as RPC model [Jia and Zhou, 2005]. In the former approach, the system is defined in terms of servers exchanging messages. A server is an entity that has a specific state and offers a number of actions. Execution of such an action changes the state of the server. The process in a system is defined as a sequence of server state changes. These changes are internal to the server processes, which communicate with other server processes via message exchange. 
However, a second model is possible: if the process is associated with a traveling agent, it mi-grates between the servers and performs steps of its computations on various servers. The agent communicates with other traveling agents via servers' states. Messages are process carriers and therefore hidden in the processes. In this way, the system is described in terms of resource sharing instead of message passing. This is similar to a Remote Procedure Calling principle (RPC [Jia and Zhou, 2005] ), although the traveling process model is wider, because generally the process need not return to its “home” server.
The key fact is that in both approaches, Client-Server and RPC, this is one and the same sys-tem, shown in one of two views, depending on how the actions are grouped. The action gives a detailed description of the operation in a distributed system: it is invoked by an incoming mes-sage, executed on the server and changes the state of this server. The assumption in our model is that each action (with the exception of agent-terminating actions) generates the next agent message after its completion. This message is issued to another server in the system to invoke the next action in the distributed computation. The server states and the agent messages are the input and output elements of the action. Therefore, there is an intermediate state or an interme-diate message between a pair of subsequent actions. We may say that the state or the message “threads” two actions. 
If actions in a sequence are threaded by server states – it is the server view. The server’s states are the process carrier, while messages are the means of communication between servers. If the sequence is threaded by messages – it is the agent view. Agent messages are the process carrier, while servers' states serve to communicate agent processes. These two views are de-compositions showing the aspects of message passing and resource sharing in a distributed system. 
Fig. 1.2 presents an example of a distributed system – a bounded buffer with capacity 2. The system consists of three servers: buffer, producer and consumer, their names: Sbuf, Sprod and Scons.  The Sprod server produces items and sends them to Sbuf using put message, then receives ok_put response message. The Sprod server sometimes does something else, which is modeled by doSth message sent to itself. The Scons server acts similar. The Sbuf server receives put and get messages, but accepts put only when the buffer is not full and accepts get only if the buffer is not empty. We can distinguish two agents representing distributed com-putations: Aprod , consisting of all messages sent and received by Sprod, and Acons - similar-ly. The servers’ states are ovals and the agents’ messages are contour arrows. Agent messages are shown in italics. System actions are shown as thin arrows between servers states. The figure does not explain which messages are accepted in which states, but this is obvious in such a simple system. For example, an empty buffer (0 state) accepts the put message, changes its state to 1 and generates ok_put message. In the server view, the system is decomposed into three server processes, each of which groups the actions of a given server. In the agent view, the system is decomposed into two agent processes, each of which groups actions of a given computation (producing or consuming). Initial server states and initial agent messages have bold edges. In the figure (and all subsequent ones) the servers and their states are colored red, while agents and their messages are green.
 Informally, IMDS is based on states, messages and actions. If the server state allows the action to be executed (we say that the state and the message match), the server can fire the action. The action changes the server state to another one and issues the next message, invoking an action on another server (or sometimes on the same server). The set of actions is the relation between the input pairs (m,p) and the output pairs (m',p’). States in the system are attributed to servers while messages are attributed to agents (formal definition is given in Chapter 3). The process is a sequence of actions: on the same server (server process) or in the same agent (agent process). The system starts from the initial set of servers’ states (one state for the server) and the initial set of agents’ messages (one message for the agent).
There is a special type of actions for process termination in IMDS. In such an action, the output message does not exist and therefore the agent terminates. This type of actions is the relation between the pair (m,p) and singleton (p’). 
The obvious limitation of the modeled system class comes from the IMDS rules: because there is one input message and one output message in the regular action (no output message in the agent-terminating action), systems with broadcast communication cannot be specified. Instead, the designer can use a set of agents (“task force”) to perform broadcast-like communication. 
The behavior of the distributed system may change if specific time constraints are imposed on its elements. Many specification and verification models have time-dependent versions, such as timed Petri nets and Timed Automata [Bérard et al., 2005] [Popescu and Martinez Lastra, 2010]. The author provides a timed version of IMDS (T-IMDS, with real-time constraints). The transla-tion rules to Uppaal Timed Automata [Behrmann, David, et al., 2006] are defined for verification purposes. The T-IMDS, described in Chapter 10, preserves the features needed to verify distrib-uted systems: communication duality, locality, autonomy and asynchrony. T-IMDS is both a re-search and a practical contribution of the author. 
1.3.	Distributed deadlock and termination
The verification methodology, consisting of the IMDS specification and temporal verification [Daszczuk, 2008], allows the designer to specify a distributed system, observe the server and agent views of the system and to easily find various types of deadlocks (total/partial deadlock, communication/resource deadlock) and distributed termination of processes (again total/partial).
An example of deadlock in the IMDS server view is when two servers are waiting for messages from each other. It is a communication deadlock, because the way the server processes cooper-ate is message passing. The definition of a communication deadlock in IMDS is a situation where there are pending messages on the server (at least one), but they can never be served. A deadlock can affect all servers (total deadlock) or a subset of servers (partial deadlock). A dead-lock can even involve a single server.
In the agent view, deadlock is a situation where an agent has a message pending at some server, but the agent cannot make any progress. The message cannot be served, but messages of other agents possibly can. Again, the deadlock can involve all agents (total deadlock) or subset of agents (partial deadlock). Note that following this definition, a single process can be deadlocked. Such a situation is sometimes called starvation [Tai, 1994] or stall [Masticola and Ryder, 1990].
A (partial) termination in IMDS is simply the disappearance of the agent: the agent-terminating action binds the input pair (message, state) with the singleton output (next state). The action produces the next state of the server but no next message is generated.
Model checking is a method often used in static deadlock detection or termination verification in distributed systems [E.M. Clarke et al., 1999] [Baier and Katoen, 2008]. The model checker au-tomatically detects situations such as deadlock or lack of termination, using system specification and temporal formulas. General  temporal formulas for deadlock and termination are defined by the author over the elements of IMDS [Daszczuk, 2017a][Daszczuk, 2018b]. The generality of formulas means that they do not depend on the specific features of processes in a given system. Only general features of server processes and agent processes are used as arguments. The two views of a model allow to find communication deadlocks and resource deadlocks. In other for-malisms, there are general formulas to find a total deadlock (see Chapter 2), but most of them do not distinguish total deadlock from total termination. Some verifiers perform automatic detection of partial deadlocks, but only in cases where the scheme of the verified system is strictly limited. A similar limitation concerns checking partial termination. If the structure of the system is not restricted, the designer must have some knowledge of temporal logic or equivalent formalisms in order to perform the verification. In addition, none of the known verifiers distinguish between communication deadlocks and resource deadlocks.
If the process falls into a deadlock, or if it does not terminate, the model checker creates a coun-terexample for the program defect. The counterexample supports the designer in finding and correcting errors in the specification. A counterexample is a sequence of states and messages leading from an initial situation  to an erroneous situation.
General formulas - used to deadlock detection and termination checking – allow automatic verifi-cation. Therefore, the formulation and verification of the properties are carried out automatically inside the modeling program Dedan [“Dedan,” n.d.], and the user only sees the final results. What the designer must absorb is the IMDS formalism and specification language, which is much simpler than the specification of temporal formulas. 
Automatic verification of: partial and total deadlocks, partial and total distributed termination, and distinction between deadlock and termination are research and practical contribution of this monograph. They are the basis for the development of the Dedan program.
A non-exhaustive search algorithm, called "2-vagabonds ", has also been developed to detect deadlocks and termination in very large reachability spaces.
1.4.	Practical outcome
The Dedan environment was developed by the author for the practical application of the pro-posed verification methodology [“Dedan,” n.d.], which is presented in Chapters 4, 5 and 6. Fur-ther work of the author, described in this monograph, concerns additional facilities that support the specification and verification of distributed systems. First, IMDS model can be transformed into a Petri net (with a strictly restricted scheme) [Heiner and Heisel, 1999] and verified by coop-eration with Charlie Petri net analyzer [Heiner et al., 2015], described in Chapter 7. For this pur-pose, the translation of the IMDS specification into a Petri net is defined [Daszczuk and Zuberek, 2018] [Daszczuk, 2017b].
Model checking is very attractive in deadlock detection, but its disadvantage results from its very nature: model checking is based on evaluation of the temporal formula. If a formula for “deadlock freeness” is evaluated as false, because a deadlock was found, the verifier stops. However, many other deadlocks can be hidden inside the verified system. Analysis of Petri net solves this problem: identification of bad siphons allows to find multiple deadlocks [Daszczuk and Zuberek, 2018] [Daszczuk, 2018a]. Temporal analysis allows for judging if a siphon represents a deadlock. What's more, Charlie can perform another structural analyzes, such as identifying separated subnets, which mean the existence of independent parts of the system (possibly due to the designer's error), and the location of unreachable transitions meaning “dead code” in the specification. 
The author invented Asynchronous and Autonomous Distributed Automata (DA3, Chapter 8 [Daszczuk, 2017b]), which are equivalent to IMDS models, and which allow for graphical specifi-cation of the distributed system and the graphical simulation over its components. For the two views of a distributed system, server automata and agent automata are introduced. A counter-example obtained from model checking can be animated graphically in DA3 automata during the examination of the error in the specification. This three equivalent specifications (IMDS, Petri net and DA3) create a useful verification environment: IMDS for text specification, model checking (see Section 1.3) and simulation over the reachability space, DA3 for graphical specification and simulation over distributed components, and Petri net  for structural analysis. Reachability spaces of all three forms are equivalent. 
The Dedan program includes an internal TempoRG model checker, which uses the original CBS algorithm, developed by the author [Daszczuk, 2003]. The verification algorithm is adapted to its use in the Dedan tool: it is simplified to a limited set of formulas (see Section 3.4), and reverse reachability is used to identify the distinct cases of the shape of the reachability space (Chapter 9). This verifier uses an explicit reachability space, which allows to deal with rather small specifi-cations, such as student exercises. For larger specifications, external model checkers are used: Spin, NuSMV and Uppaal. Dedan’s cooperation with external verifiers is effective, but some structures of verified systems give false positives (detection of non-existent deadlocks). It results from the lack of strong fairness (compassion) in their implementation. Problems with external verifiers and the construction of the CBS verification algorithm, which supports strong fairness, are described in Chapter 9. The presented three facilities: integration with Charlie, integration with external temporal verifiers and specification and simulation in DA3, are practical contributions of the author [Daszczuk, 2017b]. What's more, the strong fairness-aware verification algorithm is both a research and a practical outcome.
The students of ICS, WUT prepared under the supervision of the author the Rybu preprocessor [Daszczuk et al., 2017], allowing the specification of systems in imperative programming style. This preprocessor is also described in the monograph, Section 5.8.
1.5.	The organization of the monograph
Chapter 2 presents some techniques for detecting deadlocks and checking termination, and dis-cusses their advantages and disadvantages. Chapter 3 introduces the IMDS formalism: the static description of the configuration of a distributed system according to states and messages, and the behavior of a distributed system in terms of actions. The semantics of a distributed system behavior is introduced as the Labeled Transition System (LTS [Reniers and Willemse, 2011]) over the actions. Deadlock and termination are defined in terms of the LTS. This LTS is the basis for temporal model checking in the Dedan environment, described in Chapter 4. Examples of distributed systems and their verification in Dedan are presented in Chapter 5. The Dedan pro-gram itself is described in Chapter 6. Chapter 7 and Chapter 8 show alternative formulations of IMDS systems: specification in Petri net and in the original Distributed Automata DA3. Chapter 9 presents the construction of the own CBS verification algorithm for the Dedan environment. A general scheme for evaluation of temporal formulas is described. The timed IMDS version (with real-time constraints imposed on communication channels, states and actions) is covered in Chapter 10. The own algorithm “2 vagabonds” for non-exhaustive deadlock and termination de-tection is presented in Chapter 11. The conclusions and future directions of development of IMDS and Dedan are discussed in Chapter 12.

2.	Related work on deadlock and termination detection techniques
Because many deadlock detection techniques evolved, even the concept of deadlock varies across papers. Some of them define the deadlock as a feature of the system model, as is often the case with Wait-for-Graph techniques or model checking [Kaveh and Emmerich, 2001] [Karatkevich and Grobelna, 2014] [Karacali et al., 2000] [Godefroid and Wolper, 1992] [Corbett, 1996] [Geilen and Basten, 2003]. The better formulation is abstract, but the disadvantage of this approach is often the lack of precision, as in: “Deadlock is a situation ... in which a system or a part of it remains indefinitely blocked and cannot terminate its task" [Longley and Shain, 1986]. This meaning of the formulation is close to ours (except for its imprecision), because it includes resource and communication deadlock, and total and partial deadlock (sometimes called a live-lock, because some processes work) . In some papers the infinite waiting of a single process is called stall [Masticola and Ryder, 1990], while mutual waiting of at least two processes is called deadlock. The latter definition comes from the formulation of the Coffman deadlock conditions: mutual exclusion, hold and wait, no pre-emption condition, and circular-wait [Coffman et al., 1971].
Sometimes a deadlock is related only to resources:  “Deadlocks arise when members of a group of processes which hold resources are blocked indefinitely” [Isloor and Marsland, 1980] or only communication: “A global state contains a deadlock error when all of the communication chan-nels are empty and all of the entities' states are receive states, where a receive state is a state whose outgoing transitions are all receive ones” [Huang, 1989].
For the purpose of this monograph, we define deadlock as a situation in which the process (de-fined in Section 3.3) waits for a condition than cannot be fulfilled. The total deadlock applies to all the processes in the system, while the partial deadlock leaves some processes running. Re-source deadlock and communication deadlock are defined in terms of the model of the distribut-ed system in Section 3.4. Intuitively, resource deadlock occurs when the agent process is waiting for a server state that cannot be reached. Communication deadlock occurs when the server process waits infinitely for a message that would allow it to perform an action. Other messages may arrive, but none of them will result in an action execution.
The first attempts to detect deadlocks were made on the global reachability space of a central-ized system (or rather its model) [Holt, 1972] by analysis of a dependency graph called “Wait-for Graph” (WFG). This approach allowed to statically predict the risk of deadlock. Alternative meth-ods are based on observation of system dynamically in selected “snapshots”, which allows to discover deadlocks in run-time [Chandy and Lamport, 1985]. This is especially useful in systems in which global behavior is hard to predict, like in a set of independent user programs requesting shared resources.
The Wait-for-Graph approach has been transferred to distributed systems after the introduction of the local observations, because global state cannot be determined in such systems. Locality means that there are no concepts, such as synchronized passage of time or simultaneous activi-ties. A global decision about the deadlock is made on the basis of independent local circum-stances reported by the system components [Chandy et al., 1983] [Elmagarmid, 1986] [Mitchell and Merritt, 1984]. The Wait-for-Graphs concept is still successfully used, especially for detecting deadlocks at runtime [Agarwal and Stoller, 2006] [Knapp, 1987].
In cases covered by two views of the distributed system (server view and agent view), separate techniques are used: resource deadlocks [Elmagarmid, 1986] [Zhou et al., 2004] and communi-cation deadlocks, without buffers [Hilbrich et al., 2009] [Hilbrich et al., 2013] [Natarajan, 1986] [Hosseini and Haghighat, 2005], or with finite or infinite buffers [Allen et al., 2007] [Olson and Evans, 2005]. Resource deadlock, communication deadlock and their distinction are discussed in [Singhal, 1989] [Knapp, 1987]. 
The algorithms dedicated for data bases typically use Wait-for Graphs [Choudhary et al., 1989] [Yeung et al., 1994] [Park and Scheuermann, 1991] [Knapp, 1987]. A special method for data bases uses variable values: Wait-for, Held-by and Request-Q [Grover and Kumar, 2013].
Pulse is a Linux deadlock finder [Li et al., 2005], which creates “ghost” copies of waiting pro-cesses and allows them to operate in a limited environment. Restrictions concern the omission of activities that result in permanent results, e.g., writing to a file. If the ghost process fulfils the condition that another process is waiting for, it means deadlock. This approach is effective, but sometimes finds non-existent deadlocks or misses real deadlocks.
Dynamic methods identify deadlocks in distributed systems during run-time, but if no deadlock is reported, it does not guarantee the deadlock freeness. This is because the system analysis con-tinues "until the current moment", and a deadlock may occur in the future. 
Another investigated feature of distributed system is termination. Various distributed termination checking techniques evolved [Huang, 1989] [Mattern, 1989] [Peri and Mittal, 2004] [Zhou et al., 2004]. The methods are based on the observation of some features of distributed processes or control over message traffic. Sometimes special elements of distributed processes are defined for termination detection.
Model checking techniques are based on the exploration of the global reachability space of a system, or part of it in some techniques [E.M. Clarke et al., 1999] [Bensalem et al., 2011]. The methods are based on the temporal verification of the reachability space. System activities are expressed in the form of local features of its components, and the global reachability space of the system is constructed. The features of system components are expressed as temporal logic formulas and verified by evaluating these formulas. Deadlock is one of most important features. Model checkers are often equipped with automatic deadlock detection procedures [Corbett, 1996] [Puhakka and Valmari, 2000], for example in Spin and PathFinder [Holzmann, 1995] [Holzmann, 1997] [Havelund and Pressburger, 2000]. Usually, a total deadlock is identified as “a state with no future”, i.e., a strongly connected subgraph containing only one state: the deadlock itself [Kaveh, 2001] [Magee and Kramer, 1999]. Deadlock freeness is checked by the CTL tem-poral formula AG EX true (for any state a next state exists) [Cho et al., 2006] [Royer, 2001] [Perna and George, 2006] [Mazuelo, 2008] [Bérard et al., 2001] [Kokash and Arbab, 2008] [Arcaini et al., 2009]. However, the total termination seems to be analogous state that has no future. In a cyclic system, where termination of processes is not expected, the above formula identifies a deadlock. In systems in which processes terminate their run, total deadlock should be distinguished from total termination. Therefore, the formula is refined to differentiate deadlock from termination in [Corbett, 1994]: AG ((! FINAL) => EX true) (for each state there is a next state, except for total termination states). However, the general concept of "FINAL" is not given in the paper. 
Similar results are obtained using CCS [Milner, 1984], based on succession relation. CCS term is in deadlock if the relation analogous to (AG EX true) is not met [De Francesco et al., 1998]. This has the same disadvantage as model checking: it does not distinguish between deadlock and termination and only finds total deadlocks. Suchlike is the verification using CSP [Shi and Liu, 2010] and evaluation of specific formulas which depend on component Finite State Ma-chines (FSM) structures [Hiraishi, 2000]. The methods include graph-based, for example dead-lock detection in statecharts [Kaveh, 2001], sequence diagrams-based [Zhang et al., 2015]. Other method are language-based, as verification of Promela specification in Spin [Holzmann, 1995]. 
As previously indicated, model checking is usually used to ﬁnd total deadlocks, i.e., states in which all processes are waiting, and no progress is possible. Temporal formulas can also be used to find partial deadlocks, in which some processes are involved in a deadlock, but other processes can continue. Generally, in the case of partial deadlock detection, temporal formulas are based on the structure of veriﬁed models, for example, they use key states, as in: AG(LQ.Head.Occ => AF(¬LQ.Head.Occ)) [Kern and Greenstreet, 1999] (whenever the head of the link queue is occupied with a request, this will eventually be processed and the head will be released). This identifies deadlocks in individual processes. Similar methods are described in other papers [Havelund and Skakkebæk, 1999] [Chang and Jackson, 2006] [Beneš et al., 2008] [Cordeiro, 2010] [Inverso et al., 2015] [Arcile et al., 2016]. The disadvantage of this approach is that temporal formulas need to be developed individually for each analyzed system, using its specific features. 
Some other approaches to partial deadlock detection use general temporal formulas (i.e., formu-las not related to the structure of the model being verified), but such general formulas require models to have speciﬁc properties. The Inspect checking tool [Yang et al., 2008], based on dy-namic model verification, does not accept the cyclic reachability spaces. In pairwise model checking [Attie, 2016] the general formula AG EX true is used for each pair of interrelated pro-cesses running in shared memory. 
If the system is non-terminating (cyclical), the discontinuation of the process is obviously a dead-lock [Baier and Katoen, 2008]. Conversely, another method can only be ascribed to terminating processes [Fahland et al., 2011]. Some detection methods are used for speciﬁc systems archi-tectures. For example, the WickedXmas approach uses the nodes communicating through the queues [Joosten et al., 2014]. The speciﬁc method is designed for tree-like component architec-tures [Martens, 2009]. Our approach ﬁnds the discontinuation of individual processes, using general temporal formulas, and it works for any type of system: cyclic, terminating or hybrid - built  of both kinds of processes. Termination, like deadlock, is a kind of process discontinuation (see methods for termination detecting below), but our method distinguishes deadlock and ter-mination.
Another set of static methods applies to Petri nets. Some of them are based on the analysis of the reachability graph of the Petri net [Duri et al., 1994]. The total deadlock (or termination) is a leaf in the reachability graph – there is no outgoing transition. Therefore, the analysis of reacha-bility graph is similar to the model checking techniques and they are usually combined as a tem-poral analysis of the graph. It is difficult to distinguish a deadlock from distributed termination, so these methods are mainly addressed to infinitely looping systems [Guan et al., 2012]. 
Reachability analysis is usually based on the exploration of the entire reachability space. In many models the reachability space can be extremely large. The combinatorial space explosion problem concerns models in which the size of reachability space increases exponentially with the number of concurrent components. Partial order reduction methods provide a way to alleviate the explosion problem by using equivalences of certain sequences. There are methods based on the independence of transitions: for interleaving systems [Godefroid and Wolper, 1992] [Penczek et al., 2000] [Gerth et al., 1999] and for coincidence systems [Daszczuk, 2003]. In the case of Petri nets, stubborn sets were invented which exploit commutativity over the sequences of transitions [Valmari, 1994] [Valmari and Hansen, 2010]. All these methods preserve deadlocks in reduction process. 
Alternatively, structural analysis of Petri net can be used. Structural analysis determines proper-ties of models on the basis of their structure, therefore it is not necessary to explore the reacha-bility space. Structural analysis of deadlocks is based on subnets called siphons [Schmid and Best, 1978] [Chu and Xie, 1997]. It can be shown that if a model is deadlocked, the unmarked places constitute a siphon. Structural analysis of deadlocks systematically finds elementary si-phons. Elementary siphons are those from which other siphons are composed. After identifying the siphons, they are checked for unmarking possibility. Usually, linear programming is used for this purpose. If no elementary siphon can be found that can become emptied, the model is dead-lock-free [Craig and Zuberek, 2008]. 
Many algorithms for deadlock detection are proposed based on finding siphons in a Petri net [Chu and Xie, 1997] [Tricas et al., 2014] [Węgrzyn et al., 2004]. Furthermore, partial deadlock can be found in Petri net, using a method comparable to Wait-for-Graph (searching for processes waiting for resources held by other processes in a cycle [Tricas et al., 2005]). Again, identification of siphons is helpful. Other methods use the conversion of a Petri net to another graph [Bertino et al., 1998].
Some methods use matrix operations, usually to calculate reachability. The Resource Allocation Graph (RAG) is represented by the adjacency matrix. The solution is based on the calculation the powers of the matrix [Ni et al., 2009] [Leibfried, 1989] or the reduction of some columns and rows [Nguyen et al., 2014]. In Petri nets used for modeling manufacturing systems, the analysis of  the machine-job incidence matrix is applied [Petrovic et al., 2009].
In the SCOOP model [Heußner et al., 2015], the source code of the program is converted to a graph in which cyclic-wait discovery is statically applied, similarly to Wait-for Graph analysis.
Model checking techniques usually interrupt the verification when an error is found (i.e., a value of a temporal formula is determined). As the effect, only one error is reported, and after the sys-tem revision, the next verification is needed. Methods based on finding Petri net siphons are bet-ter in this aspect, because all elementary siphons in a given net can be identified in a single run In turn, the strong point of model checking is counterexample generation: a trace leading from initial state to a deadlock state, suitable for analysis of deadlock causes.
The features of various deadlock detection techniques are summarized in Table 2.1.
Table 2.1. Advantages and disadvantages of various deadlock detection techniques
Technique	resource dead-locks	communication deadlocks	resource/comm. distinguishable	reusable resources	consumable resources	total deadlocks	partial deadlocks	distinguishable from termination	deadlock freeness  guaranteed	many deadlocks found
Dynamic WFG-resource	+	-	+	+	+	+	+	+	-	-
Dynamic WFG-communication	-	+	+	-	-	+	+	+	-	-
Pulse	+	+	-	+	+	+	+	+	-	-
Model Checking
AG EX true	+	+	-	+	-	+	-	-	+	-
Petri net siphons	+	+	-	+	+	+	+	-	+	+
IMDS and model check-ing	+	+	+	+	-	+	+	+	+	-
COLUMN HEADINGS:
“resource deadlocks” - resource deadlocks found
“communication deadlocks” - communication deadlocks found
“resource/comm. distinguishable” - resource/communication deadlocks distinguishable
“reusable resources” - deadlocks over reusable resources found
“consumable resources” - deadlocks over consumable resources found
“total deadlocks” - deadlocks with all processes involved
“partial deadlocks” – deadlocks with not all processes involved
“distinguishable from termination” - deadlock distinguishable from termination
“deadlock freeness  guaranteed” - deadlock freeness guaranteed if no deadlock found
“many deadlocks found” – many (possibly all) deadlocks found by siphon analysis

In the detection of resource deadlocks, several semantic models are used [Knapp, 1987]. The simplest is One resource model, in which a process can have at most one outstanding request for a single resource at a time. In the AND model, a process is permitted to request a set of re-sources. It is blocked until it is granted all the resources it has requested. An alternative model of resource requests is the OR model. A request for numerous resources is satisfied by granting any requested resource. The AND-OR model is a generalization of the two previous models, in which the requests may specify any combination of AND and OR in the resource request. The k out of n model allows the specification of requests to obtain any k available resources out of a pool of size n. It is a generalization of the AND-OR model. In the most general model, no under-lying structure of resource requests is assumed.
Because resources in IMDS are not directly included in formalism, each semantics can be mod-eled. The occupation of resources is modeled the servers' states, while granting  of resources is modeled as the messages. Most natural is OR model, because there may be many states matching the agent's message, and any of these states enables the agent. Yet, a server can be constructed in such a way that its state informs of fulfilment of a complicated condition over re-sources, for example in AND-OR or k out of n model.
In the analysis of distributed systems, two kinds of processes discontinuation are observed: an undesired lack of progress (deadlock), which is an error, and an expected stopping called pro-cess termination. Deadlock detection and termination checking methods must distinguish these two kinds of discontinuation [Sharma and Bhargava, 1987], or simply prohibit one of them. This is the reason why many deadlock detection techniques are only addressed to endlessly looping systems in which there is no termination [Baier and Katoen, 2008] [Guan et al., 2012]. 
Just as in a case of deadlock detection, dynamic (runtime) methods of termination detection re-quire some instrumentation of a system. Usually, messages are sent that report the states of particular processes and there is a mechanism to combine them into a global decision on dis-tributed termination [Sharma and Bhargava, 1987] [Dijkstra and Scholten, 1980] [Kumar, 1985]. There are methods diﬀering in instrumentation, dealing with failed processes or link failures, ac-ceptance of temporary network partitioning [Mattern, 1987] [Matocha and Camp, 1998] [Chalopin et al., 2007] [Kshemkalyani and Mukesh, 2008]. Static termination checking methods are based on observation of terminal states of individual processes. Model checking techniques are suitable for this purpose, using either model-speciﬁc formulas [G. Ma, 2007] or general ones [Ray and Ray, 2001]. Construction of Counting Agent [Garanina and Bodin, 2014] can be applied both dynamically and statically. Transition invariants [Podelski and Rybalchenko, 2003] allow to check whether every execution that starts in the initial state is ﬁnite (terminating).
In the monograph, we propose the application of IMDS, which highlights locality of properties of verified system and exploits communication dualism (message passing/resource sharing). In conjunction with model checking, IMDS allows the expression and detection of a partial deadlock and the distinction between deadlock and distributed termination. Moreover, the new method allows distinguishing between a resource deadlock and a communication deadlock.
The comparison includes dynamic methods to provide a broad overview of deadlock detection and distributed termination methods. Our method is static and requires calculation of total reachability space. The novelty consists in specification of general temporal formulas over the IMDS model, for partial deadlocks and termination, and to distinguish deadlock from distributed termination and communication deadlocks from resource deadlocks. The formulas are general because they are not related to the structure of the system being verified. General formulas allow the designer to verify without knowledge of temporal logic. The Dedan program is based on this paradigm and allows verification in the "push the button" style, because model checking techniques are hidden inside the Dedan tool.   

3.	Integrated Model of Distributed Systems
The IMDS formalism ([Chrobot and Daszczuk, 2006] [Daszczuk, 2008]) is designed to describe closed systems, i.e., systems in which the behavior does not depend upon external events. Static model verification, aimed at verifying correctness, applies only to closed systems. 
A distributed system is composed of servers and agents. Servers model nodes of a distributed system, while agents model distributed computations. Servers execute actions which are requested by agents. The requests have the form of messages. It is assumed that messages are immediately available to target servers (without looking into technical aspects of message delivery). When an action requested by a message is executed (on a server), the server changes its state and the agent issues the next message. Alternatively – when there is no message generated – the agent terminates.
3.1.	Basic IMDS definition
The essence of the IMDS approach is to describe the system using two sets and a binary relation on the Cartesian product of these two sets. The sets are: 
P = {p1,p2,…} – the finite set of states (of servers)	(3.1)
M = {m1,m2,…} – the finite set of messages (of agents)
while the action relation  is a binary relation on M  P:
  (MP)  (MP) – the set of actions	(3.2)
For the elements of  we use the notation ,  = ((m,p),(m’,p’)) = (m,p)(m’,p’).
The execution of the action (requested in the message) changes the state of the server and issues another message (by the agent). Thus, the action execution transforms the current state and the pending message into the next state and the next message.
In the action (m,p)(m’,p’) we say that:
•	the pair (m,p) match;
•	(m,p) is the input pair;
•	(m’,p’) is the output pair;
•	the state p is current;
•	the message m is pending (we use also a term current message);
•	p’ is the next state;
•	m’ is the next message.
The definition must be supplemented by the initial sets of states and messages:
Pini  P – the set of initial states	(3.3)
Mini  M – the set of initial messages
In the example of the system presented in Fig. 1.2, the sets and the relation are:
P = {p_neutral, produce, c_neutral, consume, 0, 1, 2}
M = {p_doSth, put, ok_put, c_doSth, get, ok_get}
 = {((p_doSth, p_neutral),(p_doSth, p_neutral)), ((p_doSth, p_neutral),(put, produce)), ((ok_put, produce),(p_doSth, p_neutral)), ((put, 0),(ok_put, 1)), ((put, 1),(ok_put, 2)),
((c_doSth, c_neutral),(c_doSth, c_neutral)), ((c_doSth, c_neutral),(get, consume)), ((ok_get, consume),(c_doSth, c_neutral)), ((get, 1),(ok_get, 0)), ((get, 2),(ok_get, 1))}
Pini = {p_neutral, c_neutral, 0}
Mini = {p_doSth, c_doSth}
The equal names of states and messages used in more than one server are preceded by “p_” for producer and by “c_” for consumer.
3.2.	IMDS system behavior
The behavior of a system described in IMDS is represented by a Labeled Transition Systems (LTS [Reniers and Willemse, 2011]), i.e., a rooted labeled directed graph.
For LTS representing the behavior of an IMDS system, the nodes are system configurations  (sets of current states and pending messages), the root is the initial configuration and the set of labels is the set of actions of the system. The system starts with Pini and Mini, therefore the initial configuration is a union of them. The states and messages together are called items. The set of directed arcs is determined by the actions, which convert their input configurations to their output configurations.
H = P M – the set of items	(3.4)
Tini = Pini Mini – the initial configuration
TH – the configuration
The rule of obtaining Tout() from Tinp() for the action  is:
    = ((m,p),(m’,p’))  Tinp(){m,p}, Tout()=Tinp()\{m,p}{m’,p’} 	(3.5)
LTS = N,n0,W, where:	(3.6)
−	N is the set nodes (configurations {T0,T1,...}, Tini= T0);
−	n0 is the root, n0  N (configuration Tini);
−	W is the set of directed labeled transitions, W  N    N, 
W = { (Tinp(),,Tout()) | }.
As single actions are LTS labels, this means the interleaving semantics of the system [Penczek et al., 2000], i.e., one action is executed at a time . The execution of the action transforms the input configuration to the output configuration in such a way that the input pair (message, state) is removed and replaced by the output pair (next message, next state). The items (messages and states) not included in the input pair remain unchanged. The LTS contains all possible runs of the system as paths in the graph. 
A fragment of LTS for the example in Fig. 1.2 is presented in Fig. 3.1.
 
3.3.	IMDS processes
The system starts from the initial states of all servers (one state for each server) and the initial messages of all agents (one message for each agent). In the action, the input message must be directed to the server appointed by the input state, because the action is executed on the server. The next state generated in the action appoints the same server as the input state. This ensures continuity of the server behavior. Likewise, the next message generated in the action appoints the same agent as the input message. This ensures continuity of the agent behavior. 
The formal definition of IMDS for the purpose of processes extraction follows:
S = {s1,s2,…} – the finite set of servers	(3.7)
A = {a1,a2,…} – the finite set of agents
P(s) = {p1s,p2s,…}, sS – the finite set of states of server s
M(a) = {m1a,m2a,…}, aA – the finite set of messages of agent a
M(s) = {m1s,m2s,…}, sS – the finite set of messages directed to server s
For the elements of sets P(s), M(a) and M(s), we say that these elements appoint corresponding server, agent and server, respectively.
The sets in the example are (initial elements are highlighted by boldface): 
S = {Sprod, Scons, Sbuf}
A = {Aprod, Acons}
P(Sprod) = {p_neutral, produce}, P(Scons) = {c_neutral, consume}, P(Sbuf) = {0, 1, 2}
M(Aprod) = {p_doSth, put, ok_put}, M(Acons) = {c_doSth, get, ok_get}
M(Sprod) = {p_doSth, ok_put}, M(Scons) = {c_doSth, ok_get}, M(Sbuf) = {put, get}
The constraints on P, M and , needed for process extraction, are the following:
P = sS P(s), s1,s2S s1s2 P(s1)P(s2)= – every state is attributed to some server	(3.8)
M = aA M(a)=sS M(s), a1,a2A a1a2 M(a1)M(a2)=, s1,s2S s1s2 M(s1)M(s2)= – every message is attributed to some agent and is directed to some server
The constraints on input and output pairs of the action are: the input state and input message concern the same server; the input and output states concern the same sever, the input and output messages concern the same agent:
    = ((m,p),(m’,p’)),  mM(a)m’M(a), pP(s)p’P(s)  mM(s).	(3.9)
sS card(P(s)Pini)=1 – the initial set of states contains exactly one state for every server	
aA card(M(a)Mini)=1 – the initial set of messages contains exactly one message for every agent
We add a new type of agent-terminating action (m,p)(p’), in which the next message is absent: 
  (MP) x (MP)  (MP) x (P) – the set of actions 
The constraints on the input pair and the output singleton in an agent-terminating action are:
    = ((m,p),(p’)),  pP(s)p’P(s)  mM(s).	(3.10)
The rule of obtaining Tout() from Tinp() for an agent-terminating action is:
    = ((m,p),(p’)),  Tinp(){m,p}, Tout()=Tinp()\{m,p}{p’}.	(3.11)
The definition of Tini together with rules of obtaining Tout from Tinp, ensure that every configuration contains exactly one state for every server and at most one message for every agent (except for terminated agents).
Asynchronous sequential processes in the system are defined as sequences of actions. Note that the two output items of each action (or one output item only for the agent-terminating action) can be input items of other actions. Thus a sequence of actions is threaded by intermediate items. If we choose states as a process carrier – we get the server process running along with the changing server states. The states between actions define the succession relation between actions. In this perspective, intermediate messages are passed between actions of distinct processes: they serve as communication means between servers. Note that the server processes do not terminate (in the sense of terminating action) the output state is present in each action.
On the other hand, we can choose messages for threading actions. In this perspective, the agent's messages form the agent's process. The messages between actions define the succession relation between actions. The process runs along its messages while visited servers’ states are the communication means with other agents. Because there can exist actions without an output message – the agent process can terminate. 
B(s) = <1,2,…> | i =1,… i;  	(3.12)
1 = ((m,p),(m1,p1))  1 = ((m,p),(p1)), pPini P(s) ;
i>1 i-1 = ((m,p),(m1,p1))  i-1 = ((m,p),(p1)), i = ((m2,p2),(m3,p3))  i = ((m2,p2),(p3)), 
p1, p2P(s), p1 = p2 – the server process of the server s: the first action of the process has the initial state of the server s on input, all the threading states appoint the server s.
C(a) = <1,2,…> | i =1,… i; 
1 = ((m,p),(m1,p1))  1 = ((m,p),(p1)), mMini M(a) ;
i>1 i-1 = ((m,p),(m1,p1)), i = ((m2,p2),(m3,p3))  i = ((m2,p2),( p3)), m1,m2M(a), m1= m2 – the agent process of the agent a: the first action of the process has the initial message of the agent a on input, all the threading messages appoint the agent a.
We call the processes asynchronous sequential, because:
•	action sequences come from their definition; 
•	asynchrony comes from the feature that always a state waits for a message or a message waits for a matching state (and, at the same time, a state waits for a matching message).
Note that:
•	A process can have more than one starting node if more than one action can appear first in the process. For example, the process Sprod Fig. 3.2 can begin from the putting action (p_doSth, p_neutral)(put, produce), of from doing-something-else action (p_doSth, p_neutral)(p_doSth, p_neutral) which is a self-transition not shown in Fig. 3.2a (but shown in Figs. 3.1 and 3.2b)
•	The process may be a branched graph if there is non-determinism in the action set: it may be possible to perform multiple actions for a given state or for a given message.
•	Some paths in the graph may be finite if there is an action that terminates the agent’s operation, or if no action is defined for a given state/message (this is not considered a process termination).
For the “Bounded buffer” example in Fig. 1.2, Fig. 3.2 presents server processes. The graph in Fig. 3.2b is converted by joining equal actions. Fig. 3.3 shows one of the agent processes (Aprod). 
3.4.	Views of a distributed system
The action sets of individual server processes are disjoint. The same concerns actions of agent processes. But there can be “orphan” actions, which do not belong to any server/agent. This can occur when an action has a state/message on input, which is neither initial nor present on output of any action belonging to any process. An orphan action denotes existence of unreachable, or “dead” code. To avoid such situations, in which there are actions not belonging to any process, other definition of processes is possible, grouping actions of individual servers/agents to sets:
B(s) = {  |  = ((p,m),(p’,m’))   = ((p,m),(p’)), pP(s)} – the server process of the server s	(3.13)
C(a) = { |  = ((p,m),(p’,m’))   = ((p,m),(p’)), mM(a)} – the agent process of the agent a
In the “Bounded buffer” example from Fig. 1.2, the processes defined as sets of actions are:
B(Sprod) =	{ (p_doSth, p_neutral)(p_doSth, p_neutral), (p_doSth, p_neutral)(put, produce), (ok_put, produce)(p_doSth, p_neutral) }
B(Scons) =	{ (c_doSth, c_neutral)(p_doSth, p_neutral), (c_doSth, c_neutral)(get, consume), (ok_get, consume)(c_doSth, c_neutral) }
B(Sbuf) =	{ (put, 0)(ok_put, 1), (put, 1)(ok_put,2), (get, 1)(ok_get, 0), (get, 2)(ok_get, 1) }
C(Aprod) =	{ (p_doSth, p_neutral)(p_doSth, p_neutral), (p_doSth, p_neutral)(put, produce), (put, 0)(ok_put, 1), (put, 1)(ok_put,2), (ok_put, produce)(p_doSth, p_neutral) }
C(Acons) =	{ (c_doSth, c_neutral)(c_doSth, c_neutral), (c_doSth, c_neutral)(get, consume), (get, 1)(ok_get, 0), (get, 2)(ok_get, 1), (ok_get, consume)(c_doSth, c_neutral) }
Having all actions included in processes, we obtain the system decomposed into processes. Two decompositions into asynchronous sequential processes give the two system views:
  B = {B(s) | sS} – the server view	(3.14)
C = {C(a) | aA} – the agent view
In the example:
B = {B(Sprod), B(Scons), B(Sbuf)}
C = {C(Aprod), C(Acons)}
Many system properties can be verified using the model checking technique. This monograph focuses on deadlock and distributed termination properties [Chandy and Lamport, 1985]. Different features can be observed in different views (i.e., server view or agent view), as shown in Section 3.7.  
3.5.	IMDS as a Programming Language
In the basic IMDS definition, states and messages were defined as simple, indivisible entities. In the Dedan program designed for verification of distributed systems, IMDS is used as the specification language. To be able to define server types and agent types, and declare variables of these types, it is better to specify a server state as a pair (server, value). A message can also be defined as a pair (agent, target server). However, the agent can call various server operations, for example P and V operations on the semaphore. These operations will be called “services”. Messages are therefore defined as triples (agent, server, service). In such a formulation, a message is an invocation of a server’s service by an agent. Below is a formal definition of actions in terms of states as pairs and messages as triples. 
The basic sets are servers, agents, values and services: 
S = {s1,s2,...} – the finite set of servers 
A = {a1,a2,...} – the finite set of agents 
V = {v1,v2,...} – the finite set of values 
R = {r1,r2,...} – the finite set of services 
The servers’ states are defined as pairs (server, value) and the messages as triples (agent, server, service). In such a formulation, a message is an invocation of a server’s service by an agent. An action is an execution of a service on a server in a context of an agent. 
P  S  V – the set of states 
M  A  S  R – the set of messages
The constraints on states and messages expressed in the new formulation in the input and output items of the action are:
  (MP)  (MP)  (MP)  (P) | (m,p)(m’,p’)  (m,p)(p’), 
m = (a,s,r)  M, p=(s1,v1)  P, m’=(a2,s2,r2)  M, p’=(s3,v3)  P, s1 = s, s3 = s, a2=a
The new definition of server and agent processes follows (equivalent to the previous one):
B(s) =	{ |  = (((a,s,r),(s,v)), ((a,s’,r’),(s,v’)))   = (((a,s,r),(s,v)), ((s,v’))), s’S, aA, v,v’V, r,r’R } – the server process of the server sS
C(a) =	{ |  = (((a,s,r),(s,v)), ((a,s’,r’),(s,v’)))   = (((a,s,r),(s,v)), ((s,v’))), s,s’S, v,v’V, r,r’R } – the agent process of the agent aA

In the Dedan program, and in the rest of the monograph, we use the notation s.v and a.s.r for pairs (s,v) and triples (a,s,r), and the notation {a.s.r, s.v}{a,s’.r’, s.v’} for actions ((a,s,r),(s,v))((a,s’,r’),(s,v’)). The “Bounded buffer” example from Fig. 1.2, depicted graphically using the presented notation, is shown in Fig. 3.4.
The source code of the example is given below. It is a development of a system shown in Fig. 1.2. The example is presented informally in Fig. 3.4. It is the server view of a system consisting of a producer, a consumer and a buffer. Server names are preceded by ‘S’, and agent names are preceded by ‘A’. Messages are input and output symbols on transitions leading from one server state to another. The rules for this figure (and consecutive ones) are : 
•	every server is depicted as separate automaton-like graph of Mealy type [Dick and Yao, 2014],
•	nodes of an automaton are the server’s states,
•	initial node (initial state) is surrounded by bold ellipse,
•	initial messages of the agents are in bold font,
•	transitions are actions,
•	transitions are labeled by input symbol (input message) / output symbol (output message).
In the example, three servers cooperate: the buffer containing 0, 1 or 2 elements, the producer spontaneously making new elements and then sending them to the buffer, and the consumer retrieving the elements from the buffer and destroying them. A message invoking a buffer’s action is accepted if the operation is possible, for example putting to a full buffer is prohibited. Consider the upper-left action in Sbuf server: the buffer is empty (a value elem_0 denotes 0 elements in the buffer) and the message of Aprod agent is pending at Sbuf. The message invokes a put service of Sbuf server. The execution of the action inserts an element to the buffer: it changes its state from a value elem_0 to a value elem_1. On finishing of the execution of the put service, the Sbuf server issues a message of the same agent Aprod to the server Sprod, invoking its service ok_put. Note that in the state elem_2 of the server Sbuf a message invoking a service put cannot be accepted. If it is received, it remains pending (it is not shown in the figure, see the definition of distributed server automata is Section 8.1).
The full source code of the buffer example, extended to sets of producers and consumers (instead of single producer and single consumer in Fig. 3.4) in the server view is as follows:
 1	system	BUF_server_view;

 2	#DEFINE N 2
 3	#DEFINE M 2
 4	#DEFINE K 2
 
 5	server:	Sbuf(agents Aprod[N],Acons[M]; servers Sprod[N],Scons[M]),  
 6	services	{put, get},
 7	states	{elem0,elem[K]},								
 8	actions{
 9	<i=1..N>	{Aprod[i].Sbuf.put, Sbuf.elem0} -> 
{Aprod[i].Sprod[i].ok_put, Sbuf.elem[1]},			
10	<i=1..N><j=1..K-1>	{Aprod[i].Sbuf.put, Sbuf.elem[j]} -> {Aprod[i].Sprod[i].ok_put, Sbuf.elem[j+1]},	
11	<i=1..M><j=2..K>	{Acons[i].Sbuf.get, Sbuf.elem[j]} -> {Acons[i].Scons[i].ok_get, Sbuf.elem[j-1]},	
12	<i=1..M>	{Acons[i].Sbuf.get, Sbuf.elem[1]} -> {Acons[i].Scons[i].ok_get, Sbuf.elem0}
13	}

14	server:	Sprod(agents Aprod; servers Sbuf),
15	services	{doSth,ok_put}
16	states	{neutral,prod}
17	actions	{	
18	{Aprod.Sprod.doSth, Sprod.neutral} -> {Aprod.Sbuf.put, Sprod.prod}
19	{Aprod.Sprod.ok_put, Sprod.prod}	-> {Aprod.Sprod.doSth, Sprod.neutral}
20	}

21	server:	Scons(agents Acons; servers Sbuf),
22	services	{doSth,ok_get}
23	states	{neutral,cons}
24	actions	{	
25	{Acons.Scons.doSth, Scons.neutral} -> {Acons.Sbuf.get, Scons.cons}
26	{Acons.Scons.ok_get, Scons.cons}	-> {Acons.Scons.doSth, Scons.neutral}
27	}

28	servers 	Sbuf,Sprod[N],Scons[M];
29	agents	Aprod[N],Acons[M];	
 
30	init ->	{ 
31	<j=1..N>	Sprod[j](Aprod[j],Sbuf).neutral,
32	<j=1..M>	Scons[j](Acons[j],Sbuf).neutral,
33	  		Sbuf(Aprod[1..N],Acons[1..M],Sprod[1..N],Scons[1..M]).elem0,

34	<j=1..N>	Aprod[j].Sprod[j].doSth, 			
35	<j=1..M>	Acons[j].Scons[j].doSth,
36	}.		

The notation is intuitive; the (optional) header contains the system name (line 1). The server types are defined first (l.5,14,21), then servers (l.28), agents (l.29) and initialization part (l.30). A server type consists of formal parameters defining servers and agents used (l.14), server’s services (l.15), states (l.16) and the actions of the server (l.9-12). Since the vectors in the Dedan program are numbered from 1, the 0th state of the buffer is defined separately. In initialization part, actual parameters (agents and servers) are passed to every server (l.31-33) and initial state of every server is defined after the dot. For every agent, an initial message is defined (l.34,35).
The system converted to the agent view is given below. It is a manual conversion, to preserve the constants M, N and K. This is the only difference between the manual and the automatic conversion: the program Dedan performs the conversion automatically, but the constants disappear in the process due to preprocessing.
 1	system BUF_agent_view;

 2	#DEFINE N 2
 3	#DEFINE M 2
 4	#DEFINE K 2

 5	server:	Sbuf,
 6	services	{put, get}
 7	states	{elem0, elem[K]}
 8	;
 9	server:	Sprod,
10	services	{doSth, ok_put}
11	states	{neutral, prod}
12	;
13	server:	Scons,
14 	services	{doSth, ok_get}
15	states	{neutral, cons}
16	;
17	agent:	Aprod (servers Sbuf,Sprod),
18	actions 	{
19	<j=1..K-1>	{Aprod.Sbuf.put, Sbuf.elem[j]} -> {Aprod.Sprod.ok_put, Sbuf.elem[j+1]},
20		{Aprod.Sbuf.Sput, Sbuf.elem0} -> {Aprod.Sprod.ok_put, Sbuf.elem[1]},
21		{Aprod.Sprod.doSth, Sprod.neutral} -> {Aprod.Sbuf.put, Sprod.prod},
22		{Aprod.Sprod.ok_put, Sprod.prod} -> {Aprod.Sprod.doSth, Sprod.neutral},
23	};

24	agent:	Acons (servers buf,Scons),
25	actions 	{
26		{Acons.Sbuf.get, Sbuf.elem[1]} -> {Acons.Scons.ok_get, Sbuf.elem0},
27	<j=2..K>	{Acons.Sbuf.get, Sbuf.elem[j]} -> {Acons.Scons.ok_get, Sbuf.elem[j-1]},
28		{Acons.Scons.ok_get, Scons.cons} -> {Acons.Scons.doSth, Scons.neutral},
29		{Acons.Scons.doSth, Scons.neutral} -> {Acons.Sbuf.get, Scons.cons},
30	};

31	agents	Aprod[M], Acons[N];
32	servers	Sbuf, Sprod[M], Scons[N];

33	init -> 	{
34	<j=1..M>	Aprod[j](Sbuf,Sprod[j]).Sprod[j].doSth,
35	<j=1..N>	Acons[j](Sbuf,Scons[j]).Scons[1].doSth,

36		Sbuf.elem0,
37	<j=1..M>	Sprod[j].neutral,
38	<j=1..N>	Scons[j].neutral,
39	}.

The (optional) header contains the system name (line 1). The server types are defined first (l.5,9,13). They contain only service and state definitions, as the actions are attributed to the agents. The agent types are defined separately (l.17,24). Then, there are declarations of agents (l.31), servers (l.32) and initialization part (l.33). The agent type consists of formal parameters defining servers used (l.17) and the actions of the agent (l.19-22). In the initialization part, actual parameters (servers) are passed to every agent (l.34-35) and the initial message of every agent is defined. For every server, the initial state is defined (l.36-38). The formal syntax of IMDS is given in Appendix C.
The presented input of the Dedan program follows IMDS formulation and it is uncomfortable for programmers. Therefore, the Rybu preprocessor for imperative-like programming was developed by the students of ICS, WUT under the supervision of the author [Daszczuk et al., 2017]. The students of second-year studies use the Rybu language in verification of their synchronization solutions. More details on Rybu are given in Section 5.8.
3.6.	Semantics
The semantics of modeled system is defined by a Labeled Transition System (LTS, Section 3.2, [Reniers and Willemse, 2011]), in which the nodes are system configurations and transitions are actions. 
If the items p and m match in the configuration, then an action having p and m on input can be executed. We say that the action is prepared (or enabled) in the configuration containing p and m. The execution of the action is called firing the action. We assume interleaving semantics [Glabbeek and Goltz, 1990] [Winskel and Nielsen, 1995], i.e., only one of the prepared actions is fired at a time.
Note that the actions prepared on the same server are always in conflict, as each of them “consumes” the current server’s state.
On the other hand, the actions prepared on separate servers are always independent. The firing of the action on a given server does not affect the prepared actions on other servers. They remain prepared, although the action can add a new prepared action on some server.
The Labeled Transition System (LTS=<N,n0,W>, see Section 3.2) is defined by the set of nodes N, root node n0 and the set of transitions W. The nodes are the system configurations (with the root node being the initial configuration) and the transitions are actions. Such an LTS contains all possible executions of the system.
Nondeterminism is modeled as diverging branches in the LTS. IMDS provides three kinds of nondeterminism:
•	nondeterminism between servers – if there are prepared actions on distinct servers, the action to fire is chosen in nondeterministic way,
•	nondeterminism in server – if the current state matches pending messages of more than one agent – an action to fire is chosen nondeterministically,
•	nondeterminism in agent – if more than one action is prepared with matching state and message – an action to fire is chosen nondeterministically.
The system is assumed to act fair, i.e., if the action is prepared infinite number of times – it must be fired. In other words, if there is an escape from the loop in the LTS, then after the finite number of cycles in the loop, the escape action must be selected. Thus, no part of LTS is left as “dead code” because on unfairness.
Usually, the LTS is large, therefore it cannot be observed manually in its entirety. A tiny example “different strokes – different folks” is prepared to show the entire LTS. The system consists of three servers. There is a single TV set, and there are two people: the boy switches to sport while the girl switches to the music program. The TV server has two states: sport and music. The services of the TV server are pushing the buttons: b1 and b2 switching to sport and music, respectively. An initial state of TV should be chosen, say: sport. The server view is as follows (graphical representation in Fig. 3.5, the rules are the same as for Fig. 3.4):
system	strokes;

server:	TV (agents Aboy,Agirl; servers Sboy,Sgirl),
states	{sport, music}
services	{b1,b2}
actions	{
		{Aboy.TV.b1, TV.sport} -> {Aboy.Sboy.ok, TV.sport},
		{Aboy.TV.b1, TV.music} -> {Aboy.Sboy.ok, TV.sport},
		{Agirl.TV.b2, TV.sport} -> {Agirl.Sgirl.ok, TV.music},
		{Agirl.TV.b2, TV.music} -> {Agirl.Sgirl.ok, TV.music},
};
server:	Sboy (agents Aboy; servers TV),
states	{wait, watch}
services	{switch, ok}
actions	{
		{Agirl.Sgirl.switch, Sgirl.watch} -> {Agirl.TV.b2, Sgirl.wait},
		{Agirl.Sgirl.ok, Sgirl.wait} -> {Agirl.Sgirl.switch, Sgirl.watch},
};
server:	Sgirl (agents Agirl; servers TV),
states	{wait, watch}
services	{switch, ok}
actions	{
		{Aboy.Sboy.switch, Sboy.watch} -> {Aboy.TV.b1, Sboy.wait},
		{Aboy.Sboy.ok, Sboy.wait} -> {Aboy.Sboy.switch, Sboy.watch},
};

servers	TV,Sboy,Sgirl;
agents	Agirl,Aboy;
init ->	{
		TV(Aboy,Agirl,Sboy,Sgirl).sport,
		Sboy(Aboy,TV).watch,
		Sgirl(Agirl,TV).watch,
		Aboy.Sboy.switch,
		Agirl.Sgirl.switch,
}.

The LTS of the strokes system is presented in Fig. 3.6. The nodes show configurations: pending messages of both agents (Agirl and Aboy) and states of all three servers (TV, Sgirl and Sboy). The initial configuration has a bold border. Every configuration has two successors, because of nondeterministic choice: “between servers” when agents have pending messages at different servers or “in server” when both agents have pending messages at TV. Nondeterminism in agent is not modeled in this example, but it can be observed in “philosophers” systems (Section 5.2), the philosopher when he thinks, may decide to continue thinking or taking a fork. 
3.7.	Deadlock and termination
We define deadlock as a situation in which a process that is not terminated, cannot continue (at the moment and in the future). The deadlock should be defined separately for the server process and for the agent process, since they have different characteristics.
First consider a server process. The following situations can occur:
•	the current state matches some of messages pending at the server – an action is prepared and it can be fired; the server process runs;
•	the current state does not match any message pending at the server (or no message is pending) – a matching message may occur at the server in the future; the server process waits;
•	neither a message is pending at the server nor a message will occur at the server in the future; the server process is idle;
•	there are messages pending at the server, but the current state does not match any of the pending messages, and no matching message may occur at the server in the future; the server process is in deadlock.
The former two cases are normal operation of the server process. The third case means that the server will not change its state – the current state will be current forever. This is not an error, just no other server wants any service offered by the given server. The last case is a deadlock – some messages wait to be served, but neither the current state matches any of them nor it will match in the future. The cases can be distinguished during the analysis of the LTS.
The server process never terminates – the next state is obligatory in every action, although one may treat the idleness situation as a termination.
Consider the agent process. The cases are:
•	the agent’s message is pending at a server and it matches the current state of this server – the action is prepared and it can be fired; the agent runs;
•	the agent’s message is pending at a server and it does not match the current state of this server, but a matching state may occur in the future; the agent waits;
•	the agent’s message is pending at a server and neither the current state of this server matches the message nor such a state may occur in the future; the agent fell into a deadlock;
•	there is no agent’s message – the agent process is terminated.
The former two cases are the normal operation of the agent process. The third case is a deadlock – there is a message to be serviced but this will never happen. The last case means that the process is terminated. Again, the cases can be distinguished by the analysis of the LTS.
References
Chandy K M, and Lamport L. (1985). Distributed snapshots: determining global states of distributed systems. ACM Transactions on Computer Systems, 3(1), 63–75. doi: 10.1145/214451.214456
Chrobot S, and Daszczuk W B. (2006). Communication Dualism in Distributed Systems with Petri Net Interpretation. Theoretical and Applied Informatics, 18(4), 261–278. url: https://deepai.org/publication/communication-dualism-in-distributed-systems-with-petri-net-interpretation
Daszczuk W B. (2008). Deadlock and termination detection using IMDS formalism and model checking, Version 2, ICS WUT Research Report No.2/2008.
Daszczuk W B, Bielecki M, and Michalski J. (2017). Rybu: Imperative-style Preprocessor for Verification of Distributed Systems in the Dedan Environment. In KKIO’17 – Software Engineering Conference, Rzeszów, Poland, 14-16 Sept. 2017 (pp. 135–150). Polish Information Processing Society. url: https://arxiv.org/abs/1710.02722
Dick G, and Yao X. (2014). Model representation and cooperative coevolution for finite-state machine evolution. In 2014 IEEE Congress on Evolutionary Computation (CEC), Beijing, China, 6-11 July 2014 (pp. 2700–2707). New York, NY: IEEE. doi: 10.1109/CEC.2014.6900622
Glabbeek R J, and Goltz U. (1990). Equivalences and refinement. In LITP Spring School on Theoretical Computer Science La Roche Posay, France, 23–27 April 1990, LNCS 469 (pp. 309–333). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-53479-2_13
Penczek W, Szreter M, … Kuiper R. (2000). Improving Partial Order Reductions for Universal Branching Time Properties. Fundamenta Informaticae, 43(1–4), 245–267. doi: 10.3233/FI-2000-43123413
Reniers M A, and Willemse T A C. (2011). Folk Theorems on the Correspondence between State-Based and Event-Based Systems. In 37th Conference on Current Trends in Theory and Practice of Computer Science, Nový Smokovec, Slovakia, 22-28 Jan. 2011, LNCS vol. 6543 (pp. 494–505). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-642-18381-2_41
Winskel G, and Nielsen M. (1995). Models for concurrency. Handbook of logic in computer science (vol.4). (S. Abramsky, D. M. Gabbay, & T. S. E. Maibaum, Eds.). Oxford, UK: Oxford University Press.

4.	Model Checking of IMDS specifications in the Dedan environment
The LTS of a system can be analyzed manually or using graph algorithms. However, the LTS can be interpreted as the Kripke Structure [Clarke et al., 1999]: finite set of nodes (we do not call them states to avoid ambiguity) – configurations, root node – initial configuration, a total transition relation – actions, naturally assignable labeling (see later). This allows the application of model checking techniques to analyze the graph, especially to find deadlocks and check termination of processes.
A communication deadlock occurs when the current server’s state does not match any message pending at the server, and no matching message may occur at the server in the future. In other words, some messages are pending but no action will be fired on the server. We label the LTS nodes using the Boolean formulas (only configurations with true labels are described, false is for all remaining configurations): 
•	Ds – true in all configurations where at least one message is pending at the server s,
•	Es – true in all configurations where at least one action is prepared at the server s.
The formulas checking if the server s falls into a communication deadlock or to an idle state are given in Table 4.1, features dds(s) and idle(s), respectively. Properties are given both in LTL and CTL temporal logic, as the Dedan program cooperates with three external model checkers: Spin (using LTL [Holzmann, 1995] [Holzmann, 1997]), NuSMV (using CTL [Cimatti et al., 2000]), and Uppaal (using CTL [Behrmann et al., 2006]).	
A resource deadlock (or deadlock over resources) occurs when the agent process' message is pending at the server but it will never match any state of this server. We need the following label-ling of the LTS (Fa is for finding agent termination):
•	Da – true in all configurations where a message of the agent a is pending,
•	Ea – true in all configurations where an action is prepared with a message of the agent a,
•	Fa – true in all configurations where a terminating action (with a message of the agent a on input) is prepared.
The formula that checks if the agent a falls into a resource deadlock is given in Table 4.1, feature dda(a). 
An agent termination term(a) (no message of the agent pending) is also included. Of course, other properties can be added, provided that the proper labeling is applied on the LTS nodes.
Table 4.1. Temporal formulas for finding various situations in processes
property		LTL	CTL
communication deadlock in server s: dds(s)	 (Ds  Es)	EF AG (Ds  Es)
server s idle: idle(s)	 (Ds)	AF AG (Ds)	
resource deadlock in agent a: dda(a)	 (Da  Ea)	EF AG (Da  Ea)	
termination of agent a: term(a)	 (Fa)	AF (Fa)	

Note that finding deadlocks concerns individual processes, not the entire system. This feature differs the presented technique from other deadlock detection approaches by static model checking.
The presented IMDS formalism, combined with model checking using general formulas, satisfies the desired features in modeling and verification of distributed systems:
•	Communication duality: each system can be decomposed either to server processes communicating via messages (the action’s output state is the server’s process carrier, while the output message is a communication means between servers) or to agent processes communicating via servers' states (the action’s output message is the agent’s process carrier, while the output state is a communication means between the agents).
•	Locality: each action on the server is executed on a basis of the current state of this server and the set of messages pending at this server. The server does not have ac-cess to any global or non-local variables. No external event (except messages re-ceived by the server) affects the behavior of the server.
•	Autonomy: each server autonomously decides, which of the prepared actions will be executed and when (the LTS contains all possible scenarios). In other words, the servers autonomously decide if and when the communication would be accepted and what activities it will result.
•	Asynchrony: the server accepts the message when it is ready for it, otherwise the message is pending; there is no synchrony in the model - no simultaneous activities of servers or agents, such as synchronous transitions on common symbols in Büchi automata [Holzmann, 1995] or Timed Automata [Alur and Dill, 1994], synchronization on send and receive operations in CSP [Hoare, 1978] [Lanese and Montanari, 2006], Occam [May, 1983] or Uppaal timed automata [Behrmann et al., 2006], synchronous operations on complementary input and output ports in CCS [Milner, 1980] [Lanese and Montanari, 2006]. Autonomy of servers and agents is implemented by means of asynchronous operations: sending a message to the server is the only way to influ-ence its behavior; setting a new value of the server's state is the only way to influence the behavior of agents visiting the server.
•	Asynchronous channels: communication between the servers is unidirectional (com-munication in the opposite direction, if present, has its own channel), and may seem synchronous, because the message appears at a receiving server just when it is sent. However, asynchrony is modeled by possible deferring the reaction to the message (the message may wait for a long time before it is accepted). In the timed model (Chapter 10), the propagation time can be directly assigned to the communication channel.
•	Automated verification: the temporal formulas are used to locate communication deadlocks in individual server processes, servers' idleness, resource deadlocks in agent processes and agents termination – regardless of a structure of the verified system - that is why they are the basis for building of automatic verifier Dedan. The program can be used without knowledge of temporal logics and model checking. Temporal logic formulas are "wired" in Dedan itself.
References
Alur R, and Dill D L. (1994). A theory of timed automata. Theoretical Computer Science, 126(2), 183–235. doi: 10.1016/0304-3975(94)90010-8
Behrmann G, David A, and Larsen K G. (2006). A Tutorial on Uppaal 4.0. Aalborg, Denmark. url: http://www.it.uu.se/research/group/darts/papers/texts/new-tutorial.pdf
Cimatti A, Clarke E M, … Roveri M. (2000). NUSMV: A new symbolic model checker. International Journal on Software Tools for Technology Transfer, 2(4), 410–425. doi: 10.1007/s100090050046
Clarke E M, Grumberg O, and Peled D A. (1999). Model Checking. Cambridge, MA: MIT Press.
Hoare C A R. (1978). Communicating sequential processes. Communications of the ACM, 21(8), 666–677. doi: 10.1145/359576.359585
Holzmann G J. (1995). Tutorial: Proving properties of concurrent systems with SPIN. In 6th International Conference on Concurrency Theory, CONCUR’95, Philadelphia, PA, 21–24 Aug. 1995 (pp. 453–455). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-60218-6_34
Holzmann G J. (1997). The model checker SPIN. IEEE Transactions on Software Engineering, 23(5), 279–295. doi: 10.1109/32.588521
Lanese I, and Montanari U. (2006). Hoare vs Milner: Comparing Synchronizations in a Graphical Framework With Mobility. Electronic Notes in Theoretical Computer Science, 154(2), 55–72. doi: 10.1016/j.entcs.2005.03.032
May D. (1983). OCCAM. ACM SIGPLAN Notices, 18(4), 69–79. doi: 10.1145/948176.948183
Milner R. (1980). A Calculus of Communicating Systems, LNCS vol. 92. (R. Milner, Ed.) (Vol. 92). Berlin, Heidelberg: Springer Berlin Heidelberg. doi: 10.1007/3-540-10235-3

5.	Deadlock detection examples: the Dedan environment at work
5.1.	“Two semaphores” model
The example of deadlock detection is presented for the system in which two distributed computations, each one running on its own server, use two semaphores. Each semaphore resides on a separate server.

A1:				A2:
sem1.wait;			sem2.wait;
sem2.wait;			sem1.wait;
sem1.signal;		sem2.signal;
sem2.signal;		sem1.signal;
stop				stop

This system falls into a total deadlock when A1 holds sem1 and waits for sem2 and A2 holds sem2 and waits for sem1. But the situation changes if we add another agent process A3  on its own server r , which simply loops and performs its own calculations. In the deadlock, processes A1 and A2 cannot continue, but A3 still runs. We introduce calculations made by A3 symbolically as an endless execution of left and right services on the server r:
A3:
loop {
	r.left;
	r.right
}

The system is not in a total deadlock, it is a partial deadlock, which is difficult  to identify using model checking techniques (no system state is a “state with no future”). In the system, the termination of the agents A1 and A2 (which are designed to terminate after some calculations) is not inevitable (the deadlock is not the termination). Using IMDS, partial deadlock of A1 and A2 can be identified using the proposed general formulas that show the lack of termination of these agents. The agent A3 does not terminate as well – but this is expected because it works in an infinite loop in which there are no terminating actions.
The verification is carried out in the Dedan (Deadlock analyzer, [“Dedan,” n.d.]) environment which consists of a specification part and TempoRG model checker [Daszczuk, 2003]. The exemplary system consisting of two semaphores is presented graphically (informally) in Fig. 5.1a. The rules are the same as in the case of Fig. 3.4, except for the parameters showing the relationship between the specific instances of automata-like types. In Figs. 3.4 and 3.5 the servers are represented as automata. In Fig. 5.1a, the server types are shown, therefore the automata names are supplemented by the sets of formal parameters. The system is presented below in IMDS notation, which is the input notation of Dedan. The specification is in the server view. It is simply grouping of the actions in individual servers. The system is defined as a sequence of server type specifications (enclosed by server … }; – lines 2-9, 10-19, 20-26), server and agent instances (variables) declaration (agents …, servers … – lines 27,28) and the initial configuration phrase (init  {…} – lines 29-36). The server type heading contains a set of formal parameters: agents and servers used in the actions of the server type. Formal parameters can be vectors, as A[2] and proc[2] (l.2). Each server type contains the set of services (l.3,11,21), the set of states (l.4,12,22) and the set of assigned actions (in arbitrary order, l.6-8, 14-18, 24-25). The services and states can be vectors. To obtain a compact definition, repeaters can precede the actions in the server type definition (up to 3 for every action definition, l.6-8). The repeater is an integer variable with a defined range. The action definition is repeated for every value of a preceding repeater. If multiple repeaters are applied, the Cartesian product of their values is used. The indices of agents, states and services indicate individual instances of the vectors (l.6-8). 
 

Fig. 5.2 Common communication deadlock in sem[1] and sem[2] in server view
The server and agent variables can be organized in vectors (l.27,28). In the initialization part (l.29), the actual parameters are bound with formal parameters (again, repeaters and indices may be used – l.30-34). The initial server states and initial agent messages are also defined.
An important feature of the example is that actual parameters of proc servers are switched for proc2, therefore A[1] uses first semaphore, then second, and A[2] uses second semaphore, then first. This is graphically shown in Fig. 5.1b: the servers are represented by rounded boxes, and the arrows represent the parameter binding: labels of arrows show the order of the formal parameters and the arrowheads indicate the actual parameters bound with the formal parameters – switched for proc2.
 1. system	two_sem_server_view;

 2. server:	sem (agents A[2]; servers proc[2]),  
 3. services	{wait, signal}, 							
 4. states	{up, down},								
sem[1]	sem[2]	proc[1]	proc[2]	r

	




up	up	ini	ini	res
		A[1] -> start	A[2] -> start	A3 -> left
		first		
wait
	A[1]		
down				
A[1]
	ok_wait		
	
sec		
	wait
A[1]		
			first	
	wait
	A[2]	
	down			
	A[2]
	ok_wait	
			sec	
wait
		A[2]	
current states and pending messages
A[2] ! wait	A[1] ! wait			A3 ! left
DEADLOCK !	DEADLOCK !			
				
Fig. 5.3 Common communication deadlock in sem[1] and sem[2] in the server view. The circle surrounds two consecutive messages that are pending at the sem[2] server.
 5. actions	{
 6. <j=1..2>	{A[j].sem.wait, sem.up} -> {A[j].proc[j].ok_wait, sem.down},
 7. <j=1..2>	{A[j].sem.signal, sem.down} -> {A[j].proc[j].ok_sig, sem.up},
 8. <j=1..2>	{A[j].sem.signal, sem.up} -> {A[j].proc[j].ok_sig, sem.up},	
 9. };										

10. server:	proc (agents A; servers sem[2]),
11. services	{start, ok_wait, ok_sig},
12. states	{ini, first, sec, stop},
13. actions	{
14. 	{A.proc.start, proc.ini} -> {A.sem[1].wait, proc.first},
15.	{A.proc.ok_wait, proc.first} -> {A.sem[2].wait, proc.sec},
16.	{A.proc.ok_wait, proc.sec} -> {A.sem[1].signal, proc.first},
17.	{A.proc.ok_sig, proc.first} -> {A.sem[2].signal, proc.sec},
18.	{A.proc.ok_sig, proc.sec} -> {proc.stop},
19. };	

20. server:	r (agents A3),
21. services	{left, right},
22. states	{res},
23. actions	{
24.	{A3.r.left, r.res} -> {A3.r.right, r.res},
25.	{A3.r.right, r.res} -> {A3.r.left, r.res},
26. };

27. agents: 	A[2], A3;	
28. servers: sem[2], proc[2], r; 

29. init ->	{ 
30. <j=1..2>	A[j].proc[j].start, 
31.	A3.r.left,
32.	proc[1](A[1],sem[1],sem[2]).ini;
33.	proc[2](A[2],sem[2],sem[1]).ini;
34. <j=1..2>	sem[j](A[1],A[2],proc[1],proc[2]).up,
35.	r(A3).res,
36. }.

Note that the above system is defined in the server view, because the actions concerning a given server type are grouped inside its definition. The server states: up, down, first, sec are hidden inside the server types (not used outside the servers containing them), and the communication is performed via messages (wait, ok_wait, …). In Dedan, the system can be automatically converted to the agent view. In the agent view, the messages are hidden inside the agent types, and agents communicate via servers’ states. The states and services are the server attributes (lines 3,4, 6,7, 9,10) just like in the server view. The actions are grouped in the agent types (l.13-21, 25-33, 37-38). The agent type A is split during the conversion into two types A and A__1.  The reason is the switching of actual parameters (sem[1] and sem[2]) in the case of the second agent. 

 1. system	two_sem_agent_view;

 2. server:	sem,  
 3. services	{wait, signal}, 
 4. states	{up, down};

 5. server:	proc,
 6. services	{start, ok_wait, ok_sig},
 7. states	{ini, first, sec, stop};

 8. server:	r,
 9. services	{left, right},
10. states	{res};

sem[1]	sem[2]	proc[1]	proc[2]	r	A	A__1	A3









up	up	ini	ini	res			
		start	
	proc[1]		
			start
		proc[2]	
				left	
	r
		? A => first			proc[1]		
wait	
			sem[1]		
?A => down					sem[1]		
		Ok_wait	
	proc[1]		
		? A => sec			proc[1]		
	wait	
		sem[2]		
			?A__1=>first			proc[2]	
	wait	
			sem[2]	
	?A__1=>down					sem[2]	
			Ok_wait
		proc[2]	
			sec			proc[2]	
wait	
				sem[1	
Current states and pending messages
down	down	sec	sec	res			
A__1 -> wait	A -> wait			A3 -> left	sem[2]	sem[1]	r
					DEADLOCK!	DEADLOCK!	
							
							
Fig. 5.4 Resource deadlock of agents in the agent view

11. agent:	A (servers proc,sem[2]),  
12. actions	{
13.	{A.proc.start, proc.ini} -> {A.sem[1].wait, proc.first},
14.	{A.sem[1].wait, sem[1].up} -> {A.proc.ok_wait, sem[1].down},	
15.	{A.proc.ok_wait, proc.first} -> {A.sem[2].wait, proc.sec},
16.	{A.sem[2].wait, sem[2].up} -> {A.proc.ok_wait, sem[2].down},
17.	{A.proc.ok_wait, proc.sec} -> {A.sem[1].signal, proc.first},
18.	{A.sem[1].signal, sem[1].down} -> {A.proc.ok_sig, sem[1].up},
19.	{A.proc.ok_sig, proc.first} -> {A.sem[2].signal, proc.sec},
20.	{A.sem[2].signal, sem[2].down} -> {A.proc.ok_sig, sem[2].up},	
21.	{A.proc.ok_sig, proc.sec} -> {proc.stop},
22. };

23. agent:	A__1 (servers proc,sem[2]),  
24. actions	{
25.	{A__1.proc.start, proc.ini} -> {A__1.sem[1].wait, proc.first},
26.	{A__1.sem[1].wait, sem[1].up} -> {A__1.proc.ok_wait, sem[1].down},	
27.	{A__1.proc.ok_wait, proc.first} -> {A__1.sem[2].wait, proc.sec},
28.	{A__1.sem[2].wait, sem[2].up} -> {A__1.proc.ok_wait, sem[2].down},
29.	{A__1.proc.ok_wait, proc.sec} -> {A__1.sem[1].signal, proc.first},
30.	{A__1.sem[1].signal, sem[1].down} -> {A__1.proc.ok_sig, sem[1].up},
31.	{A__1.proc.ok_sig, proc.first} -> {A__1.sem[2].signal, proc.sec},
32.	{A__1.sem[2].signal, sem[2].down} -> {A__1.proc.ok_sig, sem[2].up},	
33.	{A__1.proc.ok_sig, proc.sec} -> {proc.stop},
34. };

35. agent:	A3 (servers r),
36. actions	{
37.	{A3.r.left, r.res} -> {A3.r.right, r.res},
38.	{A3.r.right, r.res} -> {A3.r.left, r.res},
39. };

40. agents: 	A, A__1, A3;
41. servers: sem[2], proc[2], r;

42. init ->	{ 
43. <j=1..2>	proc[j].ini,
44. <j=1..2>	sem[j].up,
45.	r.res,
46. 	A(proc[1],sem[1..2]).proc[1].start,
47. 	A__1(proc[2],sem[2],sem[1]).proc[2].start,
48. 	A3(r).r.left,
49. }.

The Dedan program elaborates the global reachability space and launches TempoRG model checker to verify CTL formulas. Alternatively, the specification in input form of Spin, NuSMV or Uppaal is prepared for verification under the external model checker. The results of the verification are – communication deadlocks:
•	server sem[1] – true (deadlock in sem[1]),
•	server sem[2] – true (deadlock in sem[2]),
•	server proc[1] – false (no deadlock in proc[1]),
•	server proc[2] – false (no deadlock in proc[2]),
•	server r – false (no deadlock in r),
resource deadlocks:
•	agent A  (A[1] in the server view) – true (deadlock in A),
•	agent A__1  (A[2] in the server view) – true (deadlock in A__1),
•	agent A3 – false (no deadlock in A3),
agent termination:
•	agent A  (A[1] in the server view) – false (A may not terminate),
•	agent A__1  (A[2] in the server view) – false (A__1 may not terminate),
•	agent A3 – false (A3 does not terminate, which is expected as it contains an endless loop).
sem[1]	sem[2]	proc[1]	proc[2]	r	A	A__1	A3









up	up	ini	ini	res			
		start	
	proc[1]		
			start
		proc[2]	
				left
		r
		? A => first			proc[1]		
wait	
			sem[1]		
?A => down					sem[1]		
		Ok_wait	
	proc[1]		
		? A => sec			proc[1]		
	wait	
		sem[2]		
			?A__1=>first			proc[2]	
	wait	
			sem[2]	
	?A__1=>down					sem[2]	
			Ok_wait
		proc[2]	
			sec			proc[2]	
wait	
				sem[1]	
CYCLE
			
A3=>res		
r
				right	
	r
				A3=>res			r
				left	
	r
Current states and pending messages
down	down	sec	sec	res			
A__1-> wait	A -> wait			A3->left	sem[2]	sem[1]	r
					NO TERM !	NO TERM !	NO TERM !
							
							
Fig. 5.5 Lack of termination of all three agents in the agent view
To sum up, in our case the agent processes A and A__1 (A[1] and A[2] in the server view) fall into a resource deadlock while the agent A3 does not. The server processes sem[1] and sem[2] fall into a communication deadlock while the server r does not. No agent achieves an inevitable termination. 
The Dedan program generates the counterexamples (in the case of deadlock or lack of termination) or witnesses (in the case of successive termination) and displays them in readable format. The deadlock or termination can be checked for individual processes or for a given set of processes at the same time (common deadlock/termination). The example of the common communication deadlock of sem[1] and sem[2] in the server view is shown in Fig. 5.2. This is the output file from the Dedan program. The sequence diagram is redrawn in Fig. 5.3 for readability. Note the situation in which two subsequent messages invoke the wait service on the sem[2] server (surrounded by the circle). Both messages match the current state of sem[2]: up. The choice of an action to fire is nondeterministic. If the message originated from A[1] is selected – no deadlock occurs. However, model checking finds a counterexample that leads to the violation of the deadlock-safety rule, therefore the sequence is displayed in which the message of A[2] is selected.
Resource deadlock of the agent processes in the agent view is shown in Fig. 5.4. The lack of termination of all three agent processes is shown in Fig. 5.5. Recall that agent type A in the server view is split to two agent types A and A__1 when converted to the agent view. Agent variables have the same names as their types: A and A__1.
The counterexample or the witness is presented as a sequence diagram-like chart. The heading shows the names of servers on pink background (and agents on green background in the agent view). The upper part shows the initial states of all servers on pink background, and the sequences of states and messages leading to incorrect or desirable situation in a given process: deadlock, termination or lack of termination. A state is displayed simply as its identifier with a light blue background. The agent that causes the server process to enter the given state is shown on a dark blue background. A message is displayed with the agent identifier on light yellow background on send, and with service name on yellow background on receive. The middle part of the picture is a sequence that repeats in a loop infinitely (if there is one - in the example it is visiting the left and right states in the A3 agent process). The last part shows the deadlock, termination or lack of termination configuration: all servers’ states and all pending messages are displayed.
5.2.	Dijkstra’s philosophers
The problem of “5 philosophers” is a good example of the occurrence of deadlock [Dijkstra, 1971]. The example is shown in the distributed version, i.e., each philosopher is an agent sitting on his own chair, which is a separate server. Forks are the resources represented by separate servers. The structure of the agents and servers is shown in Fig. 5.6. The servers are depicted as rounded boxes and the agents are ovals. Message flow between servers is shown as arrows. The agents are connected to the servers on which they are started. The IMDS code for 5 philosophers (the server view) is:
 1. system		phil;

 2. server:	fork(agents ph[2]; servers chair[2]),
 3. services	{take_first, take_second, release_first, release_second},
 4. states		{taken, free},
 5. actions	{
 6. <j=1..2>	{ph[j].fork.take_first, fork.free} -> 
{ph[j].chair[j].may_take_second, fork.taken},
 7. <j=1..2>	{ph[j].fork.take_second, fork.free} -> 
{ph[j].chair[j].may_eat, fork.taken},
 8. <j=1..2>	{ph[j].fork.release_first, fork.taken} ->
{ph[j].chair[j].may_release_second, fork.free},
 9. <j=1..2>	{ph[j].fork.release_second, fork.taken} -> 
{ph[j].chair[j].may_think, fork.free},
10. };

11. server:	chair(agents ph; servers fork[2]),
12. services	{may_eat, may_think, may_take_second, may_release_second},
13. states	{think, waits_eat, eat, first_left, first_right},
14. actions	{
15.	{ph.chair.may_think, chair.think} -> 
{ph.chair.may_think, chair.think},
16.	{ph.chair.may_think, chair.think} -> 
{ph.fork[1].take_first, chair.first_left},
17.	{ph.chair.may_think, chair.think} -> 
{ph.fork[2].take_first, chair.first_right},
18.	{ph.chair.may_take_second, chair.first_left} -> 
{ph.fork[2].take_second, chair.waits_eat},
19.	{ph.chair.may_take_second, chair.first_right} -> 
{ph.fork[1].take_second, chair.waits_eat},
20.	{ph.chair.may_eat, chair.waits_eat} -> 
{ph.chair.may_eat, chair.eat},
21.	{ph.chair.may_eat, chair.eat} -> 
{ph.chair.may_eat, chair.eat},
22.	{ph.chair.may_eat, chair.eat} -> 
{ph.fork[1].release_first, chair.first_left},
23.	{ph.chair.may_eat, chair.eat} -> 
{ph.fork[2].release_first, chair.first_right},
24.	{ph.chair.may_release_second, chair.first_left} -> 
{ph.fork[2].release_second, chair.think},
25.	{ph.chair.may_release_second, chair.first_right} -> 
{ph.fork[1].release_second, chair.think},
26. };
 
27. servers: fork[5],chair[5];
28. agents: ph[5];

29. init -> {		fork[1](ph[5,1],chair[5,1]).free,
30. 		fork[2](ph[1,2],chair[1,2]).free,
31.		fork[3](ph[2,3],chair[2,3]).free,
32.		fork[4](ph[3,4],chair[3,4]).free,
33.		fork[5](ph[4,5],chair[4,5]).free,
34.		chair[1](ph[1],fork[1,2]).think,
35.		chair[2](ph[2],fork[2,3]).think,
36.		chair[3](ph[3],fork[3,4]).think,
37.		chair[4](ph[4],fork[4,5]).think,
38.		chair[5](ph[5],fork[5,1]).think,
39. <i=1..5>		ph[i].chair[i].may_think,
40. }.


Each philosopher ph[i] (line 28) sitting on a chair (type declared in l.11) thinks then eats (states declared in l.13). He needs two forks (parameters in l.11) to eat. Each fork (type in l.2) is a shared resource of two neighboring philosophers. More specifically, the philosopher ph[i] thinks for undefined time (l.15), then he decides nondeterministically to take forks, first_left (l.16) or first_right (l.17). After granting him the first fork (service may_take_second, l.12,18,19), the philosopher asks for the second one and waits for it in waits_eat state (l.13,18,19). Granting the second fork may_eat (l.20) causes the philosopher to eat (l.21), and then to release both forks, again in arbitrary order (l.22-25). 
The automata-like model is presented in Fig. 5.7. The forks are taken in arbitrary order (first_left or first_right, nondeterministically, l.16,17), which causes a deadlock when all philosophers take their left forks first or when they take their right forks first. Double arrows show multiple actions between the states. 
The analysis of the system under Dedan shows a deadlock as expected. 
The first solution to the deadlock problem is asymmetrical: there is a philosopher who always takes the left fork first, there is also a philosopher who always takes the right fork first. The remaining philosophers take their forks in arbitrary order. This solution requires two special servers: chair_first_left and chair_first_right, the other philosophers work as before. The code of the first of the special philosophers is below.
 1. server:	chair_first_left(agents ph; servers fork[2]),
 2. services	{may_eat, may_think, may_take_second, may_release_second},
 3. states		{think, eat, first_left, first_right},
 4. actions	{
 5.	{ph.chair_first_left.may_think, chair_first_left.think} -> {ph.chair_first_left.may_think, chair_first_left.think},
 6.	{ph.chair_first_left.may_think, chair_first_left.think} -> 
{ph.fork[1].take_first, chair_first_left.first_left},
 7.	{ph.chair_first_left.may_take_second, chair_first_left.first_left} -> 
{ph.fork[2].take_second, chair_first_left.eat},
 8.	{ph.chair_first_left.may_eat, chair_first_left.eat} -> 
{ph.chair_first_left.may_eat, chair_first_left.eat},
 9.	{ph.chair_first_left.may_eat, chair_first_left.eat} -> 
{ph.fork[1].release_first, chair_first_left.first_left},
10.	{ph.chair_first_left.may_eat, chair_first_left.eat} -> 
{ph.fork[2].release_first, chair_first_left.first_right},
11.	{ph.chair_first_left.may_release_second, chair_first_left.first_left} -> 
{ph.fork[2].release_second, chair_first_left.think},
12.	{ph.chair_first_left.may_release_second, chair_first_left.first_right} -> 
{ph.fork[1].release_second, chair_first_left.think},
13. };

Separate fork types pose a problem: forks should be specific to a particular pair of chairs due to types of formal parameter. This is solved by the introducing a special type self, which informs that the actual parameter can be of any type, provided that the sets of services in all actual parameters used for the formal parameter are identical. The definition of fork server is:
server:	fork(agents ph[2]; servers chair[2]:self),

The declaration of server variables and the initialization is as follows:
servers: fork[5],chair[3],chair_first_right,chair_first_left;
agents: ph[5];

 1. init	-> { 	
 2.		chair[1](ph[1],fork[1,2]).think,
 3.		chair[2](ph[2],fork[2,3]).think,
 4.		chair[3](ph[3],fork[3,4]).think,
 5.		chair_first_left(ph[4],fork[4,5]).think,
 6.		chair_first_right(ph[5],fork[5,1]).think,
 7.		fork[1](ph[5,1],chair_first_right,chair[1]).free,
 8.		fork[2](ph[1,2],chair[1],chair[2]).free,
 9.		fork[3](ph[2,3],chair[2],chair[3]).free,
10.		fork[3](ph[3,4],chair[3],chair_first_left).free,
11.		fork[4](ph[4,5],chair_first_left,chair_first_right).free,
12.		ph[1].chair[1].may_think,
13.		ph[2].chair[2].may_think,
14.		ph[3].chair[3].may_think,
15.		ph[4].chair_first_left.may_think,
16.		ph[5].chair_first_right.may_think,
17. }.

Dedan reports deadlock freeness as expected. The second solution to the problem is the generalization of the first one: two butlers guard the forks, preventing to take five same-named forks as first (left ones or right ones). The butler is constructed just as a bounded buffer: when the maximum of requesting processes is reached, no granting action is prepared (the repeater i maximum value in line 7 is 4). The code of a butler type is:
 1. server: 	butler(agents ph[5]; servers chair[5]),
 2. services	{take, release},
 3. states		{v0,v[4]}
 4. actions	{
 5. 		<j=1..5>	{ph[j].butler.take, butler.v0} -> 
{ph[j].chair[j].may_take_first, butler.v[1]},
 6. <i=1..3>	<j=1..5>	{ph[j].butler.take, butler.v[i]} -> 
{ph[j].chair[j].may_take_first, butler.v[i+1]},
 7. <i=2..4>	<j=1..5>	{ph[j].butler.release, butler.v[i]} -> 
{ph[j].chair[j].aft_release, butler.v[i-1]},
 8. 		<j=1..5>	{ph[j].butler.release, butler.v[1]} -> 
{ph[j].chair[j].aft_release, butler.v0},
 9. };

The butler contains the counter of the philosophers requesting the left forks or the right forks. The states of the butler are modeled as the state vector v, with 0th element separated as v0 due to indexing from 1 in Dedan.
All the mentioned models of “five philosophers” (erroneous system, the two presented solutions and a third solution with taking “two or none” forks) are contained in the File EXAMPLES.zip, available at [“Dedan Examples,” n.d.]. All the examples are prepared in the source code of the server view, and converted by the Dedan program to the agent view. The source codes are included in files which names end with ‘S’. The agent views of the examples are contained in files which names end with ‘T’. 
•	phil3S.txt - 3 philosophers. The Dijkstra's problem of dining philosophers, limited to 3 philosophers. The deadlock occurs.
•	phil3S-asym.txt - 3 philosophers, asymmetric solution. The solution based on the order of obtaining the forks: one philosopher takes the left fork first and one takes the right fork first.
•	phil3S-2orNo.txt - 3 philosophers, “all-or-nothing” solution. The solution based on taking two forks if both are available, on no fork if at least one fork is taken.
•	phil3S-butlers.txt - 3 philosophers, “butlers” solution. The two butlers are responsible for a prohibition of taking all three left forks as first and of taking all three right forks as first.
The models for 5 philosophers are verified entirely under Dedan (except for “butlers”, which is verified for 4 philosophers). The models for a higher number of philosophers are verified using external model checker (Uppaal). 
5.3.	Intersection
The verification techniques can be used in modeling transport systems. The intersection is a typical example. The quarters of the intersection can be treated as resources, and a vehicle takes them one after another. The quarters Q and approaching fields A are coded with the cardinal directions. A vehicle leaving the intersection returns to the set of vehicles awaiting the appropriate approach field, for example a vehicle leaving QNW to the west enters the queue at AW. The topography is shown in Fig. 5.8. 
Note that if a vehicle leaves the quarter, and waits for the next quarter freeing, other vehicles can do the same. This would lead to arising of a queue of vehicles between two neighboring quarters (which freed a quarter and request for the next one). The queue is simply the set of messages pending at the target quarter. Therefore, the vehicle must obtain the next quarter before freeing the current one, which prevents the queue from being created. The request message is issued to the next quarter, and if confirmation arrives, the vehicle moves. This requires three messages (request, grant, move), which form a kind of protocol of obtaining a quarter, for the example of QSEQNE:
•	QSE is occupied by the vehicle, and it wants to take QNE, The message try is sent from QSE to QNE. It is a request. This message may wait for acceptance for undefined period of time if QNE is occupied.
•	If finally the message try is accepted in QNE (QNE is currently free), the message ok is sent back from QNE to QSE. It is a grant. QNE changes its state from free to reserved – it cannot be taken by other vehicles.
•	Then, QSE is released and QNE is finally taken by the vehicle, QSE becomes free and QNE becomes occupied. It is a move.
We assumed a priority for the vehicles being on the intersection, i.e., QSEQNE has priority over AE->QNE. The priority is realized by doubling the states free, rese and occ with their complementary states freew, resew and occw (w stands for waiting – line 5). The additional states denote a situation similar to the basic one, except that a vehicle with a priority wants to take the quarter and the vehicle without priority must wait. If a quarter is free – it is simply taken by a requesting vehicle. After the granting procedure begun, and the vehicle with priority requests the quarter – its state is changed to a complementary one (l.9), and after freeing the quarter it is granted immediately to a requesting vehicle (l.8). The protocol may seem to be complicated for the vehicle driver, but we can treat the system as the automatic vehicle guidance environment (see the next section), in which vehicles are conducted by field controllers cooperating with each other using the mentioned protocol.
The source code of the model is as follows:
 1. #DEFINE N 4
 2. #DEFINE K 4

 3. server:		quarter(agents car[N];
servers prevq:quarter,nextq:quarter,in:road,out:road),  
 4. services	{trye[K],oke[K],takee[K],tryi[K],takei[K],occupy[K]},
 5. states		{free,freew,rese,resew,resi,occ,occw},								
 6. actions{
 7. <i=1..N>	<j=1..K>	{car[i].quarter.tryi[j], quarter.free} -> 
{car[i].in.oki[j], quarter.resi},
 8. <i=1..N>	<j=1..K>	{car[i].quarter.tryi[j], quarter.freew} -> 
{car[i].in.oki[j], quarter.resi},
 9. <i=1..N>	<j=1..K>	{car[i].quarter.tryi[j], quarter.rese} -> 
{car[i].quarter.tryi[j], quarter.resew},
10. <i=1..N>	<j=1..K>	{car[i].quarter.takei[j], quarter.resi} -> 
{car[i].quarter.occupy[j], quarter.occ},

11. <i=1..N>	<j=1..K-1>	{car[i].quarter.trye[j], quarter.free} -> 
{car[i].prevq.oke[j+1], quarter.rese},
12. <i=1..N>	<j=1..K-1>	{car[i].quarter.takee[j], quarter.rese} -> 
{car[i].quarter.occupy[j], quarter.occ},
13. <i=1..N>	<j=1..K-1>	{car[i].quarter.takee[j], quarter.resew} -> 
{car[i].quarter.occupy[j], quarter.occw},

14. <i=1..N>		{car[i].quarter.occupy[1], quarter.occ} -> 
{car[i].out.leave, quarter.free},
15. <i=1..N>		{car[i].quarter.occupy[1], quarter.occw} -> 
{car[i].out.leave, quarter.freew},
16. <i=1..N>	<j=2..K>	{car[i].quarter.occupy[j], quarter.occ} -> 
{car[i].nextq.trye[j-1], quarter.occ},
17. <i=1..N>	<j=2..K>	{car[i].quarter.occupy[j], quarter.occw} -> 
{car[i].nextq.trye[j-1], quarter.occw},

18. <i=1..N>	<j=2..K>	{car[i].quarter.oke[j], quarter.occ} -> 
{car[i].nextq.takee[j-1], quarter.free},
19. <i=1..N>	<j=2..K>	{car[i].quarter.oke[j], quarter.occw} -> 
{car[i].nextq.takee[j-1], quarter.freew},
20. };

21. server:		road(agents car[N]; servers qin:quarter),
22. services	{leave,oki[K]},
23. states		{idle,tries},
24. actions{
25. //j=1 right, j=2 straight, j=3 left, j=4 turn back
26. <i=1..N>	<j=1..K>	{car[i].road.leave, road.idle} -> 
{car[i].qin.tryi[j], road.tries},
27. <i=1..N>	<j=1..K>	{car[i].road.oki[j], road.tries} -> 
{car[i].qin.takei[j], road.idle},
28. };

29. servers 	quarter[K],road[K];
30. agents	car[N];	

31. init ->	{ 
32.		quarter[1](car[1..N],quarter[4,2],road[1,2]).free,
	        quarter[2](car[1..N],quarter[1,3],road[2,3]).free,
33.		quarter[3](car[1..N],quarter[2,4],road[3,4]).free,
34.		quarter[4](car[1..N],quarter[3,1],road[4,1]).free,

35. <j=1..4>	road[j](car[1..N],quarter[j]).idle,

36. <i=1..N>	car[i].road[1].leave, 	
37. }.

Verification shows a deadlock when all quarters are occupied and all vehicles request the next quarters. A deadlock does not occur if there are only three vehicles, or if all vehicles turn right.
This verification is rather simple and its results are obvious, but it shows the direction of research that can be carried out on transport systems, for example:
•	guiding of vehicles in Personal Rapid Transport (PRT) station, equipped with stub-berths and a shunt, with a possibility of reversing or not [Daszczuk and Mieścicki, 2014], 
•	railway interlocking system [Vu et al., 2015],
•	railway control system [Nardone et al., 2016],
•	etc.
5.4.	Automatic vehicle guidance system
The analysis of vehicles (autonomous moving platforms – AMPs) behavior in the automatic guidance environment is analyzed in [Czejdo et al., 2016]. The system topology is presented in Fig. 5.9. The solid lines are the track segments (the whole topography is letter E-shaped), and the boxes represent the distributed track segment controllers.
In the described system, we identify servers with static elements: the road segment controllers of the AMPs environment (warehouse lots and road markers). The controllers cooperate by means of simple protocols. The agents are identified with dynamic elements: AMPs traveling through the environment. For example, if the agent AMP1 is in the place Road Marker E1, then it tries to take the Road Marker M. To do this safely, a protocol similar to that used in the intersection example is applied. 
markerE[1]	markerE[2]	markerM	lotE[1]	lotE[2]	lotM	AMP	AMP
__1









free	free	free	occ	occ	free		
			start 
		lotE[1]	
				start
		lotE[2]
			?AMP=> occ			lotE[1]	
tryL	
				markerE[1]	
? AMP => resL						markerE[1]	
			ok
		lotE[1]	
			?AM => free			lotE[1]	
takeL	
				markerE[1]	
? AMP => occ						markerE[1]	
		tryE[1]	
		markerM	
		?AMP=>resE[1]				markerM	
okM[1]	
				MarkerE[1]	
				?AMP__1 =>occ			lotE[1]
	tryL
					markerE[2]
? AMP => free						markerE[1]	
		take[1]	
		markerM	
		? AMP => occ				markerM	
		switch[2]	
		markerM	
		? AMP => occ				markerM	
	tryM[2]
				markerE[2]	
	? AMP => resM					markerE[2]	
		okE[2]	
		markerM	
		? AMP =>free				markerM	
	takeM
				markerE[2]	
	? AMP => occ					markerE[2]	
				try	
lotE[2]	
Current states and pending messages
free	occ	free	free	occ	free		
				AMP->try		lotE[2]	
	AMP__1 -> tryL						markerE[2]
						DEADLOCK !	DEADLOCK !
							
Fig. 5.10 Sequence diagram of AMP (AMP1) moving from  Warehouse Lot E1 to  Warehouse Lot E2 and AMP__1 (AMP2) moving reverse way, leading to the deadlock
The views of the modeled system emphasize different aspects of the behavior, but it is worth stressing that they are merely two aspects of the uniform system. The views are simply different grouping of actions. The system in the server view allows the observation of the system from the perspective of road segments’ controllers. The agent view gives the vehicles’ perspective. 
The operation of two vehicles is checked: one vehicle traveling from Lot E1 to Lot E2 and the other one from Lot E2 to Lot E1. Proper behavior allows for bypassing using Lot M1. Indeed, the overtaking is performed correctly, but deadlocks can occur in road segments R2 and R4, when 
one of the vehicles occupies the segment and the other one does not start driving yet.
Fig. 5.10 shows the resource deadlock in the agent view. 
5.5.	Resource deadlock without communication deadlock
Typically a communication deadlock in the server view manifests as a resource deadlock in the agent view. However, in some cases of systems with too little resources, the server view can be free from communication deadlock, while some agents fall into the resource deadlock in the agent view (those for which there is a lack of resources). It is illustrated in Res_DeadlockS.txt in the examples available at [“Dedan Examples,” n.d.].  The system contains not enough resources. A resource deadlock occurs, because one of requesting agents waits forever for a resource, but there is no communication deadlock: all servers work, including the server containing the critical resource. This is due to the different formulations of communication deadlock and resource deadlock: communication deadlock affects all agents which messages are pending at the server, while resource deadlock may affect a single agent. The with lacking resources is stuck, while the other agents work, having allocated resources. Agents with insufficient resources fall into a deadlock individually, but checking for a total deadlock of all agents does not show any malfunction.
Such a situation may occur in the case of roundabout modeling: if all segments (quarters) of the roundabout are occupied, and the vehicles constantly omit one of the roads (from the direction E), vehicle approaching from this road become deadlocked. This is not a communication deadlock of the servers (segments of the roundabout), because the vehicles on these segments are moving. But in the agent view, we see the agents remaining on the bypassed road in a resource deadlock (Fig. 5.11). This is a deadlock in the sense of our definition: the agent’s message is waiting for acceptance, but it will never be served. Such a situation, in which a single process can be blocked, is sometimes called a starvation [Tai, 1994] or stall [Masticola and Ryder, 1990].
5.6.	Production cell
The Production Cell is a real-world system developed in Karlsruhe. It was a benchmark for several research projects regarding the specification, design, synthesis, testing and verification of the controller for the Production Cell. The research is summarized in [Lewerentz and Lindner, 1995]. After the publication of the original book, many additional research papers about the benchmark were published. In several works Production Cell was used as an example among other benchmarks. Similar real-world systems were used in a number of papers.
The original benchmark (Fig. 5.12) is a set of devices for delivering metal plates (blanks) with a feed belt, placing them into the press by a two-armed rotary robot, withdrawing forged plates back and transferring them to the deposit belt. Equipping the robot with two arms allows simultaneous transport of two plates: the blank one to the press and the previously forged from the press. The difference in the levels of the feeder belt and the press is bridged by the elevating rotary table between them. 
The Production Cell is the physical model, in which the press only pretends to forge the plates, so they remain blank and can be turned back in a loop. It is just the purpose of using the traveling crane which moves the plates between the belts. 
5.6.1.	Centralized vs. distributed modeling
Some approaches assume a centralized controller: Tatzelwurm [Klingenbeck and Käufl, 1995] and TLT [Cuellar and Huber, 1995]. Most studies, however, concern distributed control of the Production Cell. The distribution is modeled as common variables between the subcontrollers [Heiner and Heisel, 1999] or synchronous message passing [Greenyer et al., 2013][Garavel and Serwe, 2017][Jacobs and Simpson, 2015]. 
5.6.2.	Synchrony vs. asynchrony of specification
Most models are based on synchronous paradigm, i.e., the devices agree their states on their joint activities [Greenyer et al., 2013] [Garavel and Serwe, 2017] [Jacobs and Simpson, 2015] [Ma and Wonham, 2005] [Zorzo et al., 1999] [Sokolsky et al., 1999] [Ramakrishnan and McGregor, 2000]. Many of them are based on well-known formalisms: LOTOS [Rosa and Cunha, 2004], CSP [Hoare, 1978] or CCS [Milner, 1980]. Some papers deal with real time modeling [Cassez et al., 2005] [Dierks, 1996] [Beyer et al., 2003] [Burns, 2003] [Benghazi Akhlaki et al., 2007]. Synchrony requires some kind of nonlocality, for example sensors common to the controllers of both neighboring devices. 
Only a few papers deal with asynchronous modeling: SDL [Heinkel and Lindner, 1995], provides asynchronous, simple protocols between devices. Focus [Fuchs and Philipps, 1995], [Barbey et al., 1998b] covers the asynchronous network of components (agents) that work concurrently and communicate over unbounded FIFO channels, translated into either a functional or an imperative programming language. It is admitted that to each arrow corresponds an asynchronous event, i.e., the event is sent even though the receiving agent is not ready to accept it. The Promela model in [Cattel, 1995] uses asynchronous channels. The Model Checking Kit [Schröter et al., 2003] allows the preparation of models in various languages, including IF (Interchange Format): a language proposed for modeling asynchronous real-time communicating systems. Architecture Analysis and Design Language [Björnander et al., 2011] provides asynchronous specification, as the pairs of events feedBelt.InFeedBeltReady -> loader.InFeedBeltReady. 
Nonblocking Supervisory Control of State Tree Structures [Ma and Wonham, 2005] provide Hierarchical Statecharts description. A synchronous system is modeled directly in BDD with a controlled order of BDD variables. Features are written as formulas over states, similar to invariants. A combination of AND-states (Cartesian products of component states) and OR-states (exclusive-or between component states) model asynchrony of structures, similar to messages pending at servers. We may say that AND states hierarchically model the structure and parallelism, while OR states model the behavior (the dynamics). 
In some papers asynchronous communication is modeled by data structures: Multiparty Session Processes with Exceptions [Capecchi et al., 2016] use messages queues. In [Heiner and Heisel, 1999] asynchrony is introduced as a place “in between” in a Petri net (1-element buffer).
5.6.3.	Real-time modeling
Most papers on modeling the Production Cell deal with timeless control sequences. However, some of them deal with real-time constraints. In HTTDs (Hierarchical Timed Transition Diagrams [Cardell-Oliver, 1995]), sequences of timed transitions are used. In [Ruf and Kropf, 1999], Networks of Communicating Real-Time Processes are described: various levels of abstraction, I/O-interval structures and input-sensitive transitions. In [Benghazi Akhlaki et al., 2007], systematic transformation from UML RT [Grosu et al., 1999] to CSP+T (time) [Žic, 1994] is applied. Timed Game Automata [Ehlers et al., 2010] and Timed Games [Cassez et al., 2005] are used for on-the-fly verification. The timed specification language SLtime is described in [Dierks, 1996], while graphical specification with time is possible in [Ben-Abdallah and Lee, 1998]. Timed Automata are used in [Burns, 2003] and Cottbus Timed Automata in [Beyer and Rust, 1998].
5.6.4.	Message passing/resource sharing
Synchronous modeling usually is based on variables, as in Lustre [Holenderski, 1995], or synchronous channels [Greenyer et al., 2013] [Garavel and Serwe, 2017] [Jacobs and Simpson, 2015]. Communication based on resource sharing in a distributed environment is presented in Graphical Communicating Shared Resources [Ben-Abdallah and Lee, 1998].
5.6.5.	Synthesis and Verification
Some papers concern the synthesis of Production Cell controller (or a set of distributed controllers of individual devices). Such are Esterel [Budde, 1995], SDL [Heinkel and Lindner, 1995], Deductive Synthesis using first order predicate logic [Burghardt, 1995], Fusion method [Barbey et al., 1998b] using regular expressions. Modal Sequence Diagrams and Feature Diagrams [Greenyer et al., 2013] are used for incremental synthesis exploiting the similarities between individual device specifications.
Testing and simulation as validation methods are addressed in several papers: Symbolic Timing Diagrams [Korf and Schlör, 1995] are used for testing in waveform monitoring. Formal testing method is applied in [Barbey et al., 1998a] and [Larsen et al., 2009]. Statistical testing of Reusable Concurrent Objects is described in [Waeselynck and Thévenod-Fosse, 1999]. A simulation is used as informal validation in SDL [Heinkel and Lindner, 1995] and Graphical Communicating Shared Resources [Ben-Abdallah and Lee, 1998].
In general, safety conditions  as avoiding machine collisions and liveness properties are checked: if two blanks are inserted into the system, one of them will eventually arrive at the traveling crane. 
5.6.6.	Modeling Production Cell in IMDS
The IMS specification of Production Cell benchmark consists of the definition of servers (devices) and agents (blanks traveling through the cell). Every pair of servers negotiate using simple protocol, which is a sequence of three messages: the supplier send a message try that tests the receiver’s readiness to accept the blank. When the receiver responds with a message ok, the supplier can deliver the blank. The supplier then issues a message deliver, which has two meanings: completion of the protocol and passing a blank from the supplier to the receiver. For example, the protocol between the rotary table (T) and the robot (R), viewed from the robot’s  perspective, has the following IMDS code:
<i=1..N>{A[i].R.tryIn, R.arm1_at_T} -> {A[i].T.ok, R.arm1_at_T},
<i=1..N>{A[i].R.deliverIn, R.arm1_at_T} -> {A[i].R. rotate_ccw_P, R. R.rot_ccw_a2_P},

The meaning of this specification is as follows: for each agent (<i=1..N>), if the message tryIn is received by the robot and its state denotes staying at receiving position (arm1_at_T), the message ok is issued and the robot remains in arm1_at_T state, waiting for the message deliverIn.  When it arrives, the robot starts to rotate counterclockwise, issuing the message rotate_ccw_P to itself and entering the state rot_ccw_a2_P, which means that the robot rotates until its arm2 points to the press (P). All the above operations are performed in the context of the agent A[i], modeling the ith blank.
It is assumed that the belts do not stop, that's why they deliver blanks to receiving devices without using any protocol, they simply issue the message deliver.
Agents A[1]..A[N] model N blanks traveling through the cell. Sometimes, however, operations such as returning the table to at_FB position after delivering a blank to the robot are desirable. It is modeled by the additional agents internal to some devices, for example the agent LT in the table (T):
{LT.T.return, T.at_R_free} -> {LT.T.go_to_FB, T.mov_to_FB},
{LT.T.go_to_FB, T.mov_to_FB} -> {LT.FBC.ready, T.waits},
{LT.T.ok_ready, T.waits} -> {LT.T.return, T.at_FB},

The robot is equipped with two arms which extend for picking/leaving the blanks, and which retract before the robot rotation. For example, if the robot reaches the utmost position at the table and it receives the tryIn message, it extends to the appropriate length and then issues the message ok. After picking a blank, the arm retracts and the robot starts to rotate. This changes the previous specification (the “black box” symbol in the code ■ is described in the next sections):
<i=1..N>{A[i].R.tryIn, R.arm1_at_T} -> {A[i].R.wait_a1extIn, R.arm1_at_T_ext},
{AARM[1].R.extend, R.arm1_at_T_ext} -> {AARM[1].ARM[1].extend, R.arm1_at_T_ext},
{AARM[1].R.ok_ext, R.arm1_at_T_ext} -> {AARM[1].R.retract, R.arm1_at_T_long},
<i=1..N>{A[i].R.wait_a1extIn, R.arm1_at_T_long} -> {A[i].T.ok, R.arm1_at_T_long},
■<i=1..N>{A[i].R.deliverIn, R.arm1_at_T_long} -> 
{A[i].R.wait_a1retIn, R.arm1_at_T_ret},
{AARM[1].R.retract, R.arm1_at_T_ret} -> {AARM[1].ARM[1].retract,R.arm1_at_T_ret},
{AARM[1].R.ok_ret, R.arm1_at_T_ret} -> {AARM[1].R.extend, R.arm1_at_T_short},
<i=1..N>{A[i].R.wait_a1retIn, R.arm1_at_T_short} -> 
{A[i].R.rotate_ccw_P, R.rot_ccw_a2_P},
…

The complete model of the traveling crane (C) is as follows:
server: C(agents A[N],LC; servers DBH,FBH),
states {at_FB_occ,at_FB_free,mov_to_DB,at_DB,mov_to_FB,waits},
services {deliver,go_to_FB,go_to_DB,ok,return,ok_ready},
actions{
<i=1..N>{A[i].C.deliver, C.at_DB} -> {A[i].C.go_to_FB, C.mov_to_FB},

<i=1..N>{A[i].C.go_to_FB, C.mov_to_FB} -> {A[i].FBH.try_C, C.at_FB_occ},
<i=1..N>{A[i].C.ok, C.at_FB_occ} -> {A[i].FBH.deliver_C, C.at_FB_free},
{LC.C.return, C.at_FB_free} -> {LC.C.go_to_DB, C.mov_to_DB},
{LC.C.go_to_DB, C.mov_to_DB} -> {LC.DBH.ready, C.waits},
{LC.C.ok_ready, C.waits} -> {LC.C.return, T.at_DB},
}
5.6.7.	Verification in Dedan
 The critical situation occurs when the robot exchanges a fresh blank with a forged one in the press. Because it is forced to exchange the forged blank with the incoming, it is obvious that the last forged blank stays inside the press and cannot be taken out. If the circulation of blanks is applied in a closed loop, it requires at least two blanks for proper operation the system. Indeed, the verification shows a deadlock in the press, if only one blank is applied (Fig. 5.13, a large part of the sequence is omitted between the two black lines). The figure shows the server view, including the history of all servers. The last actions leading to a deadlock are enlarged in the lower right corner. These are messages exchanged between the robot (R) and the press (P).
The described situation is shown as a separate sequence of messages in a context of given agent A[1] in the agent view in Fig. 5.14. Last actions in red box on the left, enlarged in the lower right corner, leading to a deadlock in a context of the agent A[1] (green box on the right) are presented. Note that the server view shows the perspective of the cooperating controllers, and the deadlock applies to communication. The same system projected onto the agent view shows the perspective of blanks traveling through the cell, and shows the history that leads a blank to be stuck inside the press.
 The correctness of the model was indicated for 2 and 3 blanks, and for 4 blanks the model exceeds the available memory (8GB). Then, the external verifier Uppaal (with timeless modeling using urgent states, [Behrmann et al., 2006]) was used for 4 blanks and the verification showed correctness. The model with 5 blanks is too big for Uppaal, therefore a simplified specification was used. The robot arms were not modeled as separate servers and their activity was incorporated into the robot’s operation:
<i=1..N>{A[i].R.tryIn, R.arm1_at_T} -> 
{A[i].R.wait_a1extIn, R.arm1_at_T_long},
<i=1..N>{A[i].R.wait_a1extIn, R.arm1_at_T_long} -> 
{A[i].T.ok, R.arm1_at_T_long},
<i=1..N>{A[i].R.deliverIn, R.arm1_at_T_long} -> 
{A[i].R.wait_a1retIn, R.arm1_at_T_short},
<i=1..N>{A[i].R.wait_a1retIn, R.arm1_at_T_short} -> 
{A[i].R.rotate_ccw_P, R.rot_ccw_a2_P},

This model was successfully verified for 5 blanks, but for 6 blanks the problem returned. Therefore, the next step was modeling the Production Cell as the open system, in which new blanks appear at the beginning of the feed belt and they disappear at the end on the deposit belt. The traveling crane is not used. This allowed to verify the system with 6 blanks (with a deadlock concerning the last blank, which is expected in the open loop). 
5.6.8.	Increasing parallelism 
When the robot reaches its target position, it extends one of its arms until the appropriate sensor stops its movement. Therefore, the arm cannot be extended in advance, before its direction points to the device. The same applies when the blank is picked/released: the arm retracts to its rear position. This is modeled as a set of actions, starting from the point marked with black box ■ in Section 5.6.6. When the robot reaches a state requiring retracting, a signal is issued to the arm, and after receiving of a confirmation, the robot begins to rotate, driven by the internal agent LR:
■<i=1..N>{A[i].R.deliverIn, R.arm1_at_T_long} -> 
{A[i].R.wait_a1retIn, R.arm1_at_T_ret},
{AARM[1].R.retract, R.arm1_at_T_ret} -> {AARM[1].ARM[1].retract, R.arm1_at_T_ret},
{AARM[1].R.ok_ret, R.arm1_at_T_ret} -> {AARM[1].R.extend, R.arm1_at_T_short},
<i=1..N>{A[i].R.wait_a1retIn, R.arm1_at_T_short} -> 
{A[i].R.rotate_ccw_P, R.rot_ccw_a2_P},

{LR.R.rotate_ccw, R.rot_cw_a2_P} -> {LR.R.rotate_ccw, R.arm2_at_P},

<i=1..N>{A[i].R.rotate_ccw_P, R.arm1_at_P} -> 
{A[i].R.wait_a1extDepo, R.arm1_at_P_ext},

We noticed that the retracting differs from the extending of the arm: it does not depend on any sensor external to the robot. Instead, the internal robot sensor is used. Therefore, retracting the arm can be executed in parallel with the robot’s rotation. This can be achieved by simply changing the position in code in which the retracted arm position is expected, and adding a new state arm1_at_T_ret_goes in which parallel actions occur:

■<i=1..N>{A[i].R.deliverIn, R.arm1_at_T_long} -> 
{A[i].R.wait_a1retIn, R.arm1_at_T_ret},
{AARM[1].R.retract, R.arm1_at_T_ret} -> 
{AARM[1].ARM[1].retract, R.arm1_at_T_ret_goes},
<i=1..N>{A[i].R.wait_a1retIn, R.arm1_at_T_ret_goes} -> 
{A[i].R.rotate_ccw_P, R.rot_ccw_a2_P},

{LR.R.rotate_ccw, R.rot_cw_a2_P} -> {LR.R.rotate_ccw, R.arm2_at_P},

<i=1..N>{A[i].R.rotate_ccw_P, R.arm1_at_P} -> 
{A[i].R.wait_a1extDepo, R.arm1_at_P_wait},
{AARM[1].R.ok_ret, R.arm1_at_P_wait} -> {AARM[1].R. extend, R.rot_ccw_a2_P_ext},

5.7.	Time of verification
Many examples were verified using Dedan, including several versions of bounded buffer (correct and deadlock-prone versions), dining philosophers, systems with resource allocation errors and others. These are examples of primarily didactic nature, with the time of generating reachability space of several seconds and verification time shorter than 1 second. Larger systems, such as the intersection above, with 8 servers, 4 agents and 752 actions, exceed the internal possibilities of Dedan due to the huge reachability space, impossible to build in the memory explicitly. However, the intersection example, exported to external model checker with symbolic space representation and CTL verification (Uppaal, [Behrmann et al., 2006]), gives reasonable export time of 65 seconds and verification time less than 1 second. The example reduced to 3 roads (6 servers, 3 agents, 306 actions) can be verified entirely under Dedan, with reachability space generation time about 8 hours and verification time of several seconds. This confirms that with explicit reachability space representation, large examples cannot be checked. It will be better after space reduction and BDD symbolic representation techniques will be applied in Dedan (see Chapter 12). For now, large examples should be verified using external model checker, which can be invisible for a designer. An alternative method is a non-exhaustive verification using the "2-vagabonds" algorithm described in Chapter 11.
5.8.	Use in teaching – the Rybu preprocessor
The Dedan program is used in ICS, WUT student laboratory. The students get assignments concerning synchronization examples and solve the problems using semaphores and monitors. After that, the students verify their solutions using Dedan (using the built-in verifier). A team of two students (Maciej Bielecki and Jan Michalski) elaborated a preprocessor called Rybu [Daszczuk et al., 2017], allowing the specification of a verified system in imperative-style language ([Sebesta, 1996]-ch. 2), defined by the authors. Rybu converts the system directly to the Dedan input file. 
The main features of Rybu are:
•	The syntax is C-like.
•	The system is specified in the server view.
•	The servers are divided into two kinds: reactive servers and processing servers.
•	Reactive servers do not have initially assigned agents.
•	The processing server has its own agent (exactly one) invisible in Rybu specification. The server contains a sequence of “instructions”. The sequence terminates or forms a loop. Instructions form a sequence, just like in imperative languages, i.e., the successful completion of an instruction directs the “control” to the next one. To create a sequence in the Dedan code, the agent associated with the processing server sends a message to its home server, and the next instruction has this message on the input. Inside the instructions, messages are sent to the reactive servers and responses (messages as well) are obtained.
•	A simple instruction consists of sending a message to a reactive server and acquiring a response, which can be ok or a value from a general enumeration type of possible reply values. The processing server is stateless, but local variables are planned in the final version of Rybu. Then, it will be possible to store a response in a local variable. 
•	The message sent by a processing server may contain a value of a type (see later).
•	The choice instruction consists of a sending of message, obtaining a response and selecting one instruction from a set of nested instructions. 
•	The reactive server contains variables and state machine. Variables have the following types: enumeration, range, vector.
•	Variables are converted to a Cartesian product of their values (as server states).
•	Reactive server instructions simply change the server state based on the acquired messages, and send responses.
•	The unconditional instruction is fired by any message; in this case the message matches all server states.
•	A condition on the server state can be used together with an input message: only states that satisfy the condition are matched.
•	The next message or the next state or both can be present on the output. No output state means that the state is preserved. If there is no output message, ok is sent. 
•	The output value of the server state may be ambiguous: many actions are generated that match this value. For example if one of several variables is assigned, all possible values of other variables are generated. The output value can be relative to an input state value (the expression is calculated). The choice between ambiguous output states in nondeterministic.
•	For reactive servers, server types and server variables can be declared. Processing servers are variables, each declared separately. Processing server types are planned in the final version.
The Rybu program, together with several examples, is available at [“Rybu,” n.d.]. Examples include the “vector” problem (illustrating the variable vectors), the mid-semester test problem and the laboratory problem. All three examples concern buffers with complex put/get conditions. The solutions have 131, 59 and 129 lines of source code, respectively. The output code for Dedan consists of 5955, 84 and 179 lines of much denser code, respectively. The large Dedan code in the vector example is due to the explosion of values in the Cartesian product of vector elements. 
Some students found deadlocks in their solutions, the other ones proved the correctness of their code. But both groups of students, using Rybu and using Dedan directly, appreciated lessons from the formal verification. However, there are still other opinions that confirm the misunderstanding of the nature of synchronization in concurrent systems and the significance of formal verification (translation by W.B. Daszczuk):
“My conclusions: Dedan deals only with small examples, and writing in Rybu using servers ‘mutex’ and ‘semaphore’ gives an additional overhead (but a more comfortable implementation). Even with more than a total of 4 robots [servers, comment by W.B. Daszczuk] Dedan (with code generated by Rybu) does not give advice [students do not use external verifiers, comment by W.B. Daszczuk]. A version without Rybu can do the job so for about 5 or 6 robots. Generally, I do not see a good future for Dedan. In practice, to check for deadlocks, it simply works by inserting a delay with random time between synchronization operations into a program written in C++.”
Fortunately, such opinions are in the vast minority. Such an approach of testing instead of formal verification led to a famous priority inversion error in Pathfinder Mars explorer, caused in well-tested software [Pedersen et al., 2000] [Priority Inversion and Deadlock. Whitepaper, 2011].
References
Barbey S, Buchs D, and Péraire C. (1998a). A Case Study for Testing Object-Oriented Software: A Production Cell.
Barbey S, Buchs D, and Péraire C. (1998b). Modelling the Production Cell Case Study using the Fusion Method. Lausanne, Switzerland. url: https://infoscience.epfl.ch/record/54618/files/Barbey98-298..ps.gz
Behrmann G, David A, and Larsen K G. (2006). A Tutorial on Uppaal 4.0. Aalborg, Denmark. url: http://www.it.uu.se/research/group/darts/papers/texts/new-tutorial.pdf
Ben-Abdallah H, and Lee I. (1998). A Graphical Language for Specifying and Analyzing Real-Time Systems. Integrated Computer-Aided Engineering, 5(4), 279–302. url: ftp://ftp.cis.upenn.edu/pub/rtg/Paper/Full_Postscript/icae97.pdf
Benghazi Akhlaki K, Capel Tuñón M I, … Mendoza Morales L E. (2007). A methodological approach to the formal specification of real-time systems by transformation of UML-RT design models. Science of Computer Programming, 65(1), 41–56. doi: 10.1016/j.scico.2006.08.005
Beyer D, Lewerentz C, and Noack A. (2003). Rabbit: A Tool for BDD-Based Verification of Real-Time Systems. In Computer Aided Verification, CAV 2003, Boulder, CO, 8-12 July 2003, LNCS 2725 (pp. 122–125). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-540-45069-6_13
Beyer D, and Rust H. (1998). Modeling a Production Cell as a Distributed Real-Time System with Cottbus Timed Automata. In H. König & P. Langendörfer (Eds.), Formale Beschreibungstechniken für verteilte Systeme, 8. GI/ITG-Fachgespräch, Cottbus, Germany, 4-5 June 1998. München, Germany: Shaker Verlag. url: https://www.sosy-lab.org/~dbeyer/Publications/1998-FBT.Modeling_a_Production_Cell_as_a_Distributed_Real-Time_System_with.Cottbus_Timed_Automata.pdf
Björnander S, Seceleanu C, … Pettersson P. (2011). ABV - A Verifier for the Architecture Analysis and Design Language (AADL). In 6th IEEE International Conference on Engineering of Complex Computer Systems, Las Vegas, NV, 27-29 April 2011 (pp. 355–360). IEEE. doi: 10.1109/ICECCS.2011.43
Budde R. (1995). Esterel. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 5 (pp. 75–100). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_49
Burghardt J. (1995). Deductive synthesis. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 17 (pp. 295–309). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_61
Burns A. (2003). How to Verify a Safe Real-Time System - The Application of Model Checking and Timed Automata to the Production Cell Case Study. Real-Time Systems, 24(2), 135–151. doi: 10.1023/A:1021758401878
Capecchi S, Giachino E, and Yoshida N. (2016). Global escape in multiparty sessions. Mathematical Structures in Computer Science, 26(02), 156–205. doi: 10.1017/S0960129514000164
Cardell-Oliver R. (1995). HTTDs and HOL. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 15 (pp. 261–276). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_59
Cassez F, David A, … Lime D. (2005). Efficient On-the-Fly Algorithms for the Analysis of Timed Games. In 16th International Conference on Concurrency Theory (CONCUR’05), San Francisco, CA, 23-26 Aug. 2005, LNCS 3653 (pp. 66–80). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/11539452_9
Cattel T. (1995). Process Control Design Using SPIN. In Spin Workshop, Montreal, Canada, 16 Oct. 1995. url: http://spinroot.com/spin/Workshops/ws95/cattel.pdf
Cuellar J, and Huber M. (1995). TLT. In C. Lewerentz & T. Lindne (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. (pp. 151–169). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_53
Czejdo B, Bhattacharya S, … Daszczuk W B. (2016). Improving Resilience of Autonomous Moving Platforms by real-time analysis of their Cooperation. Autobusy-TEST, 17(6), 1294–1301. url: http://yadda.icm.edu.pl/baztech/element/bwmeta1.element.baztech-6ab8a90d-13a7-429b-9ecd-33cce2801f6f/c/10_L_CZEJDO_BHATTACHARYA_BASZUN_DASZCZUK.pdf
Daszczuk W B. (2003). Verification of Temporal Properties in Concurrent Systems. Warsaw University of Technology. url: https://repo.pw.edu.pl/docstore/download/WEiTI-0b7425b5-2375-417b-b0fa-b1f61aed0623/Daszczuk.pdf
Daszczuk W B, Bielecki M, and Michalski J. (2017). Rybu: Imperative-style Preprocessor for Verification of Distributed Systems in the Dedan Environment. In KKIO’17 – Software Engineering Conference, Rzeszów, Poland, 14-16 Sept. 2017 (pp. 135–150). Polish Information Processing Society. url: https://arxiv.org/abs/1710.02722
Daszczuk W B, and Mieścicki J. (2014). Chapter 7.2 Principles of PRT Network Simulation. In W. Choromański (Ed.), Ecomobility. Innovative and Ecological Tranport Means (in Polish) (pp. 193–209). Wydawnictwa Komunikacji i Łączności.
Dedan. (n.d.). url: http://staff.ii.pw.edu.pl/dedan/files/DedAn.zip
Dedan Examples. (n.d.). url: http://staff.ii.pw.edu.pl/dedan/files/examples.zip
Dierks H. (1996). The production cell: A verified real-time system. In 4th International Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems FTRTFT 1996: Uppsala, Sweden, 9-13 Sept. 1996, LNCS 1135 (pp. 208–227). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-61648-9_42
Dijkstra E W. (1971). Hierarchical ordering of sequential processes. Acta Informatica, 1(2), 115–138. doi: 10.1007/BF00289519
Ehlers R, Mattmüller R, and Peter H-J. (2010). Combining Symbolic Representations for Solving Timed Games. In K. Chatterjee & T. A. Henzinger (Eds.), 8th International Conference on Formal Modeling and Analysis of Timed Systems, FORMATS 2010, Klosterneuburg, Austria, 8-10 Sept. 2010, LNCS 6246 (pp. 107–121). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-642-15297-9_10
Fuchs M, and Philipps J. (1995). Focus. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 11 (pp. 185–197). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_55
Garavel H, and Serwe W. (2017). The Unheralded Value of the Multiway Rendezvous: Illustration with the Production Cell Benchmark. Electronic Proceedings in Theoretical Computer Science, 244, 230–270. doi: 10.4204/EPTCS.244.10
Greenyer J, Brenner C, … Gressi E. (2013). Incrementally synthesizing controllers from scenario-based product line specifications. In 9th Joint Meeting on Foundations of Software Engineering - ESEC/FSE 2013, Sankt Petersburg, Russia, 18-26 Aug. 2013 (pp. 433–443). New York, NY: ACM Press. doi: 10.1145/2491411.2491445
Grosu R, Broy M, … Stefănescu G. (1999). What is Behind UML-RT? In H. Kilov, B. Rumpe, & I. Simmonds (Eds.), Behavioral Specifications of Businesses and Systems (pp. 75–90). Boston, MA: Springer US. doi: 10.1007/978-1-4615-5229-1_6
Heiner M, and Heisel M. (1999). Modeling Safety-Critical Systems with Z and Petri Nets. In M. Felici, K. Kanoun, & A. Pasquini (Eds.), SAFECOMP ’99 - 18th International Conference on Computer Safety, Reliability and Security, Toulouse, France, 27-29 Sept. 1999, LNCS Vol. 1698 (pp. 361–374). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48249-0_31
Heinkel S, and Lindner T. (1995). SDL. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 10 (pp. 171–183). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_54
Hoare C A R. (1978). Communicating sequential processes. Communications of the ACM, 21(8), 666–677. doi: 10.1145/359576.359585
Holenderski L. (1995). Lustre. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 6 (pp. 101–112). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_50
Jacobs J, and Simpson A. (2015). A Formal Model of SysML Blocks Using CSP for Assured Systems Engineering. In Formal Techniques for Safety-Critical Systems, Third International Workshop, FTSCS 2014, Luxembourg, 6-7 Nov. 2014, Communications in Computer and Information Science 476 (pp. 127–141). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-319-17581-2_9
Klingenbeck S, and Käufl T. (1995). Tatzelwurm. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 14 (pp. 247–259). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_58
Korf F, and Schlör R. (1995). Symbolic Timing Diagrams. In Claus Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 18 (pp. 311–331). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_62
Larsen P G, Fitzgerald J S, and Riddle S. (2009). Practice-oriented courses in formal methods using VDM++. Formal Aspects of Computing, 21(3), 245–257. doi: 10.1007/s00165-008-0068-5
Lewerentz Claus, and Lindner T (Eds.). (1995). Formal Development of Reactive Systems, LNCS 891. Berlin, Heidelberg: Springer-Verlag. doi: 10.1007/3-540-58867-1
Ma C, and Wonham W M. (2005). The Production Cell Example. Chapter 5. In Nonblocking Supervisory Control of State Tree Structures. Lecture Notes in Control and Information Science 317 (pp. 127–144). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/11382119_5
Masticola S P, and Ryder B G. (1990). Static Infinite Wait Anomaly Detection in Polynomial Time. In 1990 International Conference on Parallel Processing, Urbana-Champaign, IL, 13-17 Aug. 1990 (p. Vol.2, 78-87). University Park, PA: Pennsylvania State University Press. url: https://rucore.libraries.rutgers.edu/rutgers-lib/57963/
Milner R. (1980). A Calculus of Communicating Systems, LNCS vol. 92. (R. Milner, Ed.) (Vol. 92). Berlin, Heidelberg: Springer Berlin Heidelberg. doi: 10.1007/3-540-10235-3
Nardone R, Gentile U, … Mazzocca N. (2016). Modeling Railway Control Systems in Promela (pp. 121–136). doi: 10.1007/978-3-319-29510-7_7
Pedersen M H, Christiansen M K, and Glæsner T. (2000). Solving the Priority Inversion Problem in legOS. Aalborg, Denmark. url: http://www.it.uu.se/edu/course/homepage/realtid/p2ht08/lego/prioinvers.pdf
Priority Inversion and Deadlock. Whitepaper. (2011). url: http://code-time.com/pdf/Priority Inversion and Deadlock.pdf
Ramakrishnan S, and McGregor J. (2000). Modelling and Testing OO Distributed Systems with Temporal Logic Formalisms. In 8th International IASTED Conference Applied Informatics’ 2000, Innsbruck, Austria, 14-17 Feb. 2000. url: https://research.monash.edu/en/publications/modelling-and-testing-oo-distributed-systems-with-temporal-logic-
Rosa N S, and Cunha P R F. (2004). A Software Architecture-Based Approach for Formalising Middleware Behaviour. Electronic Notes in Theoretical Computer Science, 108, 39–51. doi: 10.1016/j.entcs.2004.01.011
Ruf J, and Kropf T. (1999). Modeling and Checking Networks of Communicating Real-Time Processes. In L. Pierre & T. Kropf (Eds.), CHARME’99, Advanced Research Working Conference on Correct Hardware Design and Verification Methods, BadHerrenalb, Germany, 27-29 Sept. 1999, LNCS 1703 (pp. 267–279). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48153-2_20
Rybu. (n.d.). https://zyla.neutrino.re/rybu/
Schröter C, Schwoon S, and Esparza J. (2003). The Model-Checking Kit. In 24th International Conference ICATPN 2003: Eindhoven, The Netherlands, June 23-27, 2003, LNCS 2697 (pp. 463–472). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-44919-1_29
Sebesta R W. (1996). Concepts of Programming Languages. Reading, MA: Addison-Wesley Publishing Compan.
Sokolsky O, Lee I, and Ben-Abdallah H. (1999). Specification and Analysis of Real-Time Systems with PARAGON (equivalence checking). Philadelphia, PA. url: https://www.cis.upenn.edu/~sokolsky/ase99.pdf
Tai K. (1994). Definitions and Detection of Deadlock, Livelock, and Starvation in Concurrent Programs. In D. P. Agrawal (Ed.), 1994 International Conference on Parallel Processing (ICPP’94), Raleigh, NC, 15-19 Aug. 1994 (pp. 69–72). Boca Raton: CRC Press. doi: 10.1109/ICPP.1994.84
Vu L H, Haxthausen A E, and Peleska J. (2015). Formal Modeling and Verification of Interlocking Systems Featuring Sequential Release (pp. 223–238). doi: 10.1007/978-3-319-17581-2_15
Waeselynck H, and Thévenod-Fosse P. (1999). A Case Study in Statistical Testing of Reusable Concurrent Objects. In J. Hlavička, E. Maehle, & A. Pataricza (Eds.), Third European Dependable Computing Conference, Prague, Czech Republic, 15-17 Sept. 1999, LNCS 1667 (pp. 401–418). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48254-7_27
Žic J J. (1994). Time-constrained buffer specifications in CSP + T and timed CSP. ACM Transactions on Programming Languages and Systems, 16(6), 1661–1674. doi: 10.1145/197320.197322
Zorzo A F, Romanovsky A, … Welch I S. (1999). Using coordinated atomic actions to design safety-critical systems: a production cell case study. Software: Practice and Experience, 29(8), 677–697. doi: 10.1002/(SICI)1097-024X(19990710)29:8<677::AID-SPE251>3.0.CO;2-Z

6.	Using the Dedan program
6.1.	Program structure
The structure of the Dedan program is presented in Fig. 6.1. The central module Model contains the representation of a verified system. This module converts between the server view and the agent view of the system. The Input module allows reading the model from the file in IMDS nota-tion or XML file. The Output module saves the model in various formats:

•	IMDS (.TXT),
•	Promela (.PML - for verification under Spin),
•	SMV (.SMV - for verification under NuSMV),
•	XML Timed Automata (.XML - for verification under Uppaal),
•	ANDL (.ANDL – for analysis with Charlie),
•	Petri net (.TXT – for analysis with other Petri net tools).
In the LTS module, the global configuration space is constructed. The purpose of this module is:
•	temporal verification of deadlocks and termination (model checking, using TempoRG model checker), 
•	counterexample (trail) graphical display in the form of state and message sequence or configuration sequence, 
•	simulation over states and messages,
•	simulation over LTS.
The Edition module allows building or changing the structure of the model. Experience shows that editing the IMDS source text file is much more convenient. The DA3 (distributed automata are defined in Chapter 8) module supports graphical edition of the server/agent automata, and simulation over automata. This does not require generating the LTS. 
6.2.	Main window
 
Fig. 6.2 Main window of the Dedan program

The Dedan program, after its invoking, shows the set of tables for system specification in the server view (Edition module - Fig. 6.2). The server types are on the left while the agent types are on the right. The four middle tables contain the attributes of the selected server type: the states, services and formal parameters (used servers and used agents). Only these states, services and formal parameters can be used in the actions of the selected server type.
The list of actions in the server type is located at the bottom of the window. The action may be prefixed by repeaters (up to three). The repeater is an integer variable with a defined range. The repeaters are used in indices of the action elements. If the repeaters are used, then actions are generated for each vector in the Cartesian product of repeaters’ values.
The action consists of the input message (agent, server and service), the input state and the output state. The output message is optional: it does not occur in the agent-terminating action. Repeaters can be used in the indices of servers, agents, states and services (if they are vectors). The indices may have the form of expressions: “repeater ± constant” or “constant ± repeater”.
On the left, below the server types, server variables are listed. For each server variable, its type is given, and a “pointer” to the list of actual parameters (invoked by double clicking the pointer) and the initial state of the server variable. The window is presented in Fig. 6.3 on the left.
If the server variable is a vector, the pointer leads to the list of instances instead of the list of ac-tual parameters. For each instance, its actual parameters and initial states are defined.
On the right, below the agent types, agent variables are listed. For every agent variable, its initial message is defined (server and service).
   
Fig. 6.3 	Definition of actual parameters and initial state of a server (left) and graphical server design (right)

Each server element: a state, service or a formal parameter that is a server or an agent – it can be a vector. 
All lists allow for edition of their elements, as well as adding/removing elements. However, from the author’s experience, editing the source IMDS text file is more convenient. The alternative method of definition is graphical specification of the server type automaton in DA3 module (DA3 distributed automata are defined in Chapter 8). The server automaton design window is present-ed in Fig. 6.3 on the right.
6.3.	Files
The Input module and Output module provide access to model files. The file navigation buttons at the upper left corner are Open and Save text files in IMDS notation. The file in the server view is divided into the model name, server type definitions, optional agent type definitions, variable declarations and initialization part. The formal syntax is given in Appendix C.
6.4.	Model name
Optional model name is defined in the syntax:
system	BUF;
6.5.	Server type definition
The server type definition consists of a header, a state list, a service list (the latter two in any order) and an action list.
The header has the form:
server: buf(agents Aprod[2]:Aprod,Acons[2]:Acons;
servers Sprod[2]:Sprod,Scons[2]:Scons),  

where buf is the server type identifier, and the list of used agents and the list of used servers follow in parentheses. These are formal parameters, the actual parameters are given in the ini-tialization part. If the formal parameter types are identical to parameter names, the types can be omitted:
server: buf(agents Aprod[2],Acons[2]; servers Sprod[2],Scons[2]),  

Sometimes it is useful to have parameters of different types at the same position in various in-stances of the same server type. In such a case, the type tag self can be used. The meaning of a parameter type self is “do not check the compatibility of types”:
server: buf(agents Aprod[2],Acons[2]; 
servers Sprod[2]:self,Scons[2]:self),  

States and services are simply listed in the relevant lists:
states {elem0,elem[3]},
services {put, get},

Note that lists elements can be vectors (elem[3] in this example). Vectors are indexed from 1 to a maximum value (here, 3). This is the reason why the 0th element is excluded as a separate state in examples.
The actions are listed as pairs {message, state} -> {next message, next state} and may be pre-fixed by up to three repeaters, for example:
actions{
<i=1..3>	{Aprod[i].buf.put, buf.elem0} -> 
	{Aprod[i].Sprod[i].ok_put, buf.elem[1]},
…

The complete definition of the example server type is as follows:
server:	Sprod(agents Aprod;servers buf),
services	{doSth,ok_put},
states	{neutral,prod},
actions	{	
	{Aprod.Sprod.doSth, Sprod.neutral} -> {Aprod.buf.put, Sprod.prod},
	{Aprod.Sprod.ok_put, Sprod.prod} -> {Aprod.Sprod.doSth, Sprod.neutral},
};
6.6.	Agent type definition
The agent definition simply gives its name:
agent Aprod;

If an agent instance name (simple or vector) is identical to the agent type name, then the type need not be defined.
6.7.	Instances declaration
The instances of server types and agent types are declared as simple or vectors:
servers  buf,Sprod[3],Scons[3];
agents   Aprod[3],Acons[3];	
6.8.	Initialization part
The initialization part begins with “init -> {“ and ends with “}“. Server instances and agent instances are initialized in any order. The server instance must be supplied with a list of actual parameters (agent instances and server instances) and the initial state:
Sprod(Aprod,buf).neutral,

The initialization of the server instance or the agent instance as an element of the vector: 
Sprod[1](Aprod[1],buf).neutral,

A repeater can be applied to initialize a vector:
<j=1..3>Sprod[j](Aprod[j],buf).neutral,

If the actual parameters are vector elements, then they can be supplied individually (as above), or a list of indices or a range of indices can be applied:
buf(Aprod[1],Aprod[2],Acons[1,2],Sprod[1..2],Scons[1..2]).elem0,

The agent instance must be supplied witch an initial message, i.e., a service of a server:
Aprod.Sprod.doSth,
6.9.	Macrogenerator
The macrogenerator allows defining integer constants, which can be used in index expressions:
#DEFINE N 3
#DEFINE K 2
server:	buf(agents Aprod[N],Acons[N]; servers Sprod[N],Scons[N]),  
states	{elem0,elem[K]},	
…
<i=1..N><j=1..K-1>	{Aprod[i].buf.put, buf.elem[j]} -> 
{Aprod[i].Sprod[i].ok_put, buf.elem[j+1]},	
…
init -> {
buf(Aprod[1..N],Acons[1..N],Sprod[1..N],Scons[1..N]).elem0,
<j=1..N>	Aprod[j].Sprod[j].doSth, 			
6.10.	Verification
The verification is performed in a window invoked by “RUN VERIFICATION” button. The verification window of LTS module is invoked. Five versions of the verification are developed (a list of verification environments is below the mentioned button):
 
Fig. 6.4 Verification window

•	TempoRG – the verifier developed by the author of this monograph, adapted for the purpose of using it under the Dedan program. Adaptation consists in evaluating only a limited set of formulas, shown in Table 4.1, which speeds up the evaluation. Reverse reachability is used to identify the structure of the reachability space, see Section 9.5. TempoRG performs CTL verification [E.M. Clarke et al., 1999] on explicit reachability space, therefore large models cannot be verified. As the complete model is constructed, it can be observed as a whole (full Labeled Transition System) or sim-ulated. The window is presented in Fig. 6.4. Deadlock detection can be performed for individual servers or for all selected servers together. In some systems, a subsets of the servers may fall into a deadlock (for example, individual server or server pair), but all servers in the set never fall into a common deadlock. 
•	Spin – the LTL verifier, requires installation of Spin [Holzmann, 1995] and the GNU C compiler (32-bit Cygwin is recommended). Paths to Spin and C Compiler must be provided. Model preparation and verification can be performed as automatic se-quence of program calls or step-by-step. 
•	SMV (connection in development) – the CTL and LTL verifier, based on the symbolic reachability space representation.
•	Uppaal – TCTL (CTL with time constraints [Alur and Dill, 1994]), based on symbolic reachability space representation. The connection Dedan   Uppaal works, the con-nection in opposite direction for interpretation of counterexamples is under develop-ment.
•	2-vagabonds – non-exhaustive verifier (see Chapter 11).
The counterexample consists of a sequence of messages sent between servers, and the states of these servers. At the end of the sequence, states and pending messages of the erroneous configuration are shown, for instance in Figs. 5.2 and 9.2. 
The counterexample can also be observed as a system configuration sequence (Fig. 6.5). The configuration is shown textually on the left, while messages pending at individual servers are shown graphically on the right. The matching pair that enables the action is connected by a segment.
Counterexamples can be written to the file in formats: JPG, PNG, BMP and PDF.
 
Fig. 6.5 Counterexample viewed as configuration sequence

The verified system can be simulated as presented in Fig. 6.6. All matching pairs are connected by the arrows leading to a common box describing an action to execute: the next server state and the next agent message (if any). Clicking this box causes the execution of the action and the output configuration becomes current.
 
Fig. 6.6 Simulation of a model

A entire LTS can be observed as a graph (Fig. 6.7). Simulation is possible over LTS. On the left, the current configuration is shown textually and a list of next configurations is listed, each with the matching input pair of the action, leading to the next configuration. Clicking one of the next configurations makes it current. On the right, each configuration is shown in a box, and possible next configurations are appointed by arrows. The current configuration is distinguished with a green box, and the red arrows lead to the next configurations. Matching pairs are displayed on the top of each possible next configuration on a pink background. Clicking any visible configura-tion results in a detailed display of its data and enables taking this configuration as current. 
 
Fig. 6.7 LTS window

Simulation is possible without the calculating the global LTS, using the SIMULATE button in main window. This simulation is described in Chapter 8 (Fig. 8.4), because it is carried out over the automata representing the servers.
6.11.	Agent view
The button on upper right corner of the main window converts the model to the agent view, and displays it in a separate window. The shape of this window is similar to the main window (the server view), with the difference that formal and actual parameters are attributed to the agent types and agent variables rather than to servers. Of course, states and services are still attributed to server types. It is shown in Fig. 6.8. 
During the conversion process, agent vectors may be split into individual variables (when vector elements differ, for example in the lists of actual parameters). Verification is performed for agent processes. The difference lies in the deadlock definition: the agent process is deadlocked if its message is pending (at any server) and will never be accepted. In addition, the termination of the agent processes can be checked in the agent view. In the counterexample (or the witness) in the agent view, time lines of individual servers and individual agents are displayed.
 
Fig. 6.8 The agent view

Counterexamples in the agent view are presented in Figs. 5.4, 5.5 and 5.10.

7.	Deadlock detection in Petri net equivalent to IMDS
7.1.	Petri net equivalent to IMDS
Although Dedan's main goal is finding deadlocks, the user may be interested in the other proper-ties of the verified system, for example:
•	structural features of the system: structural conflicts, dead code (in Dedan it is a set of never-accessible actions), pure cyclic system or not, etc.,
•	temporal properties other than deadlock: if the system is safe from some erroneous situation, if given situations are inevitable, etc.,
•	graphical definition of concurrent system components (servers or agents),
•	graphical simulation over concurrent components rather than in terms of a global graph.
In order to support these possibilities, several additional amenities are added to Dedan. In addition to exports to external model checkers, the interface with Charlie Petri net analyzer [Charlie, n.d.] [Heiner et al., 2015] is6 added for structural analysis. The export is in ANDL format (Abstract Net Description Language [Schwarick, 2013]).
The IMDS system can be converted to an equivalent Petri net [Daszczuk and Zuberek, 2018]. Each server state p is converted to a place p and each message m is converted to a place m. Each action (m,p)(m’,p’) is equivalent to the Petri net (PN) transition l, which has the places p and m on input and places p’ and m’ on output. In the case of the agent-terminating action (m,p)(p’), the PN transition l has only one output place p’. It is illustrated in Fig. 7.1. The colors   in the figure are used for readability, it is not a colored Petri net in the sense of [Jensen and Kristensen, 2009]. 
The initial marking of the Petri net has tokens in all places of the initial server states and all places of the initial agent messages. By construction (of the described conversion of the IMDS system to a Petri net) the reachable markings graph of PN has identical structure as the LTS of IMDS: states  ”red” places, messages  ”green” places, actions  PN transitions, configuration  PN marking, initial configuration  initial PN marking.
7.1.1.	Petri net definition
Below we present the definition of a safe Petri net (PN with place capacity 1). It differs from liter-ature  [Zuberek, 2009] in joining the definitions of transitions and arcs to a compound definition of transitions, which is more suitable for showing the correspondence between IMDS and PN.
•	Petri net = (HPN, HPN0, Tr), where:	(7.1)
o	HPN is the set of places,
o	HPN0  HPN is the set of initial places,
o	Tr  2HPN  2HPN– the set of transitions, the transition tr = (Hinp, Hout)  Tr has a set of input places Hinp(tr) and a set of output places Hout(tr).
•	mark  HPN – marking – the subset of places which are marked, we say that each place in the marking is equipped with a token.
•	mark0 = HPN0 – the initial marking, i.e., the set of places equipped initially with tokens.
•	Firing a transition: if  trTr tr = (Hinp, Hout),  mark  Hinp(tr)=Hinp(tr)  mark  Hout(tr)\ Hinp(tr)  =   mark’ = mark\Hinp(tr) Hout(tr), Hinp(tr) is the input set of tr and Hout(tr) is the output set of tr ; mark is an input marking markinp(tr) Hinp(tr) and mark’ is an output marking markout(tr) Hout(tr); we say that the transition removes input tokens from its input set and inserts output tokens into its output set.
•	The transition tr is enabled in mark iff 
mark  Hinp(tr)=Hinp(tr)  mark  Hout(tr)\ Hinp(tr) = .
•	LTSPN = <NPN,nPN0,WPN> |
o	NPN  2HPN – the set of nodes,
o	nPN0 = mark0 – the initial node, root of LTSPN,
o	WPN  { (markinp(tr),tr,markout(tr)) | trTr } – the set of LTS transitions.
7.1.2.	Translation of IMDS to PN
IMDS system is translated to PN = (HPN, HPN0, Tr) such that
•	HPN = M  P	(7.2)
•	mark0 = Mini  Pini	(7.3)
•	Tr:  =((m,p),(m’,p’)) iff {m,p}Tr{m’,p’};   =((m,p),(p’)) iff {m,p}Tr{p’};	(7.4)
The correspondence between LTS and LTSPN:
1.	Correspondence between n0 and nPN0:  pPini iff p=p0i HPN0, mMini iff mHPN0 (from (7.3)).
2.	Correspondence between N and NPN: T H  nPN  nPN2HPN  (T - IMDS configuration, HPN – set of all IMDS items) (from (7.2)).
3.	Correspondence between  and Tr: 
a.	In mark0, exactly one place for every server is in mark0 (Pini has exactly one state for every server) and exactly one place for every agent is in mark0 (Mini has exactly one state for every agent) (from (7.3)). Hence, the output places for every enabled PN transition are not marked or they are the same as input places. For every  the trTr is defined, therefore for every prepared action  prepared in Mini  Pini the corresponding PN transition tr (having the corresponding input and output) is enabled. 
b.	Firing the PN transition that has a pair of places on input empties these two places and inserts tokens to output places. If the input marking of the PN transition markinp(tr) has one token for every server and at most one token for every agent, and the output state place p’ concerns the same server as the input state place and the output message place m’ concerns the same agent as the input message place (or there is no output message place), then the output marking has still one token for every server and at most one token for every agent. Moreover, the same agents are represented in the output marking or the output marking in smaller by one agent: the agent that is not represented in lacking output message place (from (7.4)). This ensures that the output places of the PN transition are empty or they are the same as input ones.
c.	Having exactly one token for every server and exactly one token for every agent in the initial marking, and the transitions that preserve the number of tokens of the servers and preserve or reduces the latter number by the agent terminating in the PN transition, we get in result that exactly the PN transitions corresponding to prepared IMDS actions are enabled in the input marking equal to the input con-figuration, and the output marking corresponds to the output configuration. 
4.	Thus we can conclude that the LTSPN of a PN corresponding to an IMDS system corre-sponds to the LTS of this IMDS system.
7.1.3.	Example
The example of the “Two semaphores” system (Fig. 5.1) converted to the Petri net (in ANDL format) is shown below. First, the places with initial marking are defined. Then the transitions follow, with input places marked “-1” and output places “+1”. For example, the action (m1,p1)(m2,p2) in the server s is modeled as s_1::[m1-1]&[p1-1]&[m2+1]&[p2+1]:1;. The final “1” is not important.
pn [ two_sem ] {
constants:
places:
A_1_sem_1_wait = 0 ;
A_1_sem_1_signal = 0 ;
A_2_sem_1_wait = 0 ;
A_2_sem_1_signal = 0 ;
sem_1_up = 1 ;
…
transitions:
sem_1_1::[A_1_sem_1_wait-1]&[sem_1_up-1]&[A_1_proc_1_ok_wait+1]&[sem_1_down+1]:1;
sem_1_2::[A_2_sem_1_wait-1]&[sem_1_up-1]&[A_2_proc_2_ok_wait+1]&[sem_1_down+1]:1;
sem_1_3::[A_1_sem_1_signal-1]&[sem_1_down-1]&[A_1_proc_1_ok_sig+1]&[sem_1_up+1]:1;
…
}

The report from Charlie [Heiner et al., 2015] contains (among other data) some statistics about elements of the generated Petri net model:
input places:
	|12.A_1_proc_1_start	:1,
	|15.proc_1_ini	:1,
	|19.A_2_proc_2_start	:1,
	|22.proc_2_ini	:1
output places:
	|18.proc_1_stop	:1,
	|25.proc_2_stop	:1
input transitions:
no input transitions
output transitions:
no output transitions

number of places: 29
number of transitions: 20
number of arcs: 78
the net is not connected,
there are 2 components:
C1:
place: A3_r_right, id: 27, orgId: 27
place: A3_r_left, id: 26, orgId: 26
transition: r_19
place: r_res, id: 28, orgId: 28
transition: r_20
C2:
place: proc_2_first, id: 23, orgId: 23
place: A_1_sem_1_signal, id: 1, orgId: 1
transition: proc_1_11
transition: proc_1_10
transition: proc_1_12
place: A_2_sem_2_signal, id: 9, orgId: 9
place: A_2_sem_1_wait, id: 2, orgId: 2
transition: proc_1_13
…

The report says that there are two separate components in the net (C1 is composed of r server with A3 agent and C2 is composed of servers sem[1..2], proc[1..2] and agents A[1..2]); no unusable parts of the model (dead code) are reported. In Charlie, total communi-cation deadlocks can be found using search for siphons [Schmid and Best, 1978] [Chu and Xie, 1997], see Section 7.2. 
Fig. 7.2 presents graphically the “Two semaphores” system (Fig. 5.1), converted to the Petri net. There are shown three agents A[1], A[2] and A3 (names in italics), their servers of origin proc[1], proc[2] and r, and two semaphores sem[1], sem[2]. The initial marking of eve-ry server and every agent is surrounded by bold ovals. The states and services concerning indi-vidual servers are separated by dashed lines. The places of proc[1] and proc[2] are filled with a grid pattern (with different density for individual servers), and places of sem[1] and sem[2] are filled with checkerboard pattern (in diamonds for sem[1]). The places of A[1] are hatched diagonally and of A[2] horizontally). The agent A3 is hatched vertically and its server r has a solid fill.
7.2.	Deadlock detection using siphons
A siphon is a Petri subnet that, if loses the tokens, cannot restore them and remains unmarked. If the emptying of a siphon is reachable, it denotes a deadlock [Zuberek, 2009]. 
The advantage of siphon analysis is that multiple total deadlocks can be found in a verified sys-tem, while model checking typically finds one deadlocks and then the analysis is stopped. It is because the purpose of model checking is to evaluate temporal formulas, so finding a single configuration providing false result is enough. Conversely, structural analysis of a Petri net allows for identification of all elementary siphons (elementary siphons do not contain other siphons). 
Consider a buffer serving two processes, each of which can by a sender or a receiver. In a neu-tral state, an agent can decide whether to put or to get (lines 16,17). The source code is be-low:
1.	#DEFINE N 2
2.	#DEFINE K 1

3.	server:	buf(agents Aprodcons[N];servers Sprodcons[N]),  
4.	services	{put, get},
5.	states	{elem0,elem[K]},								
6.	actions	{
7.	<i=1..N>{Aprodcons[i].buf.put, buf.elem0}		-> 						{Aprodcons[i].Sprodcons[i].ok_put, buf.elem[1]},		
8.	<i=1..N><j=1..K-1>{Aprodcons[i].buf.put, buf.elem[j]}	-> 					{Aprodcons[i].Sprodcons[i].ok_put, buf.elem[j+1]},	
9.	<i=1..N><j=2..K>{Aprodcons[i].buf.get, buf.elem[j]}	-> 					{Aprodcons[i].Sprodcons[i].ok_get, buf.elem[j-1]},	
10.	<i=1..N>{Aprodcons[i].buf.get, buf.elem[1]}		-> 						{Aprodcons[i].Sprodcons[i].ok_get, buf.elem0}
11.	}

12.	server:	Sprodcons(agents Aprodcons;servers buf),
13.	services	{doSth,ok_put,ok_get}
14.	states	{neutral,prod,cons}
15.	actions	{	
16.	{Aprodcons.Sprodcons.doSth, Sprodcons.neutral} 	-> 
		{Aprodcons.buf.put, Sprodcons.prod}		
17.	{Aprodcons.Sprodcons.doSth, Sprodcons.neutral}	-> 
		{Aprodcons.buf.get, Sprodcons.cons}
18.	{Aprodcons.Sprodcons.ok_put, Sprodcons.prod}		-> 
		{Aprodcons.Sprodcons.doSth, Sprodcons.neutral}
19.	{Aprodcons.Sprodcons.ok_get, Sprodcons.cons}		-> 
		{Aprodcons.Sprodcons.doSth, Sprodcons.neutral}
20.	}

21.	servers 	buf,Sprodcons[N];
22.	agents	 Aprodcons[N];	

23.	init	->	{ 
24.	<j=1..N>Sprodcons[j](Aprodcons[j],buf).neutral,
25.			buf(Aprodcons[1..N],Sprodcons[1..N]).elem0,

26.	<j=1..N>Aprodcons[j].Sprodcons[j].doSth, 	
27.	}.		

The example was converted to ANDL format, where the place names are compound of agents with their messages or servers with their states. For example, the message (Aprodcons[1],buf,put) is converted to Aprodcons_1_buf_put), and the state (buf,elem[1]) is converted to buf_elem_1.
The system was subject of siphon analysis in Charlie. There are 49 elementary siphons, but we show how abstraction classes can be built over them. Below is a list of elementary siphons (called minimal in Charlie):
minimal siphon ( place ) = 
1	|0.Aprodcons_1_buf_put	:1,
	|2.Aprodcons_2_buf_put	:1,
	|5.buf_elem_1	:1,
	|6.Aprodcons_1_Sprodcons_1_doSth	:1,
	|8.Aprodcons_1_Sprodcons_1_ok_get	:1,
	|10.Sprodcons_1_prod	:1,
	|14.Aprodcons_2_Sprodcons_2_ok_get	:1,
	|15.Sprodcons_2_neutral	:1,
	|16.Sprodcons_2_prod	:1
2	|1.Aprodcons_1_buf_get	:1,
	|3.Aprodcons_2_buf_get	:1,
	|4.buf_elem0	:1,
	|6.Aprodcons_1_Sprodcons_1_doSth	:1,
	|7.Aprodcons_1_Sprodcons_1_ok_put	:1,
	|11.Sprodcons_1_cons	:1,
	|13.Aprodcons_2_Sprodcons_2_ok_put	:1,
	|14.Aprodcons_2_Sprodcons_2_ok_get	:1,
	|15.Sprodcons_2_neutral	:1
	… (etc)	

The system has two obvious deadlocks: getting from an empty buffer by both agents and putting to a full buffer by both agents. There should be siphons that can be emptied, representing the two deadlocks. There are 49 elementary siphons found. Every empty siphon can be checked for reachability using the model checking technique (in Charlie’s output, the set of places is listed that should be emptied, and every emptied place represents the lack of message or state in the configuration), using the CTL formula AG ( ) (or LTL formula  ()), where  is the empty siphon. In the example above, the Uppaal formula (Uppaal [Behrmann et al., 2006] is one of ex-ternal model checkers used in Dedan, it is described in Chapter 9) for the siphon number 1 is (services has the encoding 1-put, 2-get, 1-doSth, 2-ok_put, 3-ok_get):
A[] !(Aprodcons_1_buf!=1 & Aprodcons_2_buf!=1 & !buf_.elem_1 & Aprodcons_1_Sprodcons_1!=1 & Aprodcons_1_Sprodcons_1!=3 & !Sprodcons_1.prod & Aprodcons_2_Sprodcons_2!=3 & !Sprodcons_2.neutral & !Sprodcons_2.prod)
Verification gives the result false, which means that the siphon can be emptied. Uppaal generates a counterexample, in which both agents perform get on an empty buffer (state elem0). Many other siphons can be emptied by two get operations on an empty buffer. All these situations constitute a single deadlock (but the counterexamples can differ in the order of issuing get by the two agents). Therefore, each siphon can be easily checked for emptying (there are some siphons that are not emptied in the example, for instance (buf_elem0,buf_elem_1)). Be-cause some siphons are equivalent (they have the same or equivalent counterexamples, differ-ing in the order or operations), abstraction classes should be made in the set of siphons. The criterion for the allocation of siphons to the abstraction classes is the configuration that finishes the counterexample (it is equivalent to the corresponding marking in the Petri net). In this exam-ple, there are two abstraction classes representing the two possible deadlocks, they are identified by the configurations (triples are messages, pairs are servers’ states):
1.	{(Aprodcons[1],Sprodcons[1],get), (Aprodcons[2],Sprodcons[2],get), (Sprodcons[1],cons), (Sprodcons[2],cons), (buf,elem0)}
2.	{(Aprodcons[1],Sprodcons[1],put), (Aprodcons[2],Sprodcons[2],put), (Sprodcons[1],prod), (Sprodcons[2],prod), (buf,elem[1])}

For small systems, for which the LTS is prepared internally in Dedan, the reachability of siphon emptying can be checked directly over the LTS. For example, for siphon number 1 the reachabil-ity of siphon emptying can be verified by the inspection of the LTS and finding a configuration in which:
•	pending message of the agent Aprodcons[1] is not put at buf, or the agent is terminated (no pending message of Aprodcons[1]),
•	pending message of the agent Aprodcons[2] is not put at buf,
•	current state of the server buf is not elem_1,
•	pending message of the agent Aprodcons[1] is not doSth at Sprodcons[1],
•	pending message of the agent Aprodcons[1] is not ok_get at Sprodcons[1],
•	current state of the server Sprodcons[1] is not prod,
•	pending message of the agent Aprodcons[2] is not ok_get at Sprodcons[2],
•	current state of the server Sprodcons[2] is not neutral.
Because a siphon may be emptied in various ways, it can lead to more than one deadlock. Model checking identifies one example of emptying the siphon in a single run. Therefore, our procedure does not guarantee the identification of all deadlocks in a single run, one deadlock is found per a reachable empty siphon. Nevertheless, the ability to identify multiple deadlocks (one for every abstraction class of emptied siphons) in a single procedure is an advantage. In addition, the described procedure liberates from constraining siphon-based deadlock detection only to purely cyclic systems.
7.3.	Problem with not purely cyclic systems
The example of bounded buffer is a purely cyclic system. If a system is not cyclic, it may contain a leader – the initializing subnet of the system before it starts to operate cyclically. Such a leader obviously contains a siphon – an emptied subnet which does not restore tokens (because it is not needed). Such a system of “Two semaphores” is described in Section 5.1. The siphon is found for every place that implements the initial state of the server or the initial message of the agent (siphons number 4,5,7,8,9):
minimal siphon ( place ) = 
1	|10.sem_2_up	:1,
	|11.sem_2_down	:1
2	|26.A3_r_left	:1,
	|27.A3_r_right	:1
3	|1.A_1_sem_1_signal	:1,
	|3.A_2_sem_1_signal	:1,
	|4.sem_1_up	:1,
	|7.A_1_sem_2_signal	:1,
	|9.A_2_sem_2_signal	:1,
	|10.sem_2_up	:1,
	|13.A_1_proc_1_ok_wait	:1,
	|14.A_1_proc_1_ok_sig	:1,
	|20.A_2_proc_2_ok_wait	:1,
	|21.A_2_proc_2_ok_sig	:1
4	|15.proc_1_ini	:1
5	|22.proc_2_ini	:1
6	|4.sem_1_up	:1,
	|5.sem_1_down	:1
7	|19.A_2_proc_2_start	:1
8	|12.A_1_proc_1_start	:1
9	|28.r_res	:1

For the siphon number 7, formula A[] !(A_2_proc_2!=1) evaluates to false, suggesting a deadlock, but it is the initial agent message (A[2],proc,start), included in the leader. Fig. 7.3 shows two types of initial siphon that can be emptied, the leader siphon is depicted on the left (Fig. 7.3a) and another type of siphon on the right (Fig. 7.3b). In the figure “Ending Strongly Connected Subgraph” is a cycle from which there is no escape. Alternatively, the system can have a terminating trailer part (reverse counterpart of the leader), which can contain the emptyable siphon. The pictures are schematic, showing the overall shape of the system. Examples of not purely cyclic systems, known from the literature, are:
•	“linear” systems (such as “two semaphores” described in Section 5.1: users issue wait to two semaphores, then they issue signal and terminate),
•	a system with “leader” (initial part) and a main loop, sometimes called “lasso-shaped” [Latvala et al., 2004],
•	terminating system with a main loop, for example WF-net system [van der Aalst, 2000], 
•	similar to lasso-shaped, but with an initial loop (Fig. 7.3b),
•	a system with cyclical part, and an escape from it to the terminating trailer.
In some cases, for example in WF-nets, the system can be easily converted to a cyclic one, connecting initial and terminating places. However, in the analysis of distributed systems, espe-cially those following the IoT paradigm, a system can have multiple leaders (for every node) and multiple terminating places, where the nodes reach their goals. An example is Automatic Vehicle Guidance System presented in Section 5.4. 
To solve such problems, a procedure was made to verify if the siphon denotes a deadlock:
1.	For every siphon found by a Petri net analysis tool (like Charlie), a formula  is con-structed, as described in Section 7.2. The siphon contains a set of places being states and messages. 
2.	The possibility of emptying the siphon is tested, using the formula AG ( ).
3.	If the result is false, the siphon can me emptied, and for each server and agent its con-tinuation, the formula is verified: AG(  EF  (/restricted to the process)). This identi-fies the processes involved in the deadlock.
After this procedure, the following cases can be concluded based on the result of the evaluation of the formula in p.3:
•	the formula is true – the process is not in deadlock,
•	the formula is true for all processes – the siphon is not a deadlock,
•	the formula is false for all processes – total deadlock,
•	the formula is false for selected processes – partial deadlock, agents/servers with false result participate.
In “Two semaphores” example, the siphons listed above denote:
•	1,2,6,9: not emptyable siphons – no deadlock,
•	3: deadlock siphon of sem_1 and sem_2 in the server view, and of proc_1 and proc_2 in the agent view,
•	4,5,7,8: emptyable leader siphons – no deadlock.
7.4.	Translation from Petri net to IMDS
The IMDS formalism is sometimes regarded as exotic to people who are used to apply other formalisms. That is why we describe the invention of IMDS step by step, adding the natural fea-tures of distributed systems. For this purpose, the well-known formalism of Petri nets is used. We are making the following assumptions about Petri net:
•	Places capacity equal to 1.
•	Interleaving semantics (one transition is fired at a time).
7.4.1.	Servers
Our requirement is that we should do not arbitrarily construct places. If we give a new attribute (with a set of values) to the set of places, then we can split the places accordingly, assigning each value of the new attribute to one of the new places.
We see the system as a node – a single place (Fig. 7.4a). The system runs – it performs some actions (Fig. 7.4b). If the system is distributed, we see its activity as messages exchanged inside. We model the system as the entity place and the message place (but without identifying individual messages), to distinguish the system structure from its behavior (Fig. 7.4c). This shows the assumptions imposed on the model: 
1.	The action is caused by a message.
2.	The action causes the next message.
In addition to the colors used in this monograph for servers and their states (red), agents and their messages (green), we also use different hatching (vertical/horizontal vs. diagonal) and font (regular vs. italics).
Having extracted messages, we see that the system accepts the message and causes the next message to appear. To run such system, we need tokens in the entity place and in the message place. The latter can be interpreted as the initial message starting the calculation run and then being the carrier of the calculation.
From now on, we require that each transition has two input arcs: one from an entity place (after proper splitting, below we call them server places) and the other from a message place. We call them input places of a transition.
At the same time, we require for every transition (with the exception of termination, described later) to have two output arcs: one to the entity place and the other to the message place. We call them output places.
As the system is distributed, we distinguish its components – the servers, replacing the single entity. Messages are sent just between these servers, and each message has a target server (Fig. 7.5a). In the figure, individual server places and message places differ in color and hatch density. The server place and the message sent to this server have the same hatching direction.
We can see that the server can send a message to itself or to another server. In the system in Fig. 7.5a, sending to the other server is blocked due to the occupancy of each message place by the token. The only option is to simultaneously fire the two transitions sending messages to an-other server (S to T and T to S), which is prohibited due to interleaving semantics. Therefore, in the example we give the initial token only to one of the messages (Fig. 7.5b), but this is not a general requirement and we will be able to give up on this after the next splitting of places.
The transition models the activity of the server, therefore we require that the transition has input arcs concerning the same server (for example, arcs from “Server S” place and “Message to S” place). One of the output arcs must lead to the same server as the input arc from the server place, to preserve the server activity. The other output arc can lead to any server, because it models sending a message.
At this point, we see the next assumption imposed on the distributed  system model:
3.	The server can send a message to itself.
An additional feature is a restriction: the action cannot cause a set of messages directed to the servers (only one message is caused by the action). This is of course our own assumption and not a general requirement.
7.4.2.	Agents
To introduce the next feature, we want to have three servers, like in Fig. 7.6a. The system is similar to that in Fig. 7.5, with one server added. No server sends messages to itself, which hap-pens in Fig. 7.5. The servers T and U can send messages to the server S (and accept response messages), but servers T and U do not communicate with each other directly. Note that although both T and U servers can send messages to the server S, the messages cannot be pending at S simultaneously because the capacity of the place “Message to S” is 1.Each server place has a renewable token which means that the server is always ready to accept a message.
Now we may say that some distributed computations are performed in the system. There may be several such computations. Even a single server can start more than one computation. We introduce a new entity called agent, which represents a distributed computation. The agent de-fines a sequence of actions to be performed on the servers in the system, caused by messages attributed to this agent. In this way, we change the message place attributes: they are pairs (server, agent), and the meaning of the pair is “message sent to the server in the context of the agent”. At the same time we withdraw the “message to server” attribute from the message plac-es. This is illustrated in Fig. 7.6b, where agents A and B are introduced. Each server has a dif-ferent hatch (horizontal, vertical or grill) and each agent has its own hatch (diagonal). The same hatch scheme is used in the following figures.
Now, two messages (A,S) and (B,S) can be pending at the server S at the same time. Of course only one of the actions caused by these two messages can be fired, because of interleaving se-mantics.
The transition has two server places of the same server on input and on output. The second input place is the agent’s message. To obtain a continuous computation, the output message place must have the same agent attribute as the input message place.
To start a computation, exactly one of the places of the agent has an initial token. By construc-tion, always exactly one of agent places contains a token, because the transition transfers a to-ken from its input message place to its output message place (except the termination, described later). 
During the system run, some situations may prohibit certain actions while others are enabled. For example, sending an element to a full buffer is forbidden, while sending it to an empty buffer is possible. To distinguish such situations, we introduce a set of states attributed to every server. The server state (full or empty buffer in the example) is defined by the value of all its internal variables. In this way, we change the server place attributes: they are pairs (server, value), and the meaning of a pair is “server state value”. At the same time we withdraw the “server” attribute from server places. This is illustrated in Fig. 7.7a, where values V and W are introduced into the server S. The server T has only one state with value M and the server U with value N. For clarity, the states of a given server and the messages of a given agent are shaded in uniform way.
Each server has an initial token in exactly one of its places. By construction, always exactly one of the server’s places contains a token (it is the initial value of the server state).
Until now, the agent can send a message to the server. But in distributed systems, the server can offer several different operations, for example, granting the resource and releasing it. Such operations are called server services. Even a single agent can call different services, depending on the progress of the calculation. Such a system is illustrated in Fig. 7.7b, where agent B causes the server S to switch between two states V and W, by invoking the services H and G. The server U offers the only service J. The service is the third attribute of the message place. The two actions executed on the server U invoke the services G and H of the server S. 
7.4.3.	Example
An example of a system consisting of a 1-element buffer and two producers/consumers (switch-ing nondetrministically between producing and consuming) is presented in Fig. 7.8. The buffer and the two users have their own servers: S1, S2 and buf. Each user is equipped with its own agent (A1/A2) which produces/consumes elements and puts them to/gets from the buffer. In each user’s server, the state n is neutral, prod is producing and cons is consuming. The services invoked at the buffer are put and get. The buffer sends responses ok_put and ok_get. After receiving a response, the agent issues a message doSth to its own server and then chooses producing or consuming, in a nondeterministic way.
7.4.4.	Termination
In some systems the computations can finish. For this purpose, a special type of transition is defined: no output message place is present. Fig. 7.1 shows a regular action and a terminating action.
7.4.5.	Processes
Now it’s time to define processes in the system. Note that we defined a structure of the system, without the concept of processes. In this way, the processes are extracted from the system, ra-ther than the system is constructed over processes. This approach is on purpose, because pro-cesses can be defined in various ways. We focus on asynchronous processes. 
The assumption is that we build processes over transitions. The process is a sequence of transi-tions. It is a loop in a cycling system, or a finite sequence in a terminating system. Of course, mixed structures are possible, for example “lasso-shaped” system, where initializing sequence is followed by an infinite loop, or a system terminating with a trailer part.
In Petri net often processes are defined over transitions. Usually, places are divided into two subclasses: process carriers and resources. The place connecting two transitions in a sequence is the process carrier. We say that the connecting place “threads” the process. The other places model  the resources, acquired in arcs leading to transitions and released in arcs leading from transitions.
In our model, each transition has two input and two output places (with the exception of agent-terminating actions). This looks similar to the process/resource model above, but messages oc-cur instead of resources. It is illustrated in Fig. 7.9, based od [Zuberek, 1999]. Process places have different diagonal hatching  and resource places have horizontal and vertical hatching. A similar approach is described in [López-Grao and Colom, 2010], where process arcs are shown as solid arrows while resource allocation arcs are dashed. Acquiring the resource and releasing it are separated from each other, therefore the transitions have 1 input place/2 output places or vice versa, but this difference does not change much. 
The main difference is that agent messages appear in sequence, traveling between servers (possibly multiple servers), while the resource place loses the token just for the time the resource is used, and then receives the token back. Note that there are papers in which a duality other than ours is described, in [Wu and Zhou, 2010] two Petri net types are considered: process-oriented and resource-oriented. However, those are not two aspects or “views” of a uniform net. The dichotomy between the process view and the resource view is modeled using two different Petri net structures that serve to model the views. In our approach, these are the two definitions of processes in a uniform net, rather than two separate nets. Note that in our model, the resources are not modeled directly, because in a distributed environment, resource allocation is not performed as a single operation. Resources are distributed over the network, therefore the minimum activity to obtain a resource is to send a request, wait for grant and obtain a grant con-firmation. Therefore, everything lies in communication.
In our model, we can choose which of the places “threads” the process: state place or message place. The answer is: whatever you want. Each of the input places can be chosen as a process carrier. If we choose state places, we get the server process. It consists of actions threaded by state places. However, we may choose message places gluing a process, resulting in the agent process. In Fig. 7.10, we have the system from Fig. 7.6, with two server processes highlighted (Fig. 7.10a) and one agent process highlighted (Fig. 7.10b). The arcs between the process tran-sition and the places gluing the process are thickened and colored with appropriate color (red for servers, green for agents). In addition, the arcs of the server process U are distinguished by dashing. 
In the system, exactly one of the places of the server has a token. Similarly, exactly one of the places of an agent has a token (or at most one place, if the agent terminates). Therefore, we can change the requirement 1 (the capacity of places is 1), restricting it to the initial places of servers and agents. In other places, the requirement is achieved by construction. 
Another problem arises: if we choose the places of given kind (state places or message places) as a process carrier, what about the other places? The answer is simple: the remaining places serve as means of communication. Now we can give two projection names: server view and agent view. In the server view, state places are the carriers of server processes while message places are the means of communication. In the agent view, message places are the carriers of agent processes while state places are the means of communication. The behavior is uniform, because it is a uniform system. Behavior is modeled by the reachability graph of the markings.
7.4.6.	Formal Requirements for Petri Net
Now we show, how to formally build the Petri network to fit our assumptions. 
1.	Interleaving semantics (one transition is fired at a time). 
2.	Each transition has two input places: server state (s,v) and message (a’,s’,r’). The server component of both places must match (s=s’) (Fig. 7.11a).
3.	Each regular transition has two output places: the new server state (s,v’’) and the next agent message (a,s’’’,r’’’). Input and output state places have the same server attribute, while input and output agent places have the same agent attribute (Fig. 7.11b).
4.	The agent-terminating transition has only one output place: the new server state (s,v’’). The input and output state places have the same server attribute (Fig. 7.11c).
We must supplement the principles with initial marking: 
5.	Among the places of any server’s states, exactly one has an initial token. It is the initial state of the server (Fig. 7.8, for example the state place (S1,n) of the server S1).
6.	Among the places of any agent’s messages, exactly one has an initial token. It is the initial message of the agent (Fig. 7.8, for example the message place (A1,S2,doSth) of the agent A1).
7.4.7.	Communication Duality, Locality, Autonomy and Asynchrony
The proposed construction of the Petri net exposes the real properties of distributed systems:
•	Communication duality: a token moving through places of the server’s states is the carrier of the server process, while the tokens in matching message places are means of communication (Fig. 7.12a, server process S, T, U). In the dual view, a token “traveling” through the agent’s message places is the carrier of the agent’s process, while the tokens in matching state places are means of communication (Fig. 7.12b, agent processes A, B, C). In the figure, transitions have server colors in the server view and agent colors in the agent view. Transitions “belong” to the server processes in the server view and to the agent processes in the agent view. The semicircular arrows in the figure show the flow of processes: a) server processes following the servers states (bold), b) agent processes following the messages (bold), traveling between the servers.
•	Locality: the server transition is made only based on its current state and messages pending at this server. The only manner to influence the behavior of the server is to send a message to it. This is illustrated in Fig. 7.13a: three messages are pending at the server S, two of them match the current state of the server and can fire the transitions (of agents A and B), the third message does not match (of agent C), and the message of the agent D matches but is not pending.
•	Autonomy: only the server decides autonomously which messages would be accepted, it is controlled by matching between states and messages. In Fig. 7.13b, state V matches messages of agents A and B invoking services G and H, while state W matches mes-sages of agents C and D invoking services J and H.
•	Asynchrony of actions: usually the current state waits for a matching message (Fig. 7.14a) or the pending message waits for a matching state (Fig. 7.14b), the two to-kens appear synchronously only when a message is sent to the sending server itself (Fig. 7.14c: the next state and the next message appear synchronously on the output of the transition, but this case appears entirely inside a process: of the server or of the agent).
•	Asynchrony of communication: the message is sent via a unidirectional channel, without response. The answer can come through a separate unidirectional channel.
7.4.8.	Semantics
All possible system behaviors are included in its graph of reachable markings. The graph for the system shown in Fig. 7.15a is presented in Fig. 7.15b. The form of transitions (dashed/dotted) is adopted from agent migration arcs in Fig. 7.15a. The terminal markings in the lower row denote deadlocks: no message matches any server’s state, but the message is still pending at the server S. The service of the server S is invoked but it will never be executed because the server cannot change its state. 
The graph is identical to the Labeled Transition System of IMDS system. The markings in Fig. 7.14b are just current states and pending messages. And they are just the configurations of the system. Likewise, the transitions in Fig. 7.15b correspond to the actions of IMDS. Therefore, the LTS of IMDS system is identical to the graph of reachable markings of the Petri net.
Thus, for designers who are accustomed to model their systems in Petri nets, and who find IMDS formalism to be exotic, the presented scheme should be attractive. The design in Petri net using the scheme presented in Fig. 7.1:
•	allows expressing locality, autonomy and asynchrony of distributed systems, 
•	preserves communication duality, emphasizing the specific features of the system, 
•	provides simple extraction of process from the model (server processes/agent pro-cesses),
•	allows finding deadlocks by identifying siphons or using model checking (after con-version to IMDS, which is obvious),
•	allows checking the system for inevitable termination, if it is desired (again in the IMDS form).

Behrmann G, David A, and Larsen K G. (2006). A Tutorial on Uppaal 4.0. Aalborg, Denmark. url: http://www.it.uu.se/research/group/darts/papers/texts/new-tutorial.pdf
Charlie. (n.d.). Charlie Petri net analyzer. url: http://www-dssz.informatik.tu-cottbus.de/DSSZ/Software/Charlie
Chu F, and Xie X-L. (1997). Deadlock analysis of Petri nets using siphons and mathematical programming. IEEE Transactions on Robotics and Automation, 13(6), 793–804. doi: 10.1109/70.650158
Daszczuk W B, and Zuberek W M. (2018). Deadlock Detection in Distributed Systems Using the IMDS Formalism and Petri Nets. In W. Zamojski, J. Mazurkiewicz, J. Sugier, T. Walkowiak, & J. Kacprzyk (Eds.), 12th International Conference on Dependability and Complex Systems, DepCoS-RELCOMEX 2017, Brunów, Poland, 2-6 July 2017. AISC vol 582 (pp. 118–130). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-59415-6_12
Heiner M, Schwarick M, and Wegener J-T. (2015). Charlie – An Extensible Petri Net Analysis Tool. In 36th International Conference, PETRI NETS 2015, Brussels, Belgium, 21-26 June 2015 (pp. 200–211). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-19488-2_10
Jensen K, and Kristensen L M. (2009). Coloured Petri Nets. Berlin, Heidelberg: Springer-Verlag. doi: 10.1007/b95112
Latvala T, Biere A, … Junttila T. (2004). Simple Bounded LTL Model Checking. In A. J. Hu & A. K. Martin (Eds.), International Conference on Formal Methods in Computer-Aided Design, Austin, TX, 15-17 Nov. 2004, LNCS 3312 (pp. 186–200). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-30494-4_14
López-Grao J-P, and Colom J-M. (2010). The Resource Allocation Problem in Software Applications: A Petri Net Perspective. In S. Donatelli (Ed.), RAPNeC-2010 Recent Advances in Petri Nets and Concurrency., Edition: Volume 827 of CEUR Workshop Proceedings (pp. 219–233). CEUR. url: http://ceur-ws.org/Vol-827/19_Juan-PabloLopez-Grao_article.pdf
Schmid H A, and Best E. (1978). A step towards a solution of the liveness problem in Petri nets. Newcastle upon Tyne. url: http://www.cs.ncl.ac.uk/publications/trs/papers/114.pdf
Schwarick M. (2013). Marcie - An analysis tool for Generalized Stochastic Petri nets. Cottbus. url: http://www-dssz.informatik.tu-cottbus.de/publications/papers/MARCIE_manual_oct_2013.pdf
van der Aalst W M P. (2000). Workflow Verification: Finding Control-Flow Errors Using Petri-Net-Based Techniques. In W. van der Aalst, J. Desel, & A. Oberweis (Eds.), Business Process Management, LNCS vol.1806 (pp. 161–183). Berlin Heidelberg: Springer. doi: 10.1007/3-540-45594-9_11
Wu N, and Zhou M. (2010). Process vs resource-oriented Petri net modeling of automated manufacturing systems. Asian Journal of Control, 12(3), 267–280. doi: 10.1002/asjc.184
Zuberek W M. (1999). Petri net models of process synchronization mechanisms. In SMC’99 IEEE International Conference on Systems, Man, and Cybernetics, Tokyo, Japan, 12-15 Oct. 1999 (Vol. 1, pp. 841–847). IEEE, Los Alamitos, CA. doi: 10.1109/ICSMC.1999.814201
Zuberek W M. (2009). Siphon-Based Verification of Component Compatibility. In Wojciech Zamojski (Ed.), 2009 Fourth International Conference on Dependability of Computer Systems, DepCos-RELCOMEX’09, Brunów, Poland, 30 June-2 July 2009 (pp. 123–132). Piscataway, NJ: IEEE. doi: 10.1109/DepCoS-RELCOMEX.2009.35

Distributed Autonomous and Asynchronous Automata (DA3)
In the practice of computer engineering, various forms of automata are used to express the behavior of concurrent components. There are two reasons: graphical representation and individual modeling of separate components. UML state diagrams are a good example [“UML,” n.d.]. 
For graphical representation of distributed systems, and for simulation in terms of parallel system components, distributed automata DA3 (D-triple A or DA-cubed) were invented. We claim that our distributed automata better describe parallelism and cooperation in real distributed environment (with full asynchrony) than those enumerated below.
Several different concepts are called in the literature “distributed automata”. 
	Automata on distributed alphabets, communicating on common letters, based on Zielonka’s automata [Zielonka, 1987]. The automata are called distributed automata in many papers concerning the behavior of concurrent systems, some of them additionally equipped with real time clocks for temporal analysis with real-time constraints: [Krishnan, 2000] [Chieu and Hung, 2010] [Muscholl, 2015] [Diekert and Muscholl, 2012] [Mohalik and Ramanujam, 2002]. These automata are called asynchronous in [Niebert, 1995] [Mukund, 2012] [Sandholm and Schwartzbach, 1997], although they perform actions (make transitions) asynchronously only if the input symbols are different. They perform synchronous moves on common input symbols (and it is the only common aspect of the automata). These automata should be called synchronous from our point of view. Alur’s Timed Automata [Alur and Dill, 1994] (sometimes called distributed [Krishnan, 2000]) are very close to Zielonka’s automata, they are simply equipped with time constraints and time invariants. CSP processes are similar, synchronizing on ! and ? operations (sending and receiving, respectively) rather than on symbols of input alphabet. The advantage of CSP is to determine the direction of communication, which should be supplied informally in the case of Zielonka’s automata.
Close to Zielonka’s automata are Büchi automata used for LTL model checking (for instance in Spin [Holzmann, 1997]). They differ in distinguishing some states as accepting. They are called distributed automata in [Brim et al., 2006].
Message Passing Automata (MPA, called distributed automata in [Bollig and Leucker, 2004] [Bollig and Leucker, 2005]) are really distributed and asynchronous. They contain ordered sets on symbols waiting for acceptance, called buffers or queues. 
Pushdown Distributed Automata (PDA) are equipped with local stacks of input symbols [Balan, 2009].
The two previous cases (MPA and PDA) are combined in [Enea et al., 2014] [Madhusudan and Parlato, 2011] and also called distributed automata.
The automata that are synchronous in fact, with a central synchronizing server. In such an automaton, two independent actions are performed "simultaneously" by independent processors. Synchronization between the processors is explicitly performed by a centralized processor: the synchronizer [Huguet and Petit, 1995] [Petit, 1993].
Grammar systems – languages for description of parallel systems, generated by automata with certain interleaving rules. They are called distributed automata in  [Krithivasan and Ramanujan, 2013] [Krithivasan et al., 1999] [Fernau et al., 2001] [Păun, 1995].
A single large automaton split into distributed parts called distributed automata [Gros-Desormeaux et al., 2008] [Caillaud et al., 1997].
We introduce a new version of automata, equivalent to IMDS formalism. We call them Distributed Autonomous, Asynchronous Automata - DA3 (D-triple A or DA-cubed) to distinguish them from all the listed formalisms, all called distributed automata. Our automata reflect the behavior of distributed components. The servers make decisions (execute actions) individually without any knowledge of other servers (autonomy) and messages are sent regardless of the states of target servers (asynchrony). As there are two views of the distributed system in IMDS, two forms of DA3 were developed: Server-DA3 and Agent-DA3 (S-DA3 and A-DA3).
Server automata S-DA3 
The IMDS system in the server view can be shown as a set of communicating automata S-DA3 (Distributed Server Automata), similar to MPA (third in the above enumeration):
Server states are nodes (we use node instead of state to avoid ambiguity) of corresponding automaton.
The initial server state is the initial node of the automaton.
Server process actions are transitions of the automaton.
The automaton is Mealy-style [Dick and Yao, 2014], labels of the transitions in the automaton are in a form extracted from the actions; an IMDS action (m,p)(m’,p’) is converted to the transition from p to p’ with the label m/m’. It is a triple (node, transition label, node): (p,m/m’,p’); m is the input symbol conditioning the transition while m’ is the output symbol produced on the transition; messages are m=(a,s,r), m’=(a,s’,r’)).
The automaton is equipped with an input set – a set of pending input symbols (messages), corresponding to a set of pending messages at the server. Firing the transition (p,m/m’,p’) in the server s automaton retrieves the symbol m from the input set of this automaton and inserts the symbol m’ to the input set of an automaton of the server s’ appointed by m’. The initial input set consists of the initial messages of agents directed to this server.
The special agent-terminating action (m,p)(p’) is converted to the transition (p,m/,p’) that does not produce an output symbol.
Formally, having the definition of S,A,V,R,P,Pini,M,Mini from IMDS (respectively: servers, agents, values, services, states, initial states, messages, initial messages), we have the set Ƨ (reﬂected S) of nS distributed sever automata Ƨ={ƨi, i=1..nS}, where nS is the number of servers in the set S. The ith distributed server automaton is 
ƨi = (si,Pi,p0i,Fi,Xi,X0i), where:	(8.1)
	siS – ith server,
	Pi={pi | pi=(si,v), vVi} – the set of nodes; Vi is the set of values of the server si states,
	p0i=(si,v0si)PiPini – the initial node (the initial state of the server si),
	Fi={(p1,m/m’,p2), p1, p2Pi, m=(a,si,ri)M, m’=(a,sj,rj)M, aA, ri, rjR or
(p1,m/,p2), p1, p2Pi, m=(a,si,ri)M, aA, riR } – the set of transitions (for an ordinary action and an agent-terminating action, respectively),
	Xi  2^{m=(a,si,ri)M, aA, riR} – the input set (^ is used to denote powerset); Xi is the variable having a set value: the sender of the message (the transition delivering the message) inserts the element, the transition execution removes the element,  according to the rules for TƧ below,
	X0i  2^{m=(a,si,ri)Mini, aA, riR} – the initial input set (restricted to messages pending initially at the server si),
	m1,m2Xi m1=(a1,si,r1), m2=(a2,si,r2), m1m2  a1a2 – the condition of IMDS that for any agent at most one message may exists in the configuration (achieved by construction).
In Ƨ,  ƨiƧ (p1,m/m’,p2)Fi m’=(a,sj,rj), aA, sjS, rjR, ƨjƧ (each output symbol is the input symbol of the automaton belonging to Ƨ).
The condition miXi,mjXj m1=(a1,si,r1), m2=(a2,sj,r2), r1,r2R, ji  a1a2 is obvious: for each agent at most one message can exists in the configuration (achieved by construction).
The semantics of Ƨ is defined as global node space ({TƧ}, TƧ0, nextTƧ), where {TƧ} is the set of global nodes, TƧ0 is the initial global node and nextTƧ is the transition relation, defined as follows:
	The global node of Ƨ is TƧ=((p1,X1),(p2,X2),...,(pn,Xn)) (current states and sets of pending messages of all servers).
	If in TƧ there exists a ƨi in which (pi1,Xi), (pi1,m/m’,pi2)Fi, mXi, m’=(a,sj,rj) (message m’ is directed to a server sj) then the possible next global node TƧ’ is:

T_Ƨ^'=((p_k,X_k^' )    ┤|   {█(X_k^'=X_k\{m}∪{m'}      for i=k=j@■(〖  X〗_k^'=X_k\{m}                   for k=i ≠ j@X_k^'=X_k∪{m'}                for k=j≠i)@X_k^'=X_k                             for i≠k≠j)┤       ,k=1…n)	(8.2)
	(the automaton ƨi changes its node to pi2, all other automata preserve their nodes; the message m is extracted from the input set Xi of the automaton ƨi, the next message m’ is inserted into the input set Xj of the automaton ƨj appointed by m’, all other input sets remain unchanged; the special case is for (i = k = j, ﬁrst case), where the server si sends a message to itself).
	If in TƧ there exists a ƨi in which (p1,Xi), (pi1,m/,pi2)Fi, mXi (message m terminates the agent appointed by m) then the possible next global node is:

T_Ƨ^'=((p_k,X_k^' )   ┤|  {█(X_k^'=X_k\{m}      for k=i@X_k^'=X_k                for k≠i)┤       , k=1…n)	(8.3)
(the automaton ƨi changes its node to pi2, all other automata preserve their nodes;  the message m is extracted from the input set Xi of the automaton ƨi, all other input sets remain unchanged).
	The initial global node is TƧ0 = ((p01,X01),(p02,X02),...,(p0n,X0n)).
	For a given global node TƧ, the transition relation nextTƧ(TƧ) is a set of pairs (TƧ,TƧ’). The transition relation nextTƧ=TƧ  nextTƧ(TƧ). If for TƧ there are many possible next global nodes, one of them is chosen in nondeterministic way. 
The global graph of Ƨ cooperation can be developed in such a way that the nodes are global nodes TƧ, and the edges are transitions in automata ƨi. Of course, this graph is analogous to the LTS of IMDS system. Global nodes contain current states of all servers, and pending messages of all not-terminated agents (but split to subsets pending at individual servers). The input symbol (message) of the transition belongs to the input set of one of servers in the source global node, while the output symbol (message) belongs the input set of one of servers in the target global node. A fragment of the global node space for the “strokes” system presented in Figs. 3.5 and 3.6 is presented in Fig. 8.1.
 It is simpler at the intuitive level, illustrated in Fig. 5.1 (for the “Two-semaphores” system – server view). Instead of individual server automata, the automata for server types are shown (with formal parameters of agents and servers used). Input sets of the automata Xproc[1], Xproc[2],Xsem[1], Xsem[2] and Xr are not shown in the picture, as they change during the operation of the automata. The agent formal parameters should be added for server types automata:
proc(A,sem[1..2]),
sem(A[1..2],proc[1..2]),
R(A3)
The S-DA3 automata, being the instances of the server type automata, are equipped with actual parameters:
proc[1]:proc(A[1],sem[1..2]),
proc[2]:proc(A[2],sem[2],sem[1]), 
sem[1]:sem(A[1..2],proc[1..2]), 
sem[2]:sem(A[1..2],proc[1..2]), 
r:r(A3). 
Each automaton is equipped with the input set of pending messages, for example for the sem[1] automaton:
Xsem[1]  2^{(A[1],sem[1],up),(A[1],sem[1],down),(A[2],sem[1],up),(A[2],sem[1],down)}

Note that the last condition in ƨi requires that the former two messages cannot be included in Xsem[1] at the same time, likewise the latter two messages.
The initial input sets are:
X0 sem[1]=, 
X0 sem[2]=, 
X0 proc[1]={(A[1],proc[1],start)}, 
X0 proc[2]={(A[1],proc[2],start)}, 
X0 r={(A3,r,res)}.
The S-DA3 are similar to Message Passing Automata. The difference lies in ordering messages on the automaton input: in MPA pending messages are ordered in the input queue (or input buffer) [Bollig and Leucker, 2004] [Bollig and Leucker, 2005], while in S-DA3 any message from the input set may cause a transition (no ordering). If input buffers are bounded, for example in implementation of distributed automata, a deadlock may occur due to all processes sending to full buffers. This is the case when the size of buffers is too small [Olson and Evans, 2005]. IMDS helps to overcome this problem by setting an exact limit on the maximum size of the input set (or input buffer): it is simply the number of agents.
Agent automata A-DA3 
The IMDS system in the agent view can be shown as a set of communicating automata A-DA3 (Agent Distributed Autonomous and Asynchronous Automata). We use the term node in these automata instead of state, because states are attributed to servers in IMDS and this may be misleading. The A-DA3 automata are similar to Timed Automata with variables, as in Uppaal [Behrmann, David, et al., 2006] (we do not use time dependencies of TA in the presentation of A DA3):
Agent messages are the nodes of the corresponding automaton.
The agent initial message of the is the initial node of the automaton.
Agent process actions are the transitions of the automaton.
The automaton is Mealy-style [Dick and Yao, 2014]; the labels of the transitions in the automaton have the form extracted from actions; the IMDS action (m,p)(m’,p’) is converted to a transition from m to m’ with the label p/p’. It is a triple (node, transition label, node): (m,p/p’,m’) (p is the input symbol conditioning the transition while p’ is the output symbol produced on the transition; server states are p=(s,v), p’=(s,v’)). 
In the case of the agent-terminating action (m,p)(p’), the special node tɐi in the automaton of ith agent is added as terminating node, and the transition is of the form (m,p/p’,tɐi). For tɐi no outgoing transition is defined.
The system is equipped with a global input vector (vector of global current input symbols), corresponding to the vector of current server states. Firing the transition (m,p/p’,m’) in the automaton replaces the symbol p with the symbol p’ in the vector. The initial global input vector consists of the initial states of all automata.
Formally, having the definition of S,A,V,R,P,Pini,M,Mini from IMDS (respectively: servers, agents, values, services, states, initial states, messages, initial messages), we have the set Ʉ (reﬂected A, rounded to distinguish it from a general quantiﬁer) of nA distributed agent automata Ʉ={ɐi, i=1..n}, where nA is the number of agents in the set A. The ith distributed agent automaton is:
ɐi = (ai,Mi,m0i,ti,Gi,Y,Y0), where:
ai – ith agent,
Mi={mi=(ai,sj,rj), sjS, rjRi  or mi=tɐi} – the set of nodes (messages, restricted to the agent ai), tɐi is a terminating node if the agent terminates (it appears on output of the terminating action),
m0i=(ai,sj,r0j)MiMini – the initial node (the initial message of the agent ai),
Gi={(m1,p/p’,m2) or (m1,p/p’,tɐi) | 
p=(s1,v1), p’=(s2,v2), m1,m2Mi, s1,s2S, v1Vs1, v2Vs2} – the set of transitions,
Y=[pj=(sj,vsj)], j=1..n, sjS, vsjVsj  – the global input vector (common for all ɐi in the system); Y is the vector of variables, every variable has the range over the set of values of the server sj: the action changes the value of the variable at the position of its server, accordingly to the rules for the global node TɄ below; Y[i] is the ith position of Y,
Y0=[p0j=(sj,v0sj)], j=1…n, sjSini, v0sjVsj – the initial global input vector, consisting of the initial states of all servers (common for all ɐi in the system). 
The semantics of Ʉ is defined as global node space ({TɄ}, TɄ0, nextTɄ), where {TɄ} is the set of global nodes, TɄ0 is the initial global node and nextTɄ is the transition relation, defined as follows:
	The global node of Ʉ is TɄ={m,m’,m’’,…, Y} (of course, m,m’TɄ  m=(a,s,r), m’=(a’,s’,r’), a  a’)
	If in TɄ there exists ɐi in which mi, (mi,p/p’,mj)Gi, mi=(ai,sx,r1),mj=(ai,sy,r2)M, sx,syS, r1,r2R, p=Y[i], p’=(sx,v), vV (message mi causes the change of state p to p’ in the server sx appointed by mi, and the message mj to the server sy is issued) then the possible next global node is:
 ■(T_Ʉ^' ∶∀_(mϵT_Ʉ )  {█(m=m_i∧m=m_j  〖 m〗_i∈T_Ʉ^'@m=m_i∧m≠m_j  〖 m〗_j∈T_Ʉ^'@m≠m_i  〖 m〗_i∈T_Ʉ^' )┤   ;@Y^'=[p_1,…,p_n ]  | p_k= {█( Y[k]    for k≠x@〖 p〗^'          for k=x)┤     , k=1…n )	(8.4)
(automaton ɐi changes its node to mj, all other automata preserve their nodes; state p in the input vector Y is replaced by p’ in the position of the server sx, appointed by p and p’, all other elements of the vector Y remain unchanged).
	If in TɄ there exists ɐi in which mi1, (mi,p/p’,tɐi)Gi, mi=(ai,sx,r)M, sxS, rR, p=Y[i], p’=(sx,v), vV (message mi is the last message in the run of the agent ai, then the agent terminates, sever sx appointed by the message mi changes its state from p to p’) then the possible next global node is:
■(T_Ʉ^' ∶∀_(mϵT_Ʉ )  {█(m=m_i  〖 m〗_i∉T_Ʉ^'@m≠m_i  〖 m〗_i∈T_Ʉ^' )┤   ;@Y^'=[p_1,…,p_n ]  | p_k= {█( Y[k]     for k≠x@p^'          for k=x)┤    ,  k=1…n ])	(8.5)
(the automaton ɐi changes its node to tɐi, all other automata preserve their nodes; the state p in Y is replaced by p’ as above).
	The initial global node TɄ0={m01, m02,…,m0n, Y0 }.
	For a given global node TƧ, the transition relation nextTɄ(TɄ) is a set of pairs (TɄ,TɄ’). The transition relation nextTɄ=TɄ  nextTɄ(TɄ). In a given global node TɄ, if there are multiple next nodes possible, one of them is chosen in nondeterministic way. 
Distributed agent automata are illustrated in Figs. 8.2 and 8.3 (for the two-semaphore system – agent view). Instead of individual agent automata, the automata for agent types are shown (with formal parameters of used servers). For the instance of an automaton type, formal parameters should be replaced by actual instances of servers. Initial agents messages are in bold ovals. The terminating node (tɐ) is surrounded by a dashed oval. Agent identifies are omitted in message labels (nodes of the automata), because they are identical for all messages in given agent type automaton. For completeness, the global input vector of current server states should be added: 
Y=[(sem[1],value{up,down}),
(sem[2],value{up,down}),
(proc[1],value{ini,first,sec,stop}),
(proc[2],value{ini,first,sec,stop}),
(r[1],value{res})]. 
The initial input vector is:
Y0=[(sem[1],up),(sem[2],up),(proc[1],ini),(proc[2],ini),(r,res)].
Note that A[1..2] automata terminate, therefore “terminating node” tA is used. There is no such node inA3, because this automaton is not expected to terminate.
The agent automata are instances of agent type automata with actual parameters: 
A[1]:A(proc[1],sem[1,2]), 
A[1]:A(proc[2],sem[2,1]), 
A3:A3(r).
A global graph of Ʉ cooperation can be developed analogously to the graph of Ƨ: the nodes of the global graph are global nodes TɄ, and the edges are transitions in the automata ɐi. This graph is analogous to the global graph of S-DA3 and to the LTS of IMDS system (global nodes contain messages of all agents, input symbol/state of a transition should be attributed to the source global node, while output symbol-state to the target global node). The fragment of the global node space for the “strokes” system presented in Figs. 3.5 and 3.6 is presented in Fig. 8.4.
 
Using DA3 in the Dedan program
The basic form used in the Dedan program is the IMDS. However, the specification in the form of the relation between pairs (state,message)(state’,message’) is exotic for users. Therefore, an alternative input form of DA3 automata is provided. For example, Fig. 8.5 shows the graphic form of the automaton type (proc automaton type of the “2 semaphores” system) in the design window. The user can move the state positions, add states and transitions, delete them etc. In the figure, the window of a new state definition is shown on the right.
The system can be simulated over the global configuration space (the LTS), but it is also possible to simulate it in terms of S-DA3, as illustrated in Fig. 8.6. All automata in the system are displayed, with input sets of pending messages shown under automata identifiers. The current states of the automata are blue. 
The user can select an automaton (proc[1] in the example, the selected automaton has a white background and blue name), and on the left a list of transitions from the current state of the selected automaton is displayed (with prepared ones highlighted; it is only one transition in this case, and it is prepared). Then, the user can choose the transition from the prepared ones. In the example, this is only one transition prepared, leading from ini to first (with acceptance of start message and issuance of the wait message to sem[1]). If the user clicks the prepared transition, it is “executed” and the destination automaton of the message becomes current (sem[1] in this case).
 
Fig. 8.6 	Simulation over S-DA3 automata. Every automaton has its own sub-window, a chosen automaton has blue caption and light background. On the left, current state of the chosen automaton and a list of possible transitions are displayed

9.	Fairness in distributed systems verification
Recall that in distributed systems three types of nondeterminism can be observed, modeled in IMDS:
•	Nondeterminism between servers: modeling of distribution. Servers make their deci-sions independently, therefore if two or more servers have prepared actions (their states and pending messages match), each of them can execute its action first. This is the modeling of nondeterminism in real world of independently operating servers.
•	Nondeterminism in server means that the current state of this server can match more than one pending message. The server should select the action to execute in nonde-terministic way. Processes running in a server are scheduled somehow, it depends on an operating system policy [Pnueli and Sa’ar, 2008] and run-time systems installed (like java [Laskowski et al., 2005] or .net [Zerzelidis and Wellings, 2005] envi-ronments). Full nondeterminism is most general approximation of many possible scheduling policies.
•	Nondeterminism in agent is a situation in which two or more actions of the agent are possible in the current state of the server appointed by the current message of the agent. This models the nondeterministic choice in computation. Loops are often modeled in such a way: if the loop ending condition is not modeled, the decision to continue the loop or to escape from the loop is taken in nondeterministic way. Nonde-terminism in a single agent seldom model actual nondeterministic choices in a pro-gram. Usually, nondeterminism models abstraction from detailed decision making. However, there may be real nondeterministic choices, for example modes of opera-tion (as in the bounded buffer system in Fig.7.8), of activities selected by human us-ers.
In all three cases, the nondeterministic choice should be fair, which means that if the same non-deterministic choice is to be decided infinite number of times, every option should be selected at least once. The verifier of the system should be fair in any one of the three types of nondeter-ministic choices: between servers, in server and in agent.
In model checking, several notions of fairness are introduced, mainly to model independence of parallel processes and fair scheduling in operating systems. The basic notions are justice (weak fairness) and compassion (strong fairness) [Kesten et al., 1998] [Pnueli and Sa’ar, 2008] [Baier and Katoen, 2008] [Rozier, 2011]. A just scheduler executes the process infinitely often, while a compassionate scheduler ensures that a process which is enabled infinitely often is executed infinitely often.
Justice and compassion can be attributes of the entire verified system. Alternatively, to avoid computations in which a given transition is forever ignored, transitions can be marked as just or compassionate [Gómez and Bowman, 2005]. Compassion applied to a given pair of events p, q can be formulated as a temporal formula, which says that whenever event p occurs, subsequent event q must occur in the future:
 
•	LTL:  (p⇒ q)	(9.1)
•	CTL: AG (p ⇒ AF q) 
9.1.	The benchmark – bounded buffer
The Dedan program was designed for specification and verification of distributed systems. Tem-poral verification for deadlock detection was planned using external model checkers: Spin [Holzmann, 1997] for LTL (linear time logic [Clarke et al., 1999]), NuSMV [Cimatti et al., 2000] for CTL (computation tree logic [Clarke et al., 1999]) and Uppaal [Behrmann et al., 2006] for TCTL (CTL and timed CTL, TCTL). The choice of the verifiers was based on the two aspects: they are popular and free (at least for academic use). Dedan converts the IMDS specification to input formats of the three programs: Promela, SMV and Timed Automata XML. The counterexamples generated in the case of a deadlock found are read to the Dedan program and presented in a readable form similar to sequence diagrams. 
In the IMDS, several tests were developed to check the operation of the Dedan program, includ-ing the presented two-semaphore model, intersection, several versions of bounded buffer, dining philosophers, etc. In most examples everything worked, but one example caused false positive in deadlock detection. It was a version of bounded buffer.
The basic example of a bounded buffer system consists of K-element buffer and two sets of us-ers: producers and consumers. The correct specification does not lead to deadlocks. Among several versions of bounded buffer, in one of them users were modified to play roles of both pro-ducers and consumers. Such a system is illustrated as a Petri net in Fig. 7.8. The action of pro-duction/consumption is selected in nondeterministic way (lines 14 and 15 in the source code below). In such a system, a deadlock may occur if all users decide to read from an empty buffer, or if all users decide to write to a full buffer. There is no user to put an element into a buffer in the former case, and to get an element and make a room in a buffer in the latter case. 
To avoid such situations, the concept of butlers from Dijkstra’s solution of dining philosophers problem [Scholten and Dijkstra, 1982] was used (line 25). But there is a difference: in the Dijks-tra’s solution the butlers prevent inactively all the philosophers from taking their left forks and from taking their right forks (the last philosopher simply waits). In our solution, the butlers cannot hold the users because the latter should make the other decision: to produce instead of consum-ing or reverse (l.16,17).
Such a system should not fall into a deadlock if it is compassionate: after many attempts to se-lect putting and being rejected (l.14,16), the user must at last choose to get (l.15) (and vice-versa). Unfortunately, all three external verifiers failed to give correct result – they report a dead-lock in the sense of the IMDS deadlock definition in the server view. This means that the verifiers report some states in the system in which messages are pending at the servers but they will never be served. In the following sections we show this vulnerability in all the three external veri-fiers.
The model in the IMDS notation is given below. For the compactness, identifiers are shortened: servers Sprodcons to S, get_butler to get_b, put_butler to put_b, agent Aprodcons to A. For readability, the vector elem is indexed from 0 (in fact, in Dedan indexing starts with 1 and additional state elem_0 should be added).
 1. #DEFINE N 3
 2. #DEFINE K 3

 3. server:	buf (agents A[N]; servers S[N]),  
 4. services	{put, get},
 5. states	{elem[0..K]},								
 6. actions	{
 7. <i=1..N>	<j=0..K-1>	{A[i].buf.put, buf.elem[j]}	-> 
{A[i].S[i].ok_put, buf.elem[j+1]},	
 8. <i=1..N>	<j=1..K>	{A[i].buf.get, buf.elem[j]}	-> 
{A[i].S[i].ok_get, buf.elem[j-1]},	
 9. };

10. server:	S (agents A;
servers buf,put_b:butler,get_b:butler),
11. services	{doSth,may_do,cannot_do,ok_put,ok_get,go_neutral},
12. states	{neutral,prod,cons},
13. actions	{	
14.	{A.S.doSth, S.neutral} 	-> {A.put_b.wants_do, S.prod}		
15.	{A.S.doSth, S.neutral}	-> {A.get_b.wants_do, S.cons}
16.	{A.S.cannot_do, S.prod}	-> {A.S.doSth, S.neutral}
17.	{A.S.cannot_do, S.cons}	-> {A.S.doSth, S.neutral}
18.	{A.S.may_do, S.prod}		-> {A.buf.put, S.prod}
19.	{A.S.may_do, S.cons}		-> {A.buf.get, S.cons}
20.	{A.S.ok_put, S.prod}		-> {A.put_b.done, S.prod}
21.	{A.S.ok_get, S.cons}		-> {A.get_b.done, S.cons}
22.	{A.S.go_neutral, S.prod}	-> {A.S.doSth, S.neutral}
23.	{A.S.go_neutral, S.cons}	-> {A.S.doSth, S.neutral}
24. };

25. server:	butler (agents A[N]; servers S[N]),
26. services	{wants_do,done}
27. states	{
28. <i=1..N>	<j=0..N-2>	{A[i].butler.wants_do, butler.want[j]} -> 
{A[i].S[i].may_do, butler.want[j+1]}
29. <i=1..N>		{A[i].butler.wants_do, butler.want[N-1]} -> 
{A[i].S[i].cannot_do, butler.want[N-1]}
30. <i=1..N>	<j=1..N-1>	{A[i].butler.done, butler.want[j]} -> 
{A[i].S[i].go_neutral, butler.want[j-1]}
31. };
32. servers 	buf,S[N],get_b:butler,put_b:butler;
33. agents	A[N];	
 
34. init	->	{ 
35. <j=1..N>	S[j](A[j],buf,put_b,get_b).neutral,
36.	buf(A[1..N],S[1..N]).elem[0],
37.		get_b(A[1..N],S[1..N]).want[0],
38.		put_b(A[1..N],S[1..N]).want[0],

39. <j=1..N>	A[j].S[j].doSth,	
40. }.	

For illustration of the model, S-DA3 automata are presented in Fig. 9.1. The names of the au-tomata implementing server types are inside rounded boxes. Initial states of the automata are surrounded by bold ellipses. Some transitions are with repeaters of the form <i=1..N>. Multiple transitions (but not those with repeaters) have double arrows and double labels. Transitions im-plement the IMDS actions in such a way that input and output states of the transition are autom-aton nodes, the input message is the input symbol enabling the transition while the output mes-sage (if present) is the output symbol of the transition (automata are Mealy-style [Dick and Yao, 2014]). Output messages are directed to the given servers, but they may not be accepted imme-diately – the messages can be pending in IMDS (due to interleaving, if some other server exe-cutes an action or simply the message does not match the current server state). 
All are three types of nondeterminism in IMDS take place in the described model:
•	Nondeterminism between servers takes place in any system consisting of more than one server, and we have many servers. 
•	Nondeterminism in server occurs, for example in the butler: it can have more than one request (wants_do message) and should grant the access to the buffer fairly. 
•	Nondeterminism in agent is modeled in the decision of each agent working on its own server: to produce or to consume. 
For the purpose of model checking with external verifiers, the temporal formulas are slightly modified. In original version, Es and Ea atomic formulas were specified as “an action is prepared (a state and a message match)”. It is enough for the internal model checker, as it is designed for supporting fairness and the action which is prepared many times, must be fired. To be inde-pendent in the way of evaluating temporal formulas, Es means “action is executed in server s” instead of “at least one action is prepared in the server s”. Likewise, Ea means “action is execut-ed with the agent’s a message on input” instead of “action is prepared with the agent’s a mes-sage”.
For temporal verification of the example system, strong fairness (compassion) is needed. If the agent periodically tries to perform get, and it is consequently rejected, it should finally switch to put (because both get and put are possible from the neutral state of its home server). 
9.2.	LTL model checking in Spin
For verification in linear temporal logic (LTL), the commonly used model checker Spin [Holzmann, 1997] was used. Deadlock detection formulas are:
•	communication deadlock in server s:  (Ds   Es); the formula reads: “eventually always there will be messages pending at the server s, but no action will be executed from this time on”,
•	resource deadlock in agent a:  (Da   Ea); “eventually always the pending mes-sage of the agent a will not cause any action to be executed”,
•	termination of agent a:  (Fa); “eventually the agent a terminates”.
The model is converted from the IMDS notation to Promela [Holzmann, 1995], the input form of Spin. Below is a fragment of the Promela code for the server buf (the version of capacity 2, line 10). In the do statement (l.16) all actions of the server buf are implemented. Pending mes-sages are stored in variables buf_Aprodcons_1_service and   Fig. 9.2 Sequence diagram of the false deadlock identified by Spin in bounded buffer model
 
buf_Aprodcons_2_service (l.17,18). Execution of the action is signaled by setting the vari-able buf_action to true, then to false (for example in line 19). The definitions of servers butler and S are similar. After the definition of buf, the LTL formula for deadlock detection in the buf server is given (l.29).
 
 1. //enumeration type of states and services of all servers:
 2. mtype {none, put, get, elem_0, elem_1, elem_2, doSth, may_do, cannot_do, ok_put, ok_get, go_neutral, neutral, prod, cons, wants_do, done, want_0, want_1};
 3. //buf_services = {put,get}; 
 4. //buf_states = {elem_0,elem_1,elem_2}; 

 5. mtype buf_Aprodcons_1_service,buf_Aprodcons_2_service;
 6. bool buf_action;
 7. mtype buf_state;
 8. #define buf_c_Aprodcons_1 (buf_Aprodcons_1_service!=none && buf_Aprodcons_1_service!=0)
 9. #define buf_c_Aprodcons_2 (buf_Aprodcons_2_service!=none && buf_Aprodcons_2_service!=0)

10. proctype buf(byte num; byte inistate; chan Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1, Aprodcons_2)
11. {	mtype mes;
12.	buf_state=inistate;
13.	buf_Aprodcons_1_service=none;
14.	buf_Aprodcons_2_service=none;
15.	buf_action=0;
16.	do
17.	:: Aprodcons_1?mes -> buf_Aprodcons_1_service=mes;
18.	:: Aprodcons_2?mes -> buf_Aprodcons_2_service=mes;
19.	:: (buf_Aprodcons_1_service==put) && (buf_state==elem_0) -> buf_action=1; buf_state=elem_1; buf_Aprodcons_1_service=none; buf_action=0; Aprodcons_1_Sprodcons_1!ok_put
20.	:: (buf_Aprodcons_1_service==put) && (buf_state==elem_1) -> buf_action=1; buf_state=elem_2; buf_Aprodcons_1_service=none; buf_action=0; Aprodcons_1_Sprodcons_1!ok_put
21.	:: (buf_Aprodcons_1_service==get) && (buf_state==elem_2) -> buf_action=1; buf_state=elem_1; buf_Aprodcons_1_service=none; buf_action=0; Aprodcons_1_Sprodcons_1!ok_get
22.	:: (buf_Aprodcons_1_service==get) && (buf_state==elem_1) -> buf_action=1; buf_state=elem_0; buf_Aprodcons_1_service=none; buf_action=0; Aprodcons_1_Sprodcons_1!ok_get
23.	:: (buf_Aprodcons_2_service==put) && (buf_state==elem_0) -> buf_action=1; buf_state=elem_1; buf_Aprodcons_2_service=none; buf_action=0; Aprodcons_2_Sprodcons_2!ok_put
24.	:: (buf_Aprodcons_2_service==put) && (buf_state==elem_1) -> buf_action=1; buf_state=elem_2; buf_Aprodcons_2_service=none; buf_action=0; Aprodcons_2_Sprodcons_2!ok_put
25.	:: (buf_Aprodcons_2_service==get) && (buf_state==elem_2) -> buf_action=1; buf_state=elem_1; buf_Aprodcons_2_service=none; buf_action=0; Aprodcons_2_Sprodcons_2!ok_get
26.	:: (buf_Aprodcons_2_service==get) && (buf_state==elem_1) -> buf_action=1; buf_state=elem_0; buf_Aprodcons_2_service=none; buf_action=0; Aprodcons_2_Sprodcons_2!ok_get
27.	od
28. }

29. ltl buf_dd {!(<>[]((buf_c_Aprodcons_1 || buf_c_Aprodcons_2) && buf_action==0))}

At the end of the code, server variables are declared and initialized (line 7 in the code below for the server buf). For each pair (agent, target server of its messages) the communication channel of capacity 1 is declared (channel A_1_buf for messages sent by the agent A_1 to the server buf, line 2). These channels are actual parameters of server variables (Promela processes – lines 10-14). The initial states are also sent as parameters to the server processes, and the initial agent messages are placed in the appropriate channels in lines 15 and 16 (all other channels are initially empty).
 1. init	{
 2.	chan Aprodcons_1_buf = [1] of {mtype};
 3.	chan Aprodcons_2_buf = [1] of {mtype};
 4.	chan Aprodcons_1_Sprodcons_1 = [1] of {mtype};
 5.	chan Aprodcons_2_Sprodcons_2 = [1] of {mtype};
 6.	chan Aprodcons_1_get_butler = [1] of {mtype};
 7.	chan Aprodcons_2_get_butler = [1] of {mtype};
 8.	chan Aprodcons_1_put_butler = [1] of {mtype};
 9.	chan Aprodcons_2_put_butler = [1] of {mtype};

10. run buf(1, elem_0, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1_buf, Aprodcons_2_buf);
11. run Sprodcons(1, neutral,Aprodcons_1_put_butler, Aprodcons_1_get_butler, Aprodcons_1_buf, Aprodcons_1_Sprodcons_1);
12. run Sprodcons(2, neutral, Aprodcons_2_put_butler, Aprodcons_2_get_butler, Aprodcons_2_buf, Aprodcons_2_Sprodcons_2);
13. run butler(1, want_0, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1_get_butler, Aprodcons_2_get_butler);
14. run butler(2, want_0, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1_put_butler, Aprodcons_2_put_butler);
15. Aprodcons_1_Sprodcons_1!doSth;
16. Aprodcons_2_Sprodcons_2!doSth;
17. }

Spin gives the answer true to the question about deadlock. Spin has two versions of dealing with fairness: there are no fairness and weak fairness (they affect the time of veriﬁcation). In both versions a deadlock is reported. Its graphical representation in Dedan sequence diagram is pre-sented in Fig. 9.2. The false positive is identified when one user sent put (the putting action is not completed yet) and the other endlessly asks the put_butler to grant for putting. The butler endlessly responds cannot_do, and the user never switches to getting. Two kinds of fairness are broken: between servers (if the putting action is finished, it would allow the other user to put) and in agent (infinitely choosing production, never switching to consumption).
9.3.	CTL and LTL model checking in NuSMV
The same system was modeled in the language of SMV, the input form of the NuSMV verifier [Cimatti et al., 2000],  for CTL verification. The CTL versions of deadlock and termination detec-tion formulas are as follows:
•	communication deadlock in the server s: EF AG (Ds   Es)
•	resource deadlock in the agent a: EF AG (Da   Ea)	
•	termination of the agent a: AF (Fa)	
The meaning of the formulas is similar to LTL. 
Modeling in SMV is based on changing value of the variables. On the example of the buf server in the two-user, two-element version of the system in SMV:
•	the variable state:{elem_0,elem_1,elem_2} (line 7) storing the server state (in-itialized to the initial value inistate), 
•	for each agent – the pending message: the variables A_1_service:{none,put,get} and A_2_service (lines 3,4), 
•	the variable phase:{rec,A_1_send,A_2_send,change} (line 8) deﬁnes the ac-tion execution phase (receiving messages and selecting the agent to perform the ac-tion – rec, selecting the action between prepared actions of the selected agent – A_1_send,A_2_send, sending the output message and changing the server state – change), 
•	for every agent – the message to be sent (A_1_to_S_1_mes, A_2_to_S_2_mes – lines 5 and 6).
The next lines contain actions that change the values of the variables according to current val-ues.
 1. MODULE buf (inistate,A_1_mes,A_2_mes)

 2. VAR
 3.	A_1_service: {none,put,get};
 4.	A_2_service: {none,put,get};
 5.	A_1_to_Sprodcons_1_mes: {none,doSth,ok_put,ok_get};
 6.	A_2_to_Sprodcons_2_mes: {none,doSth,ok_put,ok_get};
 7.	state: {elem_0,elem_1,elem_2};
 8.	phase: {rec,A_1_send,A_2_send,change};

 9. ASSIGN
10.	init(A_1_service):=none;
11.	next(A_1_service):=case
12.		phase=rec & A_1_mes=put: {none,put};
13.		phase=rec & A_1_mes=get: {none,get};
14.		phase=change & A_1_to_Sprodcons_1_mes!=none: none;
15.		TRUE: A_1_service;
16.	esac;	
17.	init(A_2_service):=none;
18.	next(A_2_service):=case
19.		phase=rec & A_2_mes=put: {none,put};
20.		phase=rec & A_2_mes=get: {none,get};
21.		phase=change & A_2_to_Sprodcons_2_mes!=none: none;
22.		TRUE: A_2_service;
23.	esac;	
24.	init(phase):=rec;
25.	next(phase):=case
26.		phase=rec & A_1_service=put & state=elem_0: A_1_send;
27.		phase=rec & A_1_service=put & state=elem_1: A_1_send;
28.		phase=rec & A_1_service=get & state=elem_2: A_1_send;
29.		phase=rec & A_1_service=get & state=elem_1: A_1_send;
30.		phase=rec & A_2_service=put & state=elem_0: A_2_send;
31.		phase=rec & A_2_service=put & state=elem_1: A_2_send;
32.		phase=rec & A_2_service=get & state=elem_2: A_2_send;
33.		phase=rec & A_2_service=get & state=elem_1: A_2_send;
34.		phase=rec & A_1_service=none & A_2_service=none: rec;
35.		phase=A_1_send & A_1_to_Sprodcons_1_mes!=none: change;
36.		phase=A_2_send & A_2_to_Sprodcons_2_mes!=none: change;
37.		phase=change: rec;
38.		TRUE: phase;
39.	esac;
40.	init(A_1_to_Sprodcons_1_mes):=none;
41.	next(A_1_to_Sprodcons_1_mes):=case
42.		phase=A_1_send & A_1_service=put & state=elem_0: ok_put;
43.		phase=A_1_send & A_1_service=put & state=elem_1: ok_put;
44.		phase=A_1_send & A_1_service=get & state=elem_2: ok_get;
45.		phase=A_1_send & A_1_service=get & state=elem_1: ok_get;
46.		TRUE: none;
47.	esac;
48.	init(A_2_to_Sprodcons_2_mes):=none;
49.	next(A_2_to_Sprodcons_2_mes):=case
50.		phase=A_2_send & A_2_service=put & state=elem_0: ok_put;
51.		phase=A_2_send & A_2_service=put & state=elem_1: ok_put;
52.		phase=A_2_send & A_2_service=get & state=elem_2: ok_get;
53.		phase=A_2_send & A_2_service=get & state=elem_1: ok_get;
54.		TRUE: none;
55.	esac;
56.	init(state):=inistate;
57.	next(state):=case
58.		phase=change & A_1_service=put & state=elem_0: elem_1;
59.		phase=change & A_1_service=put & state=elem_1: elem_2;
60.		phase=change & A_1_service=get & state=elem_2: elem_1;
61.		phase=change & A_1_service=get & state=elem_1: elem_0;
62.		phase=change & A_2_service=put & state=elem_0: elem_1;
63.		phase=change & A_2_service=put & state=elem_1: elem_2;
64.		phase=change & A_2_service=get & state=elem_2: elem_1;
65.		phase=change & A_2_service=get & state=elem_1: elem_0;
66.		TRUE: state;
67.	esac;

The formal parameters of the server (line 1) are: initial state and channels of two agents sending messages to buf. 
Communication channels are not included in SMV language and should be modeled, for example the buf input channel is the following (the variable state is the message directed to the server buf, input is used to send a message, output is for receiving and cleaning the channel):
 1. MODULE chan_buf (inimes,input,output)
 2. VAR
 3.	state: {none,put,get};
 4. ASSIGN
 5.	init(state):=inimes;
 6.	next(state) := case
 7.		input!=none & state=none: input;
 8.		output!=none & state!=none: none;
 9.		TRUE: state;
10.	esac;

Declaration of variables and their initialization are in the main module, channels ﬁrst (the former two with initial messages - lines 3,4), and then servers (lines 7-9):
 1. MODULE main
 2. VAR
 3.	A_1_proc_1 : chan_proc(doSth, proc_1.A_to_proc_mes, buf.A_1_to_Sprodcons_1_mes, proc_1.A_service);
 4.	A_2_proc_2 : chan_proc(doSth, proc_2.A_to_proc_mes, buf.A_2_to_Sprodcons_2_mes, proc_2.A_service);

 5.	A_1_buf : chan_buf(none, proc_1.A_to_buf_mes, buf.A_1_service);
 6.	A_2_buf : chan_buf(none, proc_2.A_to_buf_mes, buf.A_2_service);
	
 7.	proc_1 : proc(neutral, A_1_proc_1.state);
 8.	proc_2 : proc(neutral, A_2_proc_2.state);
 9.	buf : buf(elem_0, A_1_buf.state, A_2_buf.state);

The example of the NuSMV CTL formula for deadlock detection – equivalent to EF AG(Ds ∧ ¬Es) – is for the example of server buf (if the message is received from A_1 or A_2, it will be proceeded when the server leaves the rec phase):
NAME buf_dd := AG ((buf.A_1_service!=none | buf.A_2_service!=none) 
-> AF buf.phase!=rec)

Fairness between servers is natural, but fairness in server and in agent should be modeled ex-plicitly by COMPASSION commands. This command specifies which options should be selected at least once if enabled infinitely frequently. The example shows the statements for nondetermin-ism in sever, when the message put from A_1 is pending in rec phase inﬁnitely often, and then it must eventually cause the next message to be sent in the context of A_1 (the phase changes to A_1_send):
COMPASSION
	(phase=rec & A_1_mes=put & state=elem_0, phase = A_1_send)
COMPASSION
	(phase=rec & A_2_mes=put & state=elem_0, phase = A_2_send)

This looks appealing, but after invocation of NuSMV, the message says that COMPASSION statements do not guarantee to be held in CTL verification. Indeed, the result is similar to that of Spin:
WARNING *** The model contains COMPASSION declarations.        ***
WARNING *** Full fairness is not yet fully supported in NuSMV. ***
WARNING *** Currently, COMPASSION declarations are only        ***
WARNING *** supported for BDD-based LTL Model Checking.        ***
WARNING *** Results of CTL Model Checking and of Bounded       ***
WARNING *** Model Checking may be wrong.                       ***

Following the advice above, we tried to verify in LTL, which is also possible in NuSMV. The ex-ample LTL formula is:
LTLSPEC	NAME A_1_dd := G ((buf.A_1_service!=none | proc_1.A_service!=none) -> F (buf.A_1_service=none & proc_1.A_service=none))

The result is even worse, because in LTL the verification seems to last infinitely and we inter-rupted it. The probable reason is that compassion requirements are usually included in the for-mulas, on the basis of: (1  2  …)   ([Katoen, 1999], Section 3.9), where 1, 2, … are compassion requirements supplied by the designer in COMPASSION statements, and  is the target formula specified in LTLSPEC statement. There are 21 COMPASSION statements in the specification, which results in very long, unacceptable verification time.
9.4.	CTL model checking in Uppaal
The last external model checker used was Uppaal [Behrmann et al., 2006]. The verifier is de-signed to check CTL formulas with real-time constraints (TCTL). In this analysis, we do not use time constraints, therefore the model and verification concern “ordinary” CTL (without time con-straints).
The code for buf server in the input form of Uppaal (XML Timed Automata) is presented below. The model is in the form of an automaton, with Uppaal locations being the buf states, and Up-paal transitions being the actions. For each server, the enumeration type of its services is deﬁned (for example type buf_service for the server buf – line 6 and next lines with individual variables). The channels between the servers are implemented as simple variables of the respective types, holding a single message or being empty – the value none (line 2). The au-tomaton is given the channels for message exchange with other servers as the parameters (separate for each agent - l.14). The additional parameter myNum (l.14) is the number of the au-tomaton instance within the automaton template (server type). Server states are implemented as locations (l.17-19). Every action has the form a transition, connecting the locations with the guard label being a message pending at the channel output to the target server (l.24). The channels are implemented as simple variables holding single message. Execution of the transi-tion causes the “consumption” of the input message (l.26) and issuing the output message (l.27). 
 1. <declaration> 
 2. const int none=0; 
 
 3. typedef int[0,2] buf_service; 
 4. const int buf_put=1;
 5. const int buf_get=2;
 
 6. typedef int[0,6] S_service;
 7. const int S_doSth=1;
 8. //next services of S are declared here: S_may_do=2, S_cannot_do=3, ... 
 9. //then type butler_service with two services 
10. </declaration> 

11. <template>
12. <name>buf</name>
13. <parameter>
14.		int myNum, Sprodcons_service &buf_Aprodcons_1_Sprodcons_1, Sprodcons_service &buf_Aprodcons_2_Sprodcons_2, buf_service &Aprodcons_1_buf, buf_service &Aprodcons_2_buf
15. </parameter>
16. <declaration />
17. <location id="id0"> <name>elem_0</name> </location>
18. <location id="id1"> <name>elem_1</name> </location>
19. <location id="id2"> <name>elem_2</name> </location>
20. <init ref="id0" />
21. <transition>
22.   <source ref="id0" />
23.   <target ref="id1" />
24.   <label kind="guard">Aprodcons_1_buf == buf_put</label>
25.   <label kind="assignment">
26.			Aprodcons_1_buf = none, 
27.			buf_Aprodcons_1_Sprodcons_1 = Sprodcons_ok_put
28.    </label>
29. </transition>
30. <transition>
31.   <source ref="id1" />
32.   <target ref="id2" />
33.   <label kind="guard">Aprodcons_1_buf == buf_put</label>
34.   <label kind="assignment">
35.			Aprodcons_1_buf = none,
36.			buf_Aprodcons_1_Sprodcons_1 = Sprodcons_ok_put
37.   </label>
38. </transition>
39. <transition>
40.   <source ref="id2" />
41.   <target ref="id1" />
42.   <label kind="guard">Aprodcons_1_buf == buf_get</label>
43.   <label kind="assignment">
44.			Aprodcons_1_buf = none,
45.			buf_Aprodcons_1_Sprodcons_1 = Sprodcons_ok_get
46.   </label>
47. </transition>
48. <transition>
49.   <source ref="id1" />
50.   <target ref="id0" />
51.   <label kind="guard">Aprodcons_1_buf == buf_get</label>
52.   <label kind="assignment">
53.			Aprodcons_1_buf = none,
54.			buf_Aprodcons_1_Sprodcons_1 = Sprodcons_ok_get
55.   </label>
56. </transition>
57. <transition>
58.   <source ref="id0" />
59.   <target ref="id1" />
60.   <label kind="guard">Aprodcons_2_buf == buf_put</label>
61.   <label kind="assignment">
62.			Aprodcons_2_buf = none,
63.			buf_Aprodcons_2_Sprodcons_2 = Sprodcons_ok_put
64.   </label>
65. </transition>
66. <transition>
67.   <source ref="id1" />
68.   <target ref="id2" />
69.   <label kind="guard">Aprodcons_2_buf == buf_put</label>
70.   <label kind="assignment">
71.			Aprodcons_2_buf = none,
72.			buf_Aprodcons_2_Sprodcons_2 = Sprodcons_ok_put
73.   </label>
74. </transition>
75. <transition>
76.   <source ref="id2" />
77.   <target ref="id1" />
78.   <label kind="guard">Aprodcons_2_buf == buf_get</label>
79.   <label kind="assignment">
80.			Aprodcons_2_buf = none,
81.			buf_Aprodcons_2_Sprodcons_2 = Sprodcons_ok_get
82.   </label>
83. </transition>
84. <transition>
85.   <source ref="id1" />
86.   <target ref="id0" />
87.   <label kind="guard">Aprodcons_2_buf == buf_get</label>
88.   <label kind="assignment">
89.			Aprodcons_2_buf = none,
90.			buf_Aprodcons_2_Sprodcons_2 = Sprodcons_ok_get
91.   </label>
92. </transition>
93. </template>

The declaration of the channels with initial messages (lines 1-3) and automata instances (lines 5-9) follows. Finally, the system is declared as a set of automata implementing the servers (line 10):
 1. buf_service Aprodcons_1_buf = none;
 2. buf_service Aprodcons_2_buf = none;
 3. S_service Aprodcons_1_Sprodcons_1 = S_doSth;
 4 //next channels...

 5. buf_ = buf(1, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, 
Aprodcons_1_buf, Aprodcons_2_buf);
 6. Sprodcons_1 = S(1, Aprodcons_1_put_butler, Aprodcons_1_get_butler, Aprodcons_1_buf, Aprodcons_1_Sprodcons_1);
 7. Sprodcons_2 = S(2, Aprodcons_2_put_butler, Aprodcons_2_get_butler, Aprodcons_2_buf, Aprodcons_2_Sprodcons_2); 
 8. get_butler = butler(1, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1_get_butler, Aprodcons_2_get_butler); 
 9. put_butler = butler(2, Aprodcons_1_Sprodcons_1, Aprodcons_2_Sprodcons_2, Aprodcons_1_put_butler, Aprodcons_2_put_butler); 

10. system buf_, Sprodcons_1, Sprodcons_2, get_butler, put_butler; 


The temporal formula in Uppaal version is (the operator --> stands for AG(p  AF q) ):
Aprodcons_1_buf != none --> Aprodcons_1_buf == none

 
Fig. 9.3 Trace of the false deadlock identified by Uppaal in bounded buffer model 

The Uppaal documentation and literature do not refer to fairness in verification. Indeed, in verifi-cation Uppaal reports a deadlock and gives the counterexample similar to Spin (Fig. 9.3). The loop in which Aprodcons_1 repeatedly tries to get (Sprodcons_1 switches to cons) while Aprodcons_2 performs get and does not move, is highlighted by red locations on red arrows. Surprisingly, the simulation of the model under Uppaal shows normal operation, in which the variable A_1_buf changes to put or get and back to none.
9.5.	Fair verification algorithm
The experience with commonly used verifiers: Spin, NuSMV and Uppaal shows that the verifica-tion of models with non-busy form of waiting gives proper results. However, problems with fair-ness in the case of busy form of waiting should be defeated. There are algorithms for LTL and CTL model checking with strong fairness [Kesten et al., 1998] [Pnueli and Sa’ar, 2008] [Rozier, 2011]. Model checking with strong fairness requires the explicit specification of the events, which should be treated as compassionate. In the monograph, we present our own algorithm for CTL model checking, which supports compassion without specifying compassion points. In Dedan only a limited set of temporal formulas is needed for deadlock and termination detection, they are listed in Chapter 4. The algorithm is based on the “Checking by Spheres” algorithm (CBS [Daszczuk, 2003] [Daszczuk, 2001]), with some improvements. The most important is using re-verse reachability for discovering the shape of the reachability space. The basic CBS algorithm is a breadth-first search, constructing consecutive spheres of nodes of the reachability space, distant from the initial node for 1, 2, …, etc. transitions. The two finishing conditions are defined:
•	Construction of an empty sphere (all nodes visited).
•	A node with a given condition fulfilled in a non-empty sphere.
In [Daszczuk, 2003], a temporal verifier TempoRG for the entire CTL is described, with some extensions for state quantification and component-aware operators. In order to verify in Dedan, the CBS algorithm was reduced to the two formulas necessary for the IMDS deadlock and ter-mination detection: EF AG  and AF . First, a decision is made if the reachability space is pure-ly cyclic, or alternatively if there are nodes outside the cyclic part. In cyclic space, the fairness causes all execution paths to visit each node in the space infinitely often. In the other case, fair-ness causes each path to settle down in a strongly connected subgraph without escaping from it (we call it ending strongly connected subgraph – or ending subgraph in short, it is a generalization of the lasso-shaped ending subpath in [Rozier, 2011]). 
The verification of EF AG  is based on reverse reachability, similar to [Hung and Chen, 2006], illustrated in Fig. 9.4. The formula  is (Ds   Es) – communication deadlock or (Da   Ea) – resource deadlock. The larger “cloud” is a cyclic part, the smaller clouds are ending subgraphs. The chessboard-filled circle is the initial node. First, all nodes fulfilling  are identified (circles with dashed filling in Fig. 9.4a). Then a past of these nodes is found using reverse reachability (dotted filling of the ending subgraphs and the cyclic part in Fig. 9.4b). If any ending subgraph is left (subgraph with grilled filling in Fig. 9.4b), EF AG  is true – a deadlock occurs. 
 
The formula AF  (where  is Fa) is a termination condition – it is verified in three cases (Fig. 9.5). Again – the larger cloud is a cyclic part, the smaller ones are ending subgraphs (the edge of a “cloud” in Fig. 9.5a is dotted, because the ending subgraph can exist or not for this case). The initial node is a circle with a chessboard filling. 
•	The graph is cyclical or not, but there is a border surrounding the initial node, with each node satisfying  (Fig. 9.5a). Compassion forces every path to cross the border – the formula is true.
•	The graph is purely cyclical, and there is at least one node satisfying  (Fig. 9.5b). Com-passion forces every path to achieve this node – the formula is true.
•	The graph contains ending subgraphs – compassion causes every path to fall into one of these subgraphs, and then to visit every node in this subgraph infinitely often. If there ex-ists a state fulfilling  in every ending subgraph (Fig. 9.5c) – the formula is true.
 
The result of verification of the bounded buffer example, using Dedan built-in verifier, is present-ed in Fig. 9.6. No deadlock is reported, both in server processes verification (upper window) and in agent processes (lower window). The “TempoRG” in the widow title is the name of temporal verifier described in [Daszczuk, 2003] [Daszczuk, 2001].
 
 
References
Baier C, and Katoen J-P. (2008). Principles of Model Checking. Cambridge, MA: MIT Press.
Behrmann G, David A, and Larsen K G. (2006). A Tutorial on Uppaal 4.0. Aalborg, Denmark. url: http://www.it.uu.se/research/group/darts/papers/texts/new-tutorial.pdf
Cimatti A, Clarke E M, … Roveri M. (2000). NUSMV: A new symbolic model checker. International Journal on Software Tools for Technology Transfer, 2(4), 410–425. doi: 10.1007/s100090050046
Clarke E M, Grumberg O, and Peled D A. (1999). Model Checking. Cambridge, MA: MIT Press.
Daszczuk W B. (2001). Evaluation of temporal formulas based on “Checking By Spheres.” In Euromicro Symposium on Digital Systems Design, Warsaw, Poland, 4-6 Sept. 2001 (pp. 158–164). IEEE. doi: 10.1109/DSD.2001.952267
Daszczuk W B. (2003). Verification of Temporal Properties in Concurrent Systems. Warsaw University of Technology. url: https://repo.pw.edu.pl/docstore/download/WEiTI-0b7425b5-2375-417b-b0fa-b1f61aed0623/Daszczuk.pdf
Dick G, and Yao X. (2014). Model representation and cooperative coevolution for finite-state machine evolution. In 2014 IEEE Congress on Evolutionary Computation (CEC), Beijing, China, 6-11 July 2014 (pp. 2700–2707). New York, NY: IEEE. doi: 10.1109/CEC.2014.6900622
Gómez R, and Bowman H. (2005). Discrete Timed Automata. Technical Report 3-05-2005. Canterbury, UK. url: https://kar.kent.ac.uk/14362/1/TR305.pdf
Holzmann G J. (1995). Tutorial: Proving properties of concurrent systems with SPIN. In 6th International Conference on Concurrency Theory, CONCUR’95, Philadelphia, PA, 21–24 Aug. 1995 (pp. 453–455). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-60218-6_34
Holzmann G J. (1997). The model checker SPIN. IEEE Transactions on Software Engineering, 23(5), 279–295. doi: 10.1109/32.588521
Hung Y-C, and Chen G-H. (2006). Reverse reachability analysis: A new technique for deadlock detection on communicating finite state machines. Software: Practice and Experience, 23(9), 965–979. doi: 10.1002/spe.4380230904
Katoen J-P. (1999). Concepts, algorithms, and tools for model checking. Erlangen-Nürnberg, Germany.
Kesten Y, Pnueli A, and Raviv L. (1998). Algorithmic verification of linear temporal logic specifications. In 25th International Colloquium, ICALP’98 Aalborg, Denmark, 13–17 July 1998 (pp. 1–16). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/BFb0055036
Laskowski E, Tudruj M, … Toursel B. (2005). Java Byte Code Scheduling Based on the Most-Often-Used-Paths in Programs with Branches. In The 4th International Symposium on Parallel and Distributed Computing (ISPDC’05), Lille, France, 4-6 July 2005 (pp. 21–27). New York, NY: IEEE. doi: 10.1109/ISPDC.2005.31
Pnueli A, and Sa’ar Y. (2008). All You Need Is Compassion. In 9th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI 2008, San Francisco, CA, 7-9 Jan. 2008 (pp. 233–247). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-540-78163-9_21
Rozier K Y. (2011). Linear Temporal Logic Symbolic Model Checking. Computer Science Review, 5(2), 163–203. doi: 10.1016/j.cosrev.2010.06.002
Scholten C S, and Dijkstra E W. (1982). A Class of Simple Communication Patterns. In Selected Writings on Computing: A personal Perspective (pp. 334–337). New York, NY: Springer New York. doi: 10.1007/978-1-4612-5695-3_60
Zerzelidis A, and Wellings A J. (2005). Requirements for a real-time .NET framework. ACM SIGPLAN Notices, 40(2), 41. doi: 10.1145/1052659.1052666

10.	Timed IMDS
10.1.	Timed Automata
The behavior of a distributed system may depend on real time flow (as opposed to succession of events in discrete systems), because changes in the system may take some time. As a result, deadlock situations may depend on relations between periods of time associated with individual changes. Several formalisms were invented to express the behavior of systems with time con-straints, the most popular two are timed Petri nets and Timed Automata [Bérard et al., 2005] [Lime and Roux, 2006] [Cassez and Roux, 2006] [Popescu and Martinez Lastra, 2010]. Fur-thermore, temporal logics related to timed systems were elaborated: Real-Time CTL (RTCTL, with temporal operators attributed with time constraints [Emerson et al., 1992] [Gluchowski, 2009]), Clocked CTL (CCTL, based of time intervals in Discrete Time Systems [Ruf and Kropf, 2003]), Quantitative CTL (QCTL, with unit-delay transitions [Frossl et al., 1996]), Discrete Time CTL for embedded systems (DTCTL [Krystosik and Turlej, 2006]) and Timed CTL (TCTL, con-nected with Timed Automata [Alur and Dill, 1994]).
Timed Automata (TA [Alur and Dill, 1994]) are similar to Büchi automata [Holzmann, 1995] with time constraints. The automata execute their transitions independently, (in interleaving manner [Winskel and Nielsen, 1995]), with the exception of transitions on common symbols (also called signals) which synchronize the automata. A set of real-time clocks is introduced for the time constraints,. Clocks are variables with values from ℝ0, measured in a basic unit of time (a unit in short). The value of each clock is a real number, but we can observe the clocks when their val-ues are integers or between integers. For example, having two clocks x and y we can look at the system in a situation in which x is 2 and y is between 0 and 1. In addition, the relation between the clocks (as x<y or x<y+1) can be observed. Transitions of timed automata are supplemented by time restrictions, which define the possible values of clocks, when individual transition can be fired (for example, x1). Time invariants can also be imposed on states of automata (called loca-tions in TA). The invariant informs how long the automaton can stay in the location, expressed as the relation over clocks, like y<3. The clocks can be reset on transitions.
The transitions of TA are executed instantly, the clocks are advanced while automata stay in their locations. Therefore, the two types of progress are possible in TA: executing the transitions and progress of time. A detailed description of Timed Automata and their semantics are given in  [Alur and Dill, 1994] [Bérard, 2013].
The semantics of a set of Timed Automata is based on two types of transitions: progress transi-tions and timed transitions:
•	The progress transition (or simply: transition, also called action transition [Bowman, 2001]) is executed if the Boolean expression on the arc of the automaton is fulfilled. This expression is compound over clocks and integer constants. If two clocks are used in an expression, only a difference between them is allowed. If more than one transition can be executed (in the same or in distinct automata), the choice is nonde-terministic. The transitions are attributed with symbols called actions (do not confuse with IMDS actions, we use the term symbol for TA action). If the transitions in two or more automata have the same symbol, they are executed synchronously. Otherwise, the transitions are executed in an interleaving manner.
•	If all the automata in the set have their time invariants in their current locations fulfilled, and the clock values used in all the locations are less than the maximum values of their invariants, then a timed transition can be executed. The execution is based on advancing all clocks synchronously (by the same, real value >0). The maximum value the clocks can be advanced is the minimum difference between a maximum value of a clock used in an invariant and the current value of a clock used in this invariant. 
If both the progress transition and the timed transition can be executed, the choice in nondeter-ministic. Note that if the timed transition is enabled, possibly infinitely many similar timed transi-tions are enabled (see Fig. 10.1b). Therefore, timed regions (classes of equivalence) are intro-duced into the formalism; they are limited by integer values (the maximum value used for a given clock is the greatest integer with which the clock is compared) and equal sign of fractional part of clock differences (0 is treated as a separate, third sign). This creates a set of regions of values of the clocks. An exemplary set of regions is shown in Fig. 10.1a, for two clocks x and y and maximum integers 3 for x and 2 for y. The relations between the clocks are not analyzed above the maximum values.
Because infinitely many timed transitions are possible between a pair or regions (Fig. 10.1b), a graph of region succession is constructed. 
The construction of TA has important consequences, which can be traps for a designer who cre-ates only timeless specifications. First, the system without any time constraints (“timeless” sys-tem) cannot be treated as the corresponding timed system without time constraints. Having the formula  fulfilled in the initial location, the formula AG (  AF ) may be false due to staying in the initial location forever, even if the Boolean condition for leaving the initial location is fulfilled. The lack of invariant in the initial location is equivalent to the invariant of the form c0, where c is a hypothetical clock starting from 0 in the initial location. Such a situation is illustrated in Fig. 10.2a. In the figure, invariants are shown inside the locations, time restrictions of transitions are given in regular font, and operations executed on transitions (as clock reset) are given in italics. Boolean conditions triggering the transitions are written in bold.
In order to convert a timeless system into a corresponding timed system, the following rules should be applied, illustrated in Fig. 10.2b (for the exemplary automaton aut):
•	a local clock caut should be added;
•	each location of the automaton aut should be equipped with the time invariant caut=0;
•	each transition in the automaton aut should reset the local clock caut.
In such a system, time does not flow and everything happens in zero time. This is appropriate, if we want to build a timeless system in Timed Automata. But if real time constraints are imposed on the system, timeless loops are dangerous, because they allow infinitely many events to hap-pen in finite time. Such a situation is called zero-time loop (generalized as zenoness – infinitely many events in a finite time), and there are special tools to find them [Bowman et al., 2005] [Hadjidj et al., 2007] [Gómez and Bowman, 2007]. The example of a zero-time loop is given in Fig. 10.2c.
Another trap occurs when the location without time invariant has an outgoing transition with a maximum time bound, as in Fig. 10.2d. This location allows for staying in it forever, even if a Boolean condition allowing the escape is fulfilled during the period of the clock constraint of the transition. This can be cured by posing an invariant over the location: Fig. 10.2e shows the open upper bound while Fig. 10.2f shows the closed upper bound. However, this should be used care-fully, because if the Boolean condition becomes fulfilled after the maximum time bound of an outgoing transition, it cannot be executed. 
The original TA execute transitions synchronously if they are triggered by common symbols (which enable transitions). More than two automata can synchronize on a common symbol. In Uppaal, common symbols triggering transitions are replaced by communication channels. Com-munication through channels consists in sending and receiving a signal synchronously, for ex-ample chan! and chan?. This solution better models distributed systems, because the direction of communication is defined. Broadcast communication consists in receiving a signal sent from an automaton, by many automata.
The channel can be declared as urgent, in which case enabled transitions (with common channel symbols enabling these transitions: chan! or chan?) have a priority over time flow in locations. Therefore, a communication via urgent channel cannot be delayed if it is enabled. The transition enabled by urgent channel communication is also called urgent. The transition fired by the signal sent through the urgent channel has a priority over staying in the location. But the use of such a mechanism loses the asynchronous communication that is one of the key features of IMDS. Therefore, asynchronous communication via channels must be introduced separately.
Urgent transitions (with chan! or chan? as labels, Fig. 10.2g) cannot be mixed with expressions over clocks, as in Fig. 10.2c-f. Therefore, urgent channels and location invariants with expres-sions over clocks on transitions cannot be used together. For this reason, the two mechanisms of limiting the time spent in locations cannot be applied together.
10.1.1.	Uppaal TA syntax
Timed automata are usually defined as a set of timed automata and a set of real-valued clocks. For compatibility with Uppaal TA, we extend the definition of TA to cover the variables that can enable the transitions and can be assigned on transitions:
The Uppaal timed automaton UTA is a tuple
(L; l0; Z; Lab; E; Jl, O, {Ō}, Ō0) where:	(10.1)
•	L= {l0,l1,…} is the finite set of locations
•	l0 L is the initial location
•	Z = {c0,c1,…} is the set of clocks
•	Lab is the set of actions labels (interpreted as actions on transitions), they are (ch!, ch? and internal -actions)
•	Jl(l) maps every location lL to the set of Z clock valuations over a Cartesian product of ℝ0Z, for example Jl(l)={c1-c2>2} 
Comment As in verification tools e.g. Uppaal [LPY97], we restrict location invariants to constraints that are downwards closed, in the form: xn or x<n where n is a natural num-ber
•	O = {o1,o2,…} the finite set of variables
•	Wi = {wi1,wi2,…} the finite, integral set of values of variable oi  O
•	Ō = (w1,w2,…); wi Wi – the vector of values of variables
•	{Ō} = W1  W2  …  Wcard(O) – the set of vectors of variable values in O, Ō{Ō}
•	Ō0 = (w10,w20,…) – the initial vector of values of variables
•	E  L  Lab  Jll  2Z  b  F  L – the set of transitions
o	Jll(l,l’) maps every transition l,l’L to a set of Z clock valuations over a Cartesian product of ℝ0Z, just as Jl(l) for a location l
o	2Z indicates the subset of clocks in Z that are reset on the transition
o	b  {Ō} – the set of vectors of variable values enabling the transition, vectors con-taining a value r as xth element are denoted b={Ō[x]=r}
o	F: {Ō}  {Ō} the function assigning new values to the variables in O; 
Comment In Uppaal TA, the function is given as assignment operation “varia-ble:=expression over variables and integer constants” (all other variables are left unchanged)
10.1.2.	UTA semantics
The Semantics of the UTA is defined as follows:
Let (L, l0, Z, Lab, E, Jl, O, {Ō}, Ō0) be an UTA.	(10.2)
The semantics is defined as the Labeled Transition System Nodes, node0, , where 
•	Node  L  {Ō}  ℝZ  is the set of nodes, 
•	node0 = (l0, Ō0, u0) is the initial node, 
•	 = d  a is the transition relation such that
o	(l, Ō, u) d (l, Ō, u+d) if d’ 0d’d  u+d’  Jl(l)
o	(l, Ō, u) a (l’, Ō’, u’) if there exists e = (l, lab, g, r, b, F, l’)  E 
such that u  Jll(l,l’); u’ = [r  0]u and Ō b and Ō’=F(Ō)
where 
o	for d  ℝ0, u+d’ maps each clock x in Z to the value u(x) + d’, 
o	[res  0]u denotes the clock valuation which maps each clock in res to 0 and agrees with u over Z \ res
10.1.3.	Network of UTA syntax
The network of Uppaal Timed Automata over a common set of clocks and labels (actions), a common set of variables and a common initial vector of their values consists of n UTA: 
UTAi=(Li, li0, Z, Lab, Ei, Jli, O, {Ō}, Ō0) with1  i  n.	(10.3)
A location vector is a vector Ῡ = (l1, …, ln). 
Location invariant functions are composed into a common function over location vectors Jl(Ῡ) = Jl1(l1) … Jln(ln). 
Ῡ[li / li’] denotes the location vector where the ith element li  of Ῡ has been replaced by li’.
O is the common set of variables, {Ō} – the common set of vectors over O, Ō0 – the common vector of their initial values.
10.1.4.	Network of UTA semantics
Let UTAi = (Li, li0, Z, Lab, Ei , Jli, O, {Ō}, Ō0).	(10.4)
Let Ῡ0 = (l10,…, ln0) be the initial location vector. 
The semantics is defined as the Labeled Transition System Nodes, node0, , where:
•	Nodes = (L1 … Ln)  {Ō}  ℝZ  is the set of nodes, 
•	node0 = (Ῡ0, Ō0, u0) is the initial node, 
•	 = d  a  !  is the transition relation defined by:
o	(Ῡ, Ō, u) d (Ῡ, Ō, u + d) if d’ 0d’d  u+d’  Jl(Ῡ)
o	(Ῡ, Ō, u) a (Ῡ[li / li’], Ō’, u’) 
if there exists (li, ; Jll(li,li’), res, bi, Fi, li’) Ei such that u  Jll(li,li’); u’ = [res   0]u and Ōbi and Ō’=fi(Ō)
o	(Ῡ, Ō, u) ! (Ῡ[lj / lj’ , li / li’], Ō’, u’) if there exist 
(li, ch?, Jll(li,li’), resi, bi, Fi, li’) Ei and (lj, ch!, Jll(lj,lj’), resj, bj, Fj, lj’) Ej such that 
u  Jll(li,li’)  Jll(lj,lj’), u’ = [resi  resj   0]u and:
	(Ōbi and Ō’=Fi(Ō) and Ōbj and Fj(Ō)Ō) or
	(Ōbj and Ō’=Fj(Ō) and Ōbi and Fi(Ō)Ō)
Comment We require that at least one of the functions Fi, Fj must be identical-ly equal to its argument (it is ignored), and the other one is in effect (gives new values of the variables). This requirement prevents incoherent assignments to the same variable in automata UTAj and UTAk; the requirement is fulfilled by construction in translation of IMDS/Uppaal, as an assignment is applied in at most one automaton from the pair.
o	If both d and ! are possible from given node (Ῡ, Ō, u), then d is not included into LTS. 
Comment In such a way, Uppaal urgent channels are achieved; only such chan-nels are applied in translation IMDS/Uppaal.
10.2.	Timed extensions to IMDS (T-IMDS)
The timed version of IMDS (T-IMDS) is a natural extension. In T-IMDS, all the mentioned fea-tures of IMDS are preserved, combined with model checking: communication duality, locality, autonomy, asynchrony and automated verification. In addition, time constraints are imposed on elements of a distributed system that can last in the time interval: 
a)	time duration of the actions (fixed or subrange),
b)	limitation of time spent in the states.
The latter feature can be achieved in two ways:
•	asynchronous channels with limited time delay (implemented using Uppaal urgent channels and urgent transitions) – CT-IMDS;
•	applying time bounds to the states (BT-IMDS):
o	state time bound - maximum time spent in the state,
o	transition time restriction – clock values in which the transition can be fired,
o	clock reset.
These two ways of limiting time spent in the state are described separately.
IMDS actions are attributed with time duration limits:
{agent.server.service, server.state}  (time duration limits) {agent.server’.service’, server.state’}
Time constraints specifying the action duration can have one of two forms:
•	integer number (fixed time of the action) – angle brackets or parentheses can be used; examples: <0>, (1);
•	subrange – two comma-separated numbers; subrange can be open or closed in each limit – angle bracket denotes closed limit while parenthesis means open limit; exam-ples: (0,1), <1,2>, (0,2>.
A single number is a fixed duration time of the action, the subrange specifies a minimum and a maximum duration time; any value is possible between the bounds (including the bounds if the subrange is closed).
Limiting the duration of actions is not enough, because the control of time spent in states must supplement the specification of real-time behavior. Two kinds of such control are possible in T IMDS: 
•	asynchronous channels between servers (CT IMDS), with limited or unlimited time of transferring messages through the channel;. 
•	limiting the time spent in the states and restricting the moment of firing the actions (BT IMDS), with the possibility of resetting the clock counting these times.
The implementation is based on the Uppaal verifier. It does not allow the use of two mechanisms together: the signal triggering the transition cannot be mixed with the expression over clocks. Therefore, two versions of T-IMDS are prepared, which cannot be mixed and are described sep-arately.
To make order in defining individual time limitations, we use different terms:
•	time duration refers to the duration of the action;
•	time delay refers to the message transfer;
•	time bound refers to the time spent in the state;
•	time restriction refers to the moment of firing the action;
•	time constraints refer to all of the above terms together.
10.2.1.	Asynchronous channels with limited time delay (CT-IMDS)
The time delay of inter-server communication is specified using the channels command:
channels {(time delay), server(time delay), serverserver (time delay)} 
A simple time delay is the default for all unspecified server pairs. If it is preceded by a server identifier, it concerns all messages transferred to this server. An index can be used for a server that is an element of a vector (server[index]) or to all elements of a vector (without index). Other possibilities are: all elements of a vector except specified (server[-index]), elements whose index modulo number1 gives number2 (server[number2%number1]), or mixed. If a server pair is speci-fied, the time delay concerns communication only between this pair (the indexing described above may be applied to both servers). Each time delay may be fixed or a subrange, with open or closed limits.
The example of time delay definition is:
channels {(1,2), sem<1,2>, proc[1]sem[2]<1>), proc[-1]sem[0%2](2,3>}
If the channels are asynchronous, but the message transfer is instantaneous, the command has the form:
channels;
10.2.2.	Time bounds of states (BT-IMDS)
Determining the duration of actions may be insufficient, because the time spent in individual states is undefined and can vary from 0 to any positive real number. To limit this time, time bounds of states are introduced. In fact, the bounds specify the values of an automaton’s own clock that are possible while staying in the state. The definition of state bounds has the form:
bounds	{?clk(time bound)state1, ?clk(time bound)state2, …}
where clk is the keyword and denotes the private clock of the automaton. Time bound specifies the upper limit of stay in the state and can be open or closed (right parenthesis or right angle bracket, for example ?clk(1)state, ?clk(2>state ). Likewise, time restriction can be imposed on firing the action (clock values at which the transition can be fired, do not confuse with the action duration):
?clk(time restrictions){agent.server.service, server.state} 
 {agent.server’.service’, server.state’}
The syntax and meaning of time restrictions are the same as for the action duration. The local automaton clock can be reset by placing the exclamation mark after clk (or after time limits of the action firing restriction):
?clk!{agent.server.service, server.state}   {agent.server’.service’, server.state’}
In the action as: {a.s1.r1, s.p1}  (x,y) {a.s2.r2, s.p2}, all instances of the server type S use the same lower and upper limits x and y. The same refers to the state bounds of the form ?clk(y)state and for time restrictions of firing the action ?clk(x,y)action. The time bounds can be appointed to all elements of the state vector or to individual elements of the state vector. To de-fine time restrictions individually, conditional definitions are included in IMDS. They have the form ?number or ? number preceding the time bounds for the state or placed before the action. 
The condition ?number refers to the server instance appointed by the number, while ?-number refers to all instances except the number. If time bounds are defined for individual instances of the server type, a default value (without an instance number) must be defined as well. 
Similarly, time delays of channels connecting the servers may concern individual target servers ((x,y)), entire server vectors or non-vectors servers (serv(x,y)), individual server vector ele-ments (serv[n](x,y)) or server pairs (serv1serv2(x,y)).
10.3.	Conversion of T-IMDS to Uppaal Timed Automata
The Uppaal verifier [Behrmann, David, et al., 2006] uses Timed Automata [Alur and Dill, 1994] with several extensions:
•	automata types (called templates) and variables,
•	global and local (to individual automata) variables of integral types,
•	global and local (to individual automata) clocks,
•	in addition to the time restrictions, the relation on integral variables and integer con-stants can be used in Boolean expressions on transitions,
•	formal and actual parameters of automata variables, passed by value or by reference;
•	equal symbols on transitions are replaced by channels; synchronous execution of transitions with the same symbol is replaced by sending and receiving a signal through the channel (in this way, the communication direction is introduced); 
•	channels can be defined as urgent, which means that synchronization (simultaneous execution of sending and receiving of a signal over the channel) has priority over staying in locations.
The verified Timed IMDS system is converted to Uppaal Timed Automata. The distributed server automata S-DA3, equivalent to the IMDS specification in the server view, are converted accord-ing to the following rules:
•	the S-DA3 automata type is converted to the Uppaal automata template;
•	the template has formal parameters: its instance number myNum (index in the server vector) and integral variables that implement communication between the automaton and other automata; 
•	every automaton implementing a server in equipped with hidden clock c, which is used to count the time durations of actions;
•	the states of S-DA3 are converted to the locations of TA;
•	the action (transition) of S-DA3 (IMDS action) is converted to a transition-location-transition sequence; the location between the transitions is used to counting the time duration of the action;
•	if various instances of the server type have different initial states, an additional initial location is added with the selection.
The location between the transitions is used to implement the action time duration; it is illustrated in Fig. 10.3a: the agent a action invoking the service r1 is executed on the server s1 in the state p1. The action lasts between x and y time units. It sends the message (a,s2,r2) of the agent a to another server s2, invoking its service r2; the server s1 changes its state from p1 to p1’. The additional location is equipped with time invariant c<y (in the case of closed upper limit it would be cy). The transition outgoing from this location has the Boolean guard x<c<y. The result is that the outgoing transition is followed not earlier than x units and not later than y units since entering the location (clock c is reset on entry to this location). Of course, x and y must be substituted by constants in the model, or #DEFINE may be used. The expressions over variables a_si on transitions are discussed in detail in the description of message passing below.
If various server variables of the common server type have different initial states, an additional location is introduced. The selection is made upon the value of the integer myNum parameter, passed to the timed automaton as the number of server type instance. On the basis of the value of this parameter, the transitions to the appropriate initial states are selected (Fig. 10.3b).
10.3.1.	Implementation of BT-IMDS
The implementation rules presented above are not enough, because the automaton can stay in a location infinitely, even if the condition firing the transition is fulfilled. Consider the Fig. 10.2a: we have the expression N==1 as a transition guard, but the automaton can stay in the location infinitely even if N is really equal to 1, because there is no necessity to leave the state in TA (the timed transition can be chosen). The time spent in the state and the moment of leaving it can be determined by state time bounds and action firing time restrictions.
The BT-IMDS implementation is based on the following rules:
•	if there are states with time bounds or actions with firing time restrictions specified (or explicit clock resets), an additional clock clk is added to count time flow for these bounds;
•	the clock reset is implemented by updating clk=0 on the transition.
•	the state time bound is implemented by the location time invariant (over the clock clk);
•	the action firing time restrictions are converted to the Boolean guard (over the clock clk) of the transition.
The state time bounds and action firing time restrictions are implemented using the internal au-tomaton clock clk. The declaration bounds p(y) causes the location p to use time invariant clk<y (Fig. 10.4a). If the time bound is closed, the invariant has the form clky (Fig. 10.4b).
Time restriction of firing the action ?clk(x,y){a.s.r, a.p}  … are implemented as Boolean guard over clk on the transition: x<clk<y, Fig. 10.4c. If the limits of time restriction are closed, the guard has the form xclky (Fig. 10.4d). Open and closed limits can be mixed: (x,y>, <x,y). The limit can be fixed: <y,y> or <y>.
The clock clk is not reset automatically, therefore it may have a non-zero value on entering the state. Therefore, it can be explicitly reset on action leading to the state. The action resets clk if it is preceded by ?clk! or ?(x,y)clk! (Fig. 10.4e).
The value and kind (open or closed) of state time bound must be coordinated with the value and kind of upper limit of the firing restriction, as presented in Fig. 10.4f. Otherwise, if time bound is bounds p<y> and firing restriction is ?clk(x,y), or if time bound is bounds p(z) and firing restriction is ?clk(x,y), y<z, then the state p cannot be left if the value of clk is y or greater than y, even if the action is prepared. This situation is sometimes called time-lock [Bowman, 2001], a situation in which time is prevented from passing beyond a certain point. The zero-time loop (zeno loop [Hadjidj et al., 2007]) is an example of a time-lock, if there is no escape from the loop (in an unfair system, even an escape does not guarantee that the system leaves the loop). Other time-lock is presented in Fig. 10.2e, if the variable N does not get value 1 while the clock c value is 2<c<3. 
The state time bounds with action firing time restrictions should be used carefully, because if the condition preparing the action (the message arrives and starts to pend) is not fulfilled during the time limit specified in state bound, a time-lock occurs.
BT-IMDS message passing is implemented using global variables, passed to individual automata by parameters in their headings. The sending server sets the global variable to a value repre-senting the service to be invoked. The message is pending at the target server simply keeping the assigned value of the variable, which is passed as the actual parameter to both servers: the sending one and the receiving one. The value is reset to 0 on firing an action invoked by the message in the target server. Because many messages can be pending at the server (one mes-sage for each agent), the variables used to store pending messages must be declared for each pair (agent, target server). This is illustrated in Fig. 10.5: the server s1 in the action prepared in the state p1 issues a message (a,s2,r2) to the server s2. The server s2 can fire the action in-voked by the message (a,s2,r2) in the state p2 (however, it does not have to be the current state of s2). The message is pending until the server s2 fires the action and thus resets the variable used to implement the message. In TA implementation, sending a message (a,s2,r2) consists in setting the value of variable a_s2 to s2_r2. Firing the action in s2 by accepting the message in the state p2 is implemented by a Boolean guard a_s2==s2_r2 of the transition. Execution of this transition resets a_s2 to 0. Sending messages through values of global variables makes the communication – sending and accepting messages – really asynchronous. 
10.3.2.	Implementation of CT-IMDS
The other way to enforce the firing of the prepared action in IMDS is to use urgent channels of Uppaal TA (synchronization on urgent channels has priority over staying in the location). Syn-chronization on urgent channels is called urgent transitions. 
Synchronization in Timed Automata is based on synchronously executed transitions with com-mon symbol in two automata. In Uppaal, the common symbol  is equipped with ! and ? symbols, which denote send and receive operations on the channel. If the channel is defined as urgent, the send and receive operations have priority over time flow in locations (progress transitions have priority over timed transitions). The channels do not allow transferring the value from the sender to the receiver, therefore we call this type of communication signals. The message value (service identifier) must be transferred separately, by the variable value.
Boolean guards over clocks on urgent transitions are not allowed in Uppaal [Behrmann, David, et al., 2006], therefore two versions of T-IMDS are elaborated: BT IMDS includes state time bounds and action firing time restrictions (implemented using location time invariants and Boolean guards over clocks), while CT-IMDS includes asynchronous channels with time delays (implemented using Uppaal TA urgent channels).
The TA channels are synchronous, because the sender and the receiver simultaneously execute their transitions on the common channel. Therefore, urgent channels cannot be used directly to implement message passing in asynchronous IMDS. However, an asynchronous channel can be built using two synchronous channels: one for sending a message and the second for receiving it. Between sending and receiving operations, the time delay with specified limits can be applied. The second channel (the one used for receiving)  can be used for keeping pending messages at the target server and for free choice of the message that matches the current state of the server.
The message passing implementation in Uppal TA is presented in Fig. 10.6. Global variables are used for transferring the message value, just as in BT-IMDS (or timeless IMDS converted to Up-paal TA). Setting the variable value is accompanied by sending a signal through an urgent channel. Execution of the transition enabled by the Boolean guard over the variable (implement-ing the message acceptance) is accompanied by receiving the signal over the second urgent channel. The two operations on two channels are coordinated in a separate timed automaton called asynchronous channel. 
The basic structure of the asynchronous channel is presented in Fig. 10.7a. The inactive channel timed automaton stays in the idle location. Getting a signal from the sending automaton via inChan channel executes the transition to the wait location in which asynchronous channel stays for a period of time specified by IMDS channel delay. The delay time is between lower and upper limit (l1,l2), specified in the IMDS channels command. Open and closed limits are allowed, as well as fixed delay <l2,l2> or <l2>.
After the delay, the asynchronous channel moves to the send location. The transition to the idle location is executed synchronously with the transition in the receiver automaton using the out-Chan channel. Note that since the signal is received through inChan, the message value is kept in the global variable. It will be reset on acceptance of the message in the receiver automaton (see Fig. 10.6). Reaching the idle location finishes the cycle of transferring the message.
Asynchronous channels start in one of two ways. If the asynchronous channel initially contains the initial message of the agent, it starts in the send location. The value of the initial message (the service identifier) must be set to the global variable. Otherwise, the asynchronous channel starts in the idle location. The selection is done based the value of the Boolean parameter iniMess, which is observed on two outgoing transitions from the choice location and leading to the send and idle locations (Fig. 10.7b).
The message can be sent by the server to itself. This should be executed without time delay. For this purpose, the third urgent channel selfChan is used. Getting a signal through this channel leads directly to the send location, without intermediately staying in the wait location (Fig. 10.7c). 
If a time delay is defined for the servers pair separately (serv1serv2(sl1,sl2)), the additional input channel serv1_chan is defined for the server serv1, and a separate waiting location serv1_wait with its own time constraints is added (Fig. 10.7d).
The command channels; defines channels without a specified delay, therefore asynchronous channels without wait location are used (Fig. 10.7e).
Just like variables used to keep the message values, a channel must be defined for each pair (agent, target server).
The implementation of actions must follow the rules resulting from the construction of asynchro-nous channels: setting of a global variable which keeps the message value must be combined with sending a signal through the input channel of the asynchronous IMDS channel, while reading the global variable which keeps the message value must be combined with receiving the signal from the output channel of the asynchronous IMDS channel. This may be done safely if the action duration is 0 (Fig. 10.8a).
However, it is more complicated in the case of a non-zero duration. Recall that Boolean guards over clocks cannot be combined with synchronization over urgent channels in Uppal. Fortunate-ly, this rule can be omitted with the help of a sequence of two transitions, as sending the message is performed at the end of the time-lasting action. It is illustrated in Fig. 10.8b: the location with the time invariant is passed first, then sending the signal follows.
10.4.	Formal translation of CT-IMDS to Uppaal Timed Automata
The translation of CT-IMDS to Uppaal Timed Automata (UTA) should fulfil the following require-ments:
•	Every server is implemented as an UTA automaton, plus UTA implementing asynchro-nous channels.
•	Every item is implemented as a set of locations of UTA and a set of UTA variables, plus UTA locations, UTA variables and UTA channels implementing asynchronous channels; therefore UTA global node represents the states of all automata, the messages of all non-terminated agents and phases of activity of asynchronous channels.
•	Every action is implemented as a single UTA transition or a sequence of UTA transitions with no diverge until the action is completed (the input state that is left, the input message is consumed, the next state is reached, the next message is issued, and the action time duration is expired); the input items “disappeared” before counting time duration, the output items are established after it.
•	Time constraints are imposed only on locations implementing the actions for counting ac-tion durations and on locations of UTA automata implementing asynchronous channels.
In this section, a translation of CT-IMDS to UTA is presented. A translation of BT-IMDS is analo-gous and is not covered.
10.4.1.	Translation of individual servers to Uppaal Timed Automata 
Every timed server (sj, B(s), gsj) in the IMDS system of N servers and K agents is implemented as: UTA = (L, l0, Z, Lab, E, J, O, {Ō}, Ō0)
The ranges of agents 1,…,K and servers 1,…,N are used in shortened form 1..K and 1..N.
sj – the IMDS server, sjS
B(sj) – the transition relation of the IMDS server sj (set of actions of a server sj): B(sj)={ | =(((a,sj,r),(sj,p)),((a,sk,r’),(sj,p’))) }
The set of constraints constr is a set of ℝ0 subranges with natural bounds: bool  ℕ  ℕ  bool,  natural numbers are lower and upper bound of the subrange and Boolean values are kinds of lower and upper bounds  (false-open/true-closed); the subrange must be monotonic, i.e., for (x1, x2, x3, x4), if x2<x3 then both x1 and x4 can be of any kind (open or closed), while if x2=x3 then x1=x4=true. The bounds x2>x3 are prohibited. The notation is x1 x2, x3 x4, where open bounds x1 and/or x4 are denoted by round parentheses ( ), and while closed bounds x1 and/or x4 by angle brackets < >. If x2=x3 then single value can be supplied. Instant subrange is (true, 0, 0, true), denoted <0,0> or <0>. A special subrange is “unspecified”, which means that the scope is ℝ0. The notation of unspecified subrange is ℝ0 or <0, ) or simply no subrange specified.

Z = {csj} – hidden clock of server sj
gsj: B(sj)   constr – the function mapping the actions of the server sj to time durations.
J sj() is the action invariant mapping the clock csi to the subrange (true, 0, x3, x4) of gsj()=(x1, x2, x3, x4),   B(sj). 
Lsj - the set of locations Lsj = Psj = {psjx(psj), psjd(psj,,gsj()), psjy(psj,) | psjP(sj), =((m,psj),(m’, p’sj))} (three locations for every state psj). The set of locations connected with states of the server sj; psjx(psj) represents the state psj itself (in which a message m can be accepted), psjd(psj,,g()) is the location connected with the state psj and the action  (more than one action can start from a given psj), used for counting the action  duration, psjy (psj,) is the location connected with the state psj and the action , in which the next message m’ of the action  is issued; the subsets of Psj are Psjx = {psjx(psj) | psjP(sj)}, Psjd = {psjd(psj,,gsj()) | psjP(sj), =((m,psj),(m’, p’sj))}, Psjy= {psjy(psj,) | psjP(sj), =((m,psj),(m’,p’sj))}.
l0 – psjx of the initial state, l0 = psjx(psj), psj  Psj  Pini (this intersection contains exactly one ele-ment).
J(l) is the location time invariant; for timeless locations in Psjx  Psjy of a server sj, the invariant J(lPsjx  Psjy)=ℝ0 for the clock csj. The invariant for timed locations Psjd: J(l Psjd)=Jsj(),  for the clock csj (for actions on server sj: =(((a,sj,r),(sj,v)),((a,sk,r’),(sj,v’))) ).
Lab =  B(sj)  {chij_y_k!, chij_x? | i=1..K, k=1..N} – for server sj: set of actions, labels of sending messages to servers skS and labels of receiving messages.
E  L  g  Lab  {{csj}}  b  F  L = {
(psjx(psj), ℝ0, chij_x?, {csj}, b[i,j]=r, F(Ō)Ō, psjd(psj,,g())), 
(psjd(psj,,gsj()), gsj (), , {csj}, b[i,j]=r, F(Ō)=Ō/[i,k]=r’, psjy(psj,)), 
(psjy(psj,), ℝ0, chij_y_k!, {csj}, b[i,k]=r’, F(Ō)Ō, psjx(p’sj))} -
for =(((ai,sj,r),(sj,v)),((ai,sk,r’),(sj,v’))); Ō/[i,k]=r’ denotes that the result of F is Ō in which ele-ment Ō[i,k] is set to r’ while all elements Ō[i,t]=novalue, t=1..K, tk;
for an action  the sequence of transitions connecting the locations psjx(psj) and psjx(p’sj) via the transition  is: (psjx(psj), psjd(psj,,g())) labeled with chij_x? (receiving of a message from channel chij_x), transition (psjd(psj,,g()), psjy(psj,))) with time constraint gsj() and label , and transition (psjy(psj,), psjx(p’sj,))) labeled with chij_y_k! (sending the next message). Every transition resets the server sj hidden clock csj. 
The location psjd(psj,,g()) has the time invariant Jsj(), all other locations have time invariant ℝ0.
O = {oij | i=1..K, j=1..N} – the set of variables containing services called by the agents. Sending the message (ai,sj,r) is implemented as setting the value of the variable oij and simultaneous ex-ecuting the send operation on the corresponding channel chik_y_j!. Accepting the message (exe-cution of the action with the message on input) is simultaneous resetting the variable to the neu-tral value (outside the set of services R, see below) and executing the receive operation on cor-responding channel chij_x?.
Wj = {w1j, w2j,…}, wijR  {novalue}, i=1..card(R) – the set of values implementing the set of services of the server sj. In practice, only services used in messages directed to sj can be used.
Ō = (wij,…) | i=1..K, j=1..N; wij Wj  {novalue} – the vector of values of variables implementing messages (Ō[i,j]=wij is the service in the messages of the agent ai pending at the server sj). if Ō[i,j]novalue then the message of ai is pending at sj, invoking the service r=wij. If Ō[i,k]=novalue for all k=1..N then the agent ai is terminated.
Ō0 = (wij0,…) | i=1..K, j=1..N; wij Wj  {novalue}  – the initial vector of services of pending mes-sages; if Ō[i,j]novalue then the initial message of ai is pending at sj.
{Ō} = W1  W2 … WK is the set of vectors where Ō  W1  W2 … WK
10.4.2.	Semantics of server timed automaton 
The semantics of UTA is defined as a Labeled Transition System Nodes; node0; , 	 (10.5)
where:
•	Nodes  L  {Ō}  ℝZ  is the set of nodes, 
•	node0 = (l0; Ō0; u0) is the initial node, 
•	 = d  ?    !  is the transition relation such that
o	(l, Ō, u) d (l, Ō, u+d) if d’ 0d’d  u+d’  J(l)

o	(psjx(pj), Ō, u) ? (psjd(psj,,g()), Ō, u’) 
if there exists =((m,psjx(pj)),(m’,psjx(p’j))) such that m=(ai,sj,r), m’=(ai,sk,r’), Ō[i,j]=r, u J(psjx(pj)), u’ = [{csj}   0]u – acceptance of the incoming message; note that the transition (psjx, psjd) is labeled with chij_x?;  server sj automaton tran-sition (psjx(pj), ℝ0, chij_x?, {csj}, {Ō[i,j]=r}, F(Ō)Ō, psjd(psj,,gsj())) 
o	(psjd(psj,,g()), Ō, u)  (psjy(psj,), Ō’, u’) 
for =((m,psjx(pj)),(m’,psjx(p’j))), such that m=(ai,sj,r), m’=(ai,sk,r’), Ō’[i,j]=novalue, Ō’[i,k]=r’, ugsj()=J(psjd(psj,,g())), u’ = [{csj}   0]u – transition to the location sending the next message (labeled with ); server sj automaton transition (psjd(psj,,gsj()), gsj (), , {csj}, {Ō}, F(Ō)=Ō/[i,k]=r’, psjy(psj,))
o	(psjy(psj,), Ō, u) ! (psjx(p’j), Ō, u’) 
for =((m,psjx(pj)),(m’,psjx(p’j))) such that m=(ai,sj,r), m’=(ai,sk,r’), u  J(psjy(psj,)), u’ = [{csj}   0]u – transition to the next state and sending the next message; note that the transition (psjy(psj,), psjx(p’j)) is labeled with chij_y_k!; server sj automaton transition (psjy(psj,), ℝ0, chij_y_k!, {csj}, {Ō}, F(Ō)Ō, psjx(p’j))
where 
•	for d  ℝ0, u+d’ maps clock csj  in Z to the value u(x) + d, 
•	[{csj}   0]u denotes the clock valuation which maps server sj hidden clock csj to 0 and agrees with u over Z \ clk

10.4.3.	Translation of asynchronous channels  to Uppaal Timed Automaton
The timed server (sj, B(sj), gsj) of IMDS system of N servers and K agents is equipped with the set of asynchronous channels for every agent, implemented as UTA = (L; l0; Z; Lab; E; J, O, {Ō}, Ō0), where O, {Ō}, Ō0 are not used. We use the name asynchronous channel to differentiate the automaton from synchronous channels used to implement the communication. The terms send-ing and receiving we reserve for servers, we say that asynchronous channel gets a message from the source server and puts it to the target server.
sj – the IMDS server, sjS, ai – the IMDS agent, aiA
Z = {ccij} – the clock of asynchronous channel of the server sj for agent ai
gchj: S   constr – the function mapping asynchronous subchannels (see below) from every server sk, k=1..N to the server sj, to time delays. For the self-subchannel gchjj= ℝ0 or gchj=(true, 0, , false).
Jchj(sk) is the subchannel time invariant mapping ccij to the subrange (true, 0, x3, x4) of gchj(sk)=(x1, x2, x3, x4). 
J(l) is the location time invariant; for timeless locations chij_idle and chij_send of the asynchronous channel chij, the invariant J(l{chij_idle and chij_send})=ℝ0 for the clock ccij. The invariant for timed location chij_wait_k J(chij_wait_k) = Jchj(sk) for the clock ccij.
Lab =  {chij_y_k? | k=1..N}  {chij_x!}  {delay} – for server sj: set of actions, labels of getting mes-sages from servers skS , label for putting a message to the server sj and the label for counting delay of the channel sj
Lchij = CHij = {chij_idle, chij_send}  {chij_wait_k | k=1..N} – the set of locations of asynchronous channel for sending the agent ai messages to the server sj; chij_idle is used for waiting for the agent ai messages, chij_wait_k is the subchannel location used for counting the asynchronous channel delay, specific for the pair (sk, sj), and the location chij_send is for putting a message to the server sj; The subsets of CHij are CHij_idle = {chij_idle}, CHij_wait = {chij_wait_k | k=1..N}, CHij_send = {chij_send}. 
If the initial message of the agent ai is directed to sj, then l0 (the initial location) is chij_idle, other-wise it is chij_send.
E  L  g  Lab  {{ccij}}  b  F  L = {
(chij_idle, ℝ0, chij_y_k?, {ccij}, {Ō}, F(Ō)Ō, chij_wait_k), 
(chij_wait_k, gchj (k), delay, {ccij}, {Ō}, F(Ō)Ō, chij_send), 
(chij_send, ℝ0, chij_x!, {ccij}, {Ō}, F(Ō)Ō, chij_idle)} -
for the message sent from the server sk to the server sj, the sequence of transitions connecting the locations chij_idle, chij_wait_k, chij_send is: (chij_idle, chij_wait_k) labeled with chik_y_j? (getting the message from the channel chik_y_j), transition (chij_wait_k, chij_send) with time constraint gchj(k) and label delay, and transition (chij_send, chij_idle) labeled with chij_x! (putting the message to the server sj using the channel chij_x). Every transition resets the channel chij clock ccij. 
The location chij_wait_k has the time invariant Jchj(k,j), all other locations have time invariant ℝ0.
O = {oij | i=1..K, j=1..N} – the set of variables, not used in the automaton.
Ō = (wij,…) | i=1..K, j=1..N – the vector of values of variables, not used in the automaton.
Ō0 = (wij0,…) | i=1..K, j=1..N – the initial vector of values of variables, not used in the automaton. 
{Ō}  W1  W2 … WK is the set of vectors where Ō  W1  W2 … WK
10.4.4.	Semantics of asynchronous channel automaton 
The semantics is defined as the Labeled Transition System Nodes; node0; , where: 	(10.6)
•	Nodes  L  {Ō}  ℝZ  is the set of nodes, 
•	node0 = (l0; Ō0; u0) is the initial node, 
•	 = d  ?  ch  ! is the transition relation such that
o	(l, Ō, u) d (l, Ō, u+d) if d’ 0d’d  u+d’  J(l)

o	(chik_idle, Ō, u) ! (chik_wait_j, Ō, u’) 
u J(chik_idle), u’ = [{ccij}   0]u – getting the message from the sending server; transition (chik_idle, chij_wait_k) is labeled with chij_y_k?; asynchronous channel chij au-tomaton transition (chik_idle, ℝ0, chik_y_j?, {ccij}, {Ō}, F(Ō)Ō, chij_wait_k)
o	(chij_wait_k, Ō, u) ch (chij_send, Ō, u’) 
ugchj(k)=J(chij_wait_k), u’ = [{ccij}   0]u – transition to the location putting the mes-sage to the target server (labeled with delay); asynchronous channel chij automa-ton transition (chij_wait_k, gchj(k), delay, {ccij}, {Ō}, F(Ō)Ō, chij_send)
o	(chij_send, Ō, u) ? (chij_idle, Ō, u’) 
u J(chij_send), u’ = [{ccij}   0]u – putting the message to the target server; the transition (chij_send, chij_idle) is labeled with chij_x!; asynchronous channel chij au-tomaton transition (chij_send, ℝ0, chij_x!, {ccij}, {Ō}, F(Ō)Ō, chij_idle)
10.4.5.	Translation of CT-IMDS system to Uppaal Timed Automata
The timed system CT-IMDS of N servers and K agents system is defined as (IMDS, g, gch) - 
IMDS is the timeless system, time constraints are given as two functions assigning time durations to actions and time delays to asynchronous channels.
Q = {chij_x, chij_y_k | i=1..K, j=1..N, k=1..N} is the set of synchronous channels for implementation of IMDS asynchronous channels. The asynchronous channel chij_y is for receiving messages of agent ai at the server sj. The channel chij_y_k is for sending messages of the agent ai from the server sk to the sever sj.
The asynchronous channel between the pair of servers (sk, sj) consists of synchronous channels chij_y_k, chik_x.
The set of all locations of all servers is LS=j=1..N Psj.
The set of all locations of all asynchronous channels is LCH = i=1..K, j=1..N CHij.
L = LS  LCH – the set of all locations
CS = {cs1,…,csN} is the set of hidden clocks of servers si.
CC = {ccij | i=1..K, j=1..N} is the set of clocks of asynchronous inter-server channels. 
Z=CS  CC
g:   constr (action time constraint guard) is the function mapping actions to subranges, it is the sum of all functions for individual servers.
The action invariant J() is csj in the subrange (true, 0, x3, x4) of g()=(x1, x2, x3, x4) , =(((a,sj,r),(sj,p)),((a,sk,r’),(sj,p’))), for all cscsj the scope is ℝ0. 
gch: S  S  constr (asynchronous channel delay time constraint guard) is the function mapping all pairs of (agent, target server) (asynchronous communication channels)  to subranges, just like g. 
The asynchronous channel invariant Jch(chij) in the subrange (true, 0, x3, x4) of gch(chij)=(x1, x2, x3, x4), i=1..K, j=1..N, for all ccccij the scope is ℝ0. 
Ῡp  Ps1  …  PsN, where Psi  {psjx(pj), psjd(psj,,g()), psjy(psj,) | pjP(sj), j=1…N, } – the vector of current locations of all server automata. The initial vector of states of servers Ῡp_ini = (psjx(pj) | pjP(sj)  Pini, j=1..N).
Ῡch  CH11  …  CHKN, where CHij={chij_idle, chij_wait_k, chij_send | k=1..N } | i=1..K, j=1..N – the vector of current locations of asynchronous channels for sending messages to all servers, for every agent. In practice, only used asynchronous channels must be implemented, i.e.:
•	For every agent, only the asynchronous channels for sending messages to the serv-ers visited by the agent must be implemented.
•	In an asynchronous channel, locations chij_wait_k must be implemented only for servers sk sending messages to the server sj.
Ῡch_ini is the initial vector of asynchronous channel locations, Ῡch_ini [i,j]  {chij_idle, chij_send}: if the initial message for the agent ai is directed to the server sj, then the initial location of asynchronous channel chij is chij_send, otherwise chij_idle.
Ῡ=(Ῡp,Ῡch) – the global location. Ῡini=(Ῡp_ini,Ῡch_ini) – the global initial location.
Location invariant functions are composed into a common function over location vectors J(Ῡ) = J(l1)  J(l2)  …, li  L, i=1..card(L). For timeless locations Psjx  Psjy of the server sj, the invariant J(lPsjx  Psjy)=ℝ0 for the clock csj. The invariant for timed locations Psjd J(l Psjd)=J(),  for the clock csj (only for the actions in the server sj: =(((a,sj,r),(sj,v)),((a,sk,r’),(sj,v’))). For timeless asynchronous channel locations CHij_idle, CHij_send, J(l CHij_idle  CHij_send)=ℝ0 for the clock ccij. The invariant for timed location chij_wait_k J(l) =Jch(k,j) for the clock ccij.
O = {oij | i=1..K, j=1..N} – the set of variables containing services called by messages. Sending a message (ai,sj,r) is implemented as setting the value of the variable oij and simultaneous execut-ing the send operation on corresponding channel chik_y_j!. Accepting the message (execution of the action with this message in input) is simultaneous resetting the variable to the neutral value (outside the set of services R) and executing the receive operation on corresponding channel chij_x?.
Wj = {w1j, w2j,…}, wijR  {novalue}, i=1..card(R) – the set of values implementing the set of services of the server sj. In practice, only services used in messages directed to sj can be used.
Ō = (wij,…) | i=1..K, j=1..N; wij Wi  {novalue} – the vector of values of variables implementing messages (wij is the service of messages of the agent ai pending at the server sj); for the agent ai, at most one of the variables wij, j=1..N has a value other than novalue: exactly one if the agent runs, all are novalue if the agent is terminated. In practice, for any agent only servers visited by the agent are represented.
Ō0 = (wij0,…) | i=1..K, j=1..N; wij Wi  {novalue}  – the initial vector of services of pending mes-sages; for the agent ai, exactly one of the variables wij, j=1..N has value other than novalue. For miMini, m=(ai,sj,r), i=1..K, j1..N, wij=r, kj wik=novalue
Ῡ[li / li’] denotes the location vector where the ith element li  of Ῡ has been replaced by li’.

Esj, j=1..N is the set of transitions of server automaton sj. ECHij, i=1..K, j=1..N is the set of transi-tions of asynchronous channel automaton CHij. Labels  and delay are replaced by the symbol of “internal action“ .
10.4.6.	Semantics of CT-IMDS system implemented as Uppaal Timed Automata
Let CT-IMDS = (IMDS, g, gch).	
Let u – the valuation of all clocks, u0 – all clocks equal 0.
The semantics is defined as a Labeled Transition System Node; node0; , where:	(10.7)
•	Node  (Ps1  …  PsN)  (CH11  …  CHKN)  (R  {novalue})card(A)*card(S)  ℝCS  CC  is a node, 
•	node0 = (Ῡ0; Ō0; u0) is the initial node, 
•	  d  ?    !  ch  is the transition relation defined by:
o	(Ῡ, Ō, u) d (Ῡ, Ō, u + d) if d’ 0d’d  u+d’  J(Ῡ)

o	(Ῡ, Ō, u) ? (Ῡ[psjx(pj) / psjd(psj,,g()), chij_send / chij_idle], Ō, u’) 
if there exists =((m,pj),(m’,p’j)) such that m=(ai,sj,r), m’=(ai,sk,r’), Ō[i,j]=r, u J(Ῡ[psjx(pj) / psjd(psj,,g()), chij_send / chij_idle]), u’ = [{csj,ccij}   0]u – acceptance of the incoming message; note that the transitions (psjx(pj), psjd(psj,,g())) and (chij_send, chij_idle) synchronize od the channel chij_x with labels chij_x? and chij_x!; 
sj transition (psjx(pj), ℝ0, chij_x?, {csj}, {Ō[i,j]=r}, F(Ō)Ō, psjd(psj,,g()))
chij transition (chij_send, ℝ0, chij_x!, {ccij}, {Ō}, F(Ō)Ō, chij_idle)
o	(Ῡ, Ō, u)  (Ῡ[psjd(psj,,g()) / psjy(psj,), Ō’, u’) 
for =((m,pj),(m’,p’j)) such that m=(ai,sj,r), m’=(ai,sk,r’), Ō’[i,j]=novalue, Ō’[i,k]=r’, ug()=J(Ῡ[psjd(psj,,g()) / psjy(psj,)]), u’ = [{csj}   0]u – transition to the location sending the next message (labeled with );
sj transition (psjd(psj,,gsj()), gsj (), , {csj}, {Ō}, F(Ō)=Ō/[i,k]=r’, psjy(psj,))
o	(Ῡ, Ō, u) ! (Ῡ[psjy(psj,) / psjx(p’j), chik_idle / chik_wait_j], Ō’, u’) 
for =((m,pj),(m’,p’j)) such that m=(ai,sj,r), m’=(ai,sk,r’), uJ(Ῡ[psjy(psj,) / psjx(p’j), chik_idle / chik_wait_j]), u’ = [{csj,ccik}   0]u – transition to the next state and sending the next message; note that the transitions (psjy(psj,), psjx(p’j)) and (chik_idle, chik_wait_j) synchronize on the channel chij_y_k with labels chij_y_k! and chij_y_k?;
sj transition (psjy(psj,), ℝ0, chij_y_k!, {csj}, {Ō}, F(Ō)Ō, psjx(p’j))
chij transition (chik_idle, ℝ0, chik_y_j?, {ccij}, {Ō}, F(Ō)Ō, chij_wait_k)

o	(Ῡ, Ō, u) ch (Ῡ[chij_wait_k / chij_send], Ō, u’) 
ugch(k,j)=J(Ῡ[chij_wait_k / chij_send]), u’ = [{ccij}   0]u;
chij transition (chij_wait_k, gch(k,j), , {ccij}, {Ō}, F(Ō)Ō, chij_send)

o	If both d and (? or !) are possible from given node (Ῡ, Ō, u), then d from the node is not included into LTS (urgent channels).
10.5.	Example of Timed IMDS system – two semaphores
To show the operation of the Timed IMDS specification, the “2 semaphores” system is used. The timed version of the system is presented in Fig. 10.9. Several types of time constraints are im-posed on the system:
•	The actions duration in proc[1] is a1 to b1 time units, while in proc[2] a2 to b2 time units (lines 18-25 in the code),
•	The actions duration in sem servers is instant (0 time units, lines 10-12 in the code below),
•	The actions duration in r server is 1 time unit (lines 32,33),
•	The time delay of all channels is between 1 and 2 time units.
If the duration of actions in both servers of type proc is equal (a1=a2, b1=b2, lines 2-5), the system operates just like the timeless system described in Section 5.1 (a deadlock occurs). But if one of the servers acts significantly faster than the other one (a2=7, b2=8), the deadlock disappears. This happens because the first server catches two wait operations before the second one issues the first wait. 
The source code of the system with time constraints is given below:
 1. system two_semaphores_t

 2. #DEFINE a1=0
 3. #DEFINE a2=0
 4. #DEFINE b1=1
 5. #DEFINE b2=1

 6. server:	sem(agents A[2];servers proc[2]),  
 7. services	{wait, signal}, 
 8. states	{up, down},
 9. actions	{
10.	<j=1..2>{A[j].sem.wait, sem.up}	-> <0> {A[j].proc[j].ok_wait, sem.down},
11.	<j=1..2>{A[j].sem.signal, sem.down} -> <0> {A[j].proc[j].ok_sig, sem.up},	
12.	<j=1..2>{A[j].sem.signal, sem.up}	-> <0> {A[j].proc[j].ok_sig, sem.up},	
13. };

14. server:	proc(agents A;servers sem[2]),
15. services	{start, ok_wait, ok_sig},
16. states	{ini, first, sec, stop},
17. actions	{
20.	?1 {A.proc.ok_wait, proc.first}	->(a1,b1) {A.sem[2].wait, proc.sec},
21.	?2 {A.proc.ok_wait, proc.first}	->(a2,b2) {A.sem[2].wait, proc.sec},	
22.	?1 {A.proc.ok_wait, proc.sec} 	->(a1,b1) {A.sem[1].signal, proc.first},
23.	?2 {A.proc.ok_wait, proc.sec} 	->(a2,b2) {A.sem[1].signal, proc.first},
24.	?1 {A.proc.ok_sig, proc.first} 	->(a1,b1) {A.sem[2].signal, proc.sec},
25.	?2 {A.proc.ok_sig, proc.first}	->(a2,b2) {A.sem[2].signal, proc.sec},
26.	   {A.proc.ok_sig, proc.sec}	->(a1,b1) {proc.stop},
27. };

28. server:	r(agents A3),	
29. services	{left, right},
30. states	{res},
31. actions	{
32.	{A3.r.left, r.res}	-> <1> {A3.r.right, r.res},	
33.	{A3.r.right, r.res}	-> <1> {A3.r.left, r.res},	
34. };

35. servers sem[2],proc[2],r;
36. agents A[2],A3;	

37. channels {(1,2)}; 

38. init	->	{ 
39.		proc[1](A[1],sem[1,2]).ini,
40.		proc[2](A[2],sem[2],sem[1]).ini,
41.	  	<j=1..2>sem[j](A[1..2],proc[1..2]).up,
42.		r(A3).res, 	

43.	  	A[1].proc[1].start, 
44.		A[2].proc[2].start,	
45.	  	A3.r.left,
46. }.

If a1=a2, b1=b2, the system falls into a deadlock as in timeless verification, but we change the time delay of individual channels, namely between proc2 and the rest of the system:
channels {	(1,2), 
proc[2]->sem(9,10), 
sem->proc[2](9,10)};

then the deadlock disappears. 
10.6.	Example of Timed IMDS system – automatic vehicle guidance system
The example of “intersection”, both in version 3-way and 4-way, can be successfully verified un-der Uppaal. However, the example equipped with time constraints causes memory overrun (8GB). The simpler example of the automatic vehicle guidance system (Chapter 5.4) gives this possibility.
Time constraints applied to CT-IMDS variant are:
•	The time of occupation of the road markers and parking lots (the time duration of the ac-tions changing states occupied to free) is between x and y.
•	The time of traveling between the markers and lots (the time delay of every channel) is between x and y.
The “almost no constraints” model, similar to a timeless system, is achieved by setting x=1 and y=10. This gives a deadlock like in the timeless system described in Chapter 5.4. 
The simultaneous movement of two AMPs, starting almost synchronously, is modeled by the constraints x=1 and y=2. In this situation, the deadlock disappears – the AMPs evade in mark-erM using lotM, but no evading necessity appears in markerE[1] and markerE[2] (time constraints do not allow the AMPs to meet there).
10.7.	Verification of the Production Cell
An attempt to verify the timed version of the Production Cell (section 5.6) failed due to memory overrun. In the literature, some other real time verification approaches, based on synchronous modeling, succeeded [Benghazi Akhlaki et al., 2007] [Behrmann, Cougnard, et al., 2006]. Our fail comes from explicit modeling of asynchronous channels built from two synchronous channels, for every pair (agent, target server). This significantly increases the size of the reachability space for model checking. 
The future implementation of our own timed verifier will be free from such disadvantages, be-cause asynchrony is modeled directly in the succession of actions without any additional con-structs.
In addition, we are currently working on a timed version of the non-exhaustive search in the reachability space in the "2 vagabonds" algorithm (Chapter 11).

2-vagabonds: non-exhaustive verification algorithm
Static deadlock detection methods suffer from space explosion problem. Model checking and other static analysis techniques are very effective in verification, many of them have a linear complexity to the size of the reachability space. However, the elaboration of the space is time-consuming (usually exponential) and takes a large amount of memory.
Some methods fight space explosion: symbolic model checking, abstraction etc. There are also methods that give an approximate solution, based on non-exhaustive heuristics for finding deadlocks. Some of them are discussed below. Finding a deadlock proves its existence, the lack of finding a does not guarantee its absence. Nowadays, we are used to such techniques in computer science, for example machine learning give both false positive and false negative solutions [Batista et al., 2004]. 
There are several non-exhaustive verification methods. Three of them are described in multiple papers: Ant Colony Optimization - ACO [Francesca et al., 2011], Genetic Algorithms - GA [Godefroid and Khurshid, 2002] and A* search [Francesca et al., 2011] (they are mixed in some solutions). The methods consist in construction of many reachable paths, hoping that at least one of them reaches a deadlock. Non-exhaustive methods were developed originally for other purposes, therefore some elements of them are useless. For example, drawing the chromosome genes (system transitions play this role) does not guarantee the construction of a reachable path. In addition, those methods use sets of parameters which values are not obvious. In GA, they are: population size, chromosome length, gene crossing manner, mutation rate, fitness function, etc. In ACO there are number of ants, pheromone evaporation rate, parameters for pheromone deposit etc. It is not easy to define the parameter values for a given case. 
All algorithms based on the construction of paths have a general drawback: similar beginning of the paths. The reachability space is often extremely branched, but its initial part consists of only several subpaths. Therefore, the initial subpaths occur in multiple generated paths. In addition, many systems contain a starting part, in which the initial activities are performed (we call it leader [Daszczuk, 2018]). A deadlock-free leader occurs in all paths without purpose (from the point of view of deadlock detection).
The methods described above do not distinguish between deadlocks and termination, as described in Chapter 2. For example successful termination of solitaire game is found just as if it were a deadlock [Gradara et al., 2006]. 
The advantages of the mentioned algorithms are:
	Paths are constructed dynamically as the algorithm runs, so the global reachability space need not be elaborated.
	The successful path (leading to the deadlock) is a ready-to-use counterexample, while in the case of exhaustive search, the path from the initial node to the deadlock must be found.
Finding deadlocks using those methods is very effective, but we think it should be extended. Distributed IoT systems contain reactive servers that offer a variety of services and operate in infinite loops, and device controllers perform certain coordinated behavior, then finish their work. In such systems, the deadlock may not be total. In addition, total distributed termination is not expected because of looping servers. Instead, a partial deadlock and termination are very much needed to be verified. However, concurrency degree in such systems is even greater than in centralized systems, because some services are often spread over distributed servers.
The mentioned papers on heuristic methods show deadlock detection in several benchmarks (most often Dijkstra philosophers [Dijkstra, 1959]). The drawback of the papers is that they exhibit detection when the result is known in advance. However, in practice, the user is interested in verifying the system in which the result is unknown. That is the sense of verification. The papers do not describe such procedures, especially the time of verification of deadlock-free system is not given.
That’s why we needed an efficient algorithm for partial deadlock and partial termination verification, using a non-exhaustive search. We developed our own algorithm which has the following features:
	Location of partial deadlocks that are not just nodes without outgoing transitions.
	Distinguishing deadlocks from distributed termination.
	Having as few parameters as possible, preferably zero.
	Generating of leader subpaths less often than for all generated paths.
This former two features are achieved thanks to the definition of partial deadlocks in the IMDS, which consists in general temporal formulas, unrelated to the structure of verified system. The formulas for distributed termination differ from the deadlock formulas. The latter two features are achieved as specific properties of the new algorithm, which is based on wandering through reachability space, constructed on-the-fly. Since each search consists of two phases, which can run almost independently, we call the algorithm 2-vagabonds. 
The new algorithm searches the reachability space in two phases. The first phase searches for nodes in which a subset of processes are disabled, the second phase checks if these processes can be enabled in the future. Because both phases use non-exhaustive search, the result is unsure and both false positives and false negatives are possible. This is typical for non-exhaustive search, for example in [Godefroid and Khurshid, 2002] the authors agree to lose the proper result in up to 70% cases.
Related work
State space explosion is the main obstacle in model checking. There are many methods to decrease this feature, such as symbolic model checking [E. Clarke et al., 1996], bounded model checking [Jard and Jéron, 1992], compositional model checking [E.M. Clarke et al., 1989][Santone, 2002], local model checking [Stirling and Walker, 1991], partial order reduction [Gerth et al., 1999], abstraction [Edmund M. Clarke et al., 1994] and slicing [Hatcliff et al., 2000].
A non-exhaustive search fights the explosion problem at the expense of uncertainty of the result. There are three main methods: Ant Colony Optimization (ACO), A* graph search, and Genetic Algorithms (GA).
ACO solutions are rather optimization algorithms than search ones [Francesca et al., 2011][Chicano and Alba, 2008]. They work like an ant, which if finds a target, i.e. a deadlock or termination, puts a pheromone that directs other ants. Therefore, ACO is ideal for finding shortest counterexample after finding a deadlock. However, during the verification, it is difficult to determine which path more likely leads to a deadlock than another path. If the ACO algorithm is used for search rather than for optimization, some paths must seem more attractive to ants than other paths.
In [Alba and Chicano, 2007], the heuristic is used that prefers a large number of enabled transitions in each node (configuration in our IMDS formalism). It is not explained why this should lead to a deadlock faster. Indeed, in that paper three benchmarks out of five give worse results for the described heuristic version than the basic one (in memory usage and in verification time). 
A* uses the heuristic evaluation function, associated with each node or transition [Francesca et al., 2011][Gradara et al., 2006]. The applied heuristic must be admissible, i.e., it must underestimate the cost. The algorithm prefers paths that seem better, following nodes or transitions with a lower value of the evaluation function, which should accelerate the achievement of the goal. It is difficult to define a function that prefers paths leading to an unknown deadlock. In [Gradara et al., 2006], such a heuristic is proposed for specification in CCS [Milner, 1980], with the preference for deadlocks of communication operations. The heuristic is addressed to total deadlocks. The formalism of CCS is synchronous, which in our opinion is inadequate for modeling distributed systems. 
[Gradara et al., 2006] proposed a Greedy algorithm, similar to A*, using a non-admissible heuristic. It tends to find quite short (but not optimal) counterexamples faster than A*. 
Genetic Algorithm generates paths of execution as chromosomes [Godefroid and Khurshid, 2002] [Alba and Troya, 1996] [Yousefian et al., 2014]. Genes are choices of transitions between nodes (configurations in IMDS). The above problems with evaluating transitions in ACO and A* are similar to the troubles with the fitness function of the chromosomes in GA. If we investigate for a deadlock, finding it simply finishes the algorithm and no further path evaluation is needed. If we search for a counterexample having given features (for example length), a more subtle evaluation is needed. For example, reinforcement learning applied to GA is described in [Pira et al., 2017].
 2-vagabonds algorithm
Total deadlock
We begin the description of our new algorithm with total deadlock detection, which requires only one vagabond. The rules are as follows:
	A path from the initial configuration is constructed. The path consists of configurations connected by actions. The path is constructed from actions one after the other, with a random selection of the action among the actions enabled in the configuration. In the configuration T, the action (m,p)(m’,p’) is enabled if {m,p}T.
	If the deadlocked configuration is reached, the algorithm stops.
	If a configuration already in the path is found, it means a loop. In this situation, the path is truncated by a random number of configurations. From the last configuration of the truncated path, the action is selected randomly, excluding the recently used action. If only one action is enabled in the configuration, the path is truncated again (by one configuration).
Note that the algorithm is extremely simple and does not contain any parameters. However, to successfully run it, one parameter is needed: how long must we construct a path if no deadlock is found. Our first attempt was to limit the number of algorithm steps (number of path extensions) to N:
for server deadlocks: N=card()*〖log〗_2⁡〖(∏_(k=1)^n▒〖〖card(s〗_k)〗〗)* log_2⁡〖(n〗)* log_2⁡〖(m〗)  ,	(11.1)
for agent deadlocks and termination: 
	 N=card()*〖log〗_2⁡〖(∏_(k=1)^m▒〖〖card(a〗_k)〗〗)* log_2⁡〖(n〗)* log_2⁡〖(m〗)  ,
where sk is the set of actions of the server process sk, ak is the set of actions of the agent process ak, nS and nA are the number of servers and the number on agents, respectively. The formulas say that we take the number of actions multiplied by the logarithm of the product of the numbers of actions in individual server (or agent) processes, and multiplied by logarithms of the number of servers and the number of agents. The factor after card() comes from the assumption, that overall server states communicate in pairs, but not every pair. The logarithm comes from the assumption that the more states, the smaller part of their pairs communicate. The last two factors result from the assumption that servers communicate in pairs and agents communicate in pairs.
However, in some cases we found a few false negatives, i.e., existent deadlock not found. We introduced the parameter D, which is the factor by witch the value N is multiplied. We suggest D=4, because it is sufficient for most searches concerning single-process deadlock or termination. Searching for a total deadlock requires a larger D in some cases.
In the total server (communication) deadlock, all server processes take part. In the total agent deadlock, all non-terminated agent processes participate.
Vagabond (set of all nodes S): // or all agents A
insert initial configuration T0 do a path ;
loop
{
	take a configuration T finishing a path ;
	if (no sS enabled in T) halt(total deadlock); // or all aA
	if (exist actions T prepared in T)
	{
		draw an action T;
		if ( leads to a configuration T) // a cycle detected
		{
			cut a random number of configurations from path ;
			while (last configuration TlastT0 in path  has one prepared action)
				cut Tlast from path ;
			exclude an action drawn previously in new Tlast from next draw;
		}
		else add T to the path ;
	}
	else
	{
		cut a random number of configurations from path ;
		while (last configuration TlastT0 in path  has one prepared action)
			cut Tlast from path ;
		exclude an action drawn previously in new Tlast from next draw;
	}
}
until (D*N steps completed);
halt(no total deadlock);
Partial server deadlock (communication deadlock)
Recall the server deadlock definition for a single server (Section 3.7): no action is prepared in the server while there are pending messages at the server. If a partial deadlock for a subset of server processes is searched, the situation must concern all servers in the subset. We use two vagabonds to detect server deadlock. For a given set of servers, first vagabond searches for configurations in which no action is prepared for any server in the subset, and each server in the subset has a pending message. Therefore, 1st vagabond starts the 2nd vagabond from this configuration to check if any of the servers will be enabled in the future. Starting from this configuration, the second vagabond searches for a configuration in which in a server belonging to the set has an enabled action. If no such configuration is found, a partial server deadlock occurs. 
In the algorithm, parts specific to server deadlock detection are marked by a box (■).
1st_vagabond (set of selected nodes Sx):
insert initial configuration T0 do a path 1;
loop
{
	take a configuration T finishing a path 1;
■	if (no sS enabled in T) halt(total deadlock); // implies partial deadlock
■	if (no sSx is enabled but messages to all sSx are in T)
		start 2nd vagabond from T;
	if (exist actions T prepared in T)
	{
		draw an action T;
		if ( leads to a configuration T1) // a cycle detected
		{
			cut a random number of configurations from path 1;
			while (last configuration TlastT0 in path 1 has one prepared action)
				cut Tlast from path 1;
			exclude an action drawn previously in new Tlast from next draw;
		}
		else add T to the path 1;
	}
	else
	{
		cut a random number of configurations from path 1;
		while (last configuration TlastT0 in path 1 has one prepared action)
			Cut Tlast from path 1;
		exclude an action drawn previously in new Tlast from next draw;
	}
}
until (N steps completed);
wait until (2nd vagabond works);
if (2nd vagabond found a configuration in which an sSx is enabled)
	halt(no partial deadlock);
else halt(partial deadlock);

2nd vagabond:
Tstart is a starting configuration for 2nd vagabond
insert starting configuration Tstart do a path 2;
loop
{
	take a configuration T finishing a path 2;
■	if (all sS not enabled)
■		return(partial deadlock found);
■	if (exist sSx enabled)
■		return(no partial deadlock);
	if (exist actions T prepared in T)
	{
		draw an action T;
		if ( leads to a configuration T2) // a cycle detected – backtracking
		{
			cut a random number of configurations from path 2;
			while (last configuration TlastT0 in path 2 has one prepared action)
				cut Tlast from path 2;
			exclude an action drawn previously in new Tlast from next draw;
		}
		else add T to the path 2;
	}
	else return(partial deadlock found);
}
until (D*N steps completed);

Partial agent deadlock (resource deadlock)
An agent is deadlocked if its current message is pending, but it will never cause an action. Two vagabonds are used again. For a given set of agents, the first vagabond searches for configurations in which no action is enabled for any agent in the set, and no agent in the set is terminated. Starting from this configuration, the second vagabond searches for a configuration in which an action is enabled in an agent belonging to the set. If no such configuration is found, an agent deadlock occurs. 
The differences between server deadlock and agent deadlock detection are as follows:
1st_vagabond (set of selected agents Ax):
…
■	if (no aA enabled) halt(total deadlock); // implies partial deadlock
■	if (no aAx is enabled nor terminated in T)
…
if (2nd vagabond found a configuration in which an aAx is enabled)
…

2nd vagabond:
…
■	if (all aA not enabled)
■		return(partial deadlock found);
■	if (exist aAx enabled)
■		return(no partial deadlock);
…
Partial distributed termination
Distributed termination of a subset of agents is successful if all agents in the subset reached their terminating actions. The vagabonds search for:
	Total deadlock – in this case the termination is not achieved.
	A partial deadlock with at least one agent belonging to the subset. The partial deadlock is identified in the same way as in partial agent deadlock detection above, using the same second vagabond as in the case of a partial agent deadlock. If such a partial deadlock is found, the termination is refuted.
	A state in which agents in the subset are all terminated.
In the two former cases, the termination is unsuccessful. In the latter case, the termination is achieved but it does not guarantee that it is inevitable. Therefore, after finding the configuration in which the agents belonging to the subset terminate, a new search begins. After reaching of D*N steps of verification, the algorithm is continued to complete the last search. Four situations can occur:
	Total deadlock (as before) – no termination.
	Partial deadlock (as before) – no termination.
	Termination of all agents in the set – this finally confirms distributed termination.
	None of the above occurred in D*N steps plus final search – no termination.
1st_vagabond (set of selected agents Ax):
insert initial configuration T0 do a path 1;
loop
{
	take a configuration T finishing a path 1;
	if (no aA is enabled but there exists aAx not terminated) 
		return(partial deadlock found);
	if (all aAx terminated in T)
	 if (current step > D*N) return (partial termination);
	 else { shrink 1 to T0, begin new search; }
	else if (no agent in Ax is enabled)
		start 2nd vagabond from T;
	if (exist actions T prepared in T)
	{
		draw an action T;
		if ( leads to a configuration T1) // a cycle detected – backtracking
		{
			cut a random number of configurations from path 1;
			while (last configuration TlastT0 in path 1 has 1 prepared action)
				cut Tlast from path 1;
			exclude an action drawn previously in new Tlast from next draw;
		}
		else add T to the path 1;
	}
	else
	{
		cut a random number of configurations from path 1;
		while (last configuration TlastT0 in path 1 has one prepared action)
			cut Tlast from path 1;
		exclude an action drawn previously in new Tlast from next draw;
	}
}
until (D*N steps completed from last termination found);
wait until (2nd vagabond works);
if (2nd vagabond found a configuration in which an aAx is enabled)
	halt(no partial termination);
else halt(partial termination);
Heuristics
We tried to speed up the search in our algorithm. We found out that having some actions disabled in a process, it can lead to a deadlock in effect. Therefore, we increase the probability of selecting transitions leading to configurations with some nodes/agents disabled. We assign the weight to each action outgoing from a configuration: 
	0 – if the backtracking is executed because of a loop: 0 is used for the recently used action,
	1 – otherwise, but:
	d – if there are d disabled processes in the target configuration of the action,
	e – if there are e disabled processes in the target configuration of the action, for the processes belonging to the subset for which a partial deadlock is investigated.
All weights are summed for a given action (1+d+e). After assigning the weights, the sum for all actions is normalized to 1, and all action weights are normalized accordingly, which gives the probability of taking individual actions.
Indeed, heuristics are accelerating the finding of deadlock in some cases. Even more important is the fact that there are cases (for example 15 philosophers, see below) in which the deadlock cannot be found in 4*N steps without heuristics.
Verification
Our algorithm finds partial deadlocks, but it is not known in advance which processes fall into deadlocks and which do not. Our typical procedure is as follows:
	Check the total deadlock: the partial deadlock into which all processes fall.
	If the first verification does not show deadlock, check whether the individual processes fall info a deadlock. The result of such verification in the Dedan program, in which not all processes fall, is presented in Fig. 11.1a. In this verification, the "together" checkbox in the upper right corner is turned off.
	If there are processes that fall into the deadlock individually, switch the checkbox “together” on and select only deadlock-prone processes for verification (checkboxes on the left), it is shown in Fig. 11.1b. If the processes do not fall into a common deadlock, the result “Deadlock” changes to the result “Ok”. In this example, the result “Deadlock” is preserved, which means that it is a common partial deadlock of processes T, R and C.
 a)
 b)

Fig. 11.1.  a) finding processes falling into a deadlock individually; b) verification if they fall into a common deadlock.
Experimental results
The benchmarks
The algorithm was tested on a set of benchmarks. The first group contains models which can be verified using an exhaustive search: 
	“1” – a simple system in which each agent can fall into a deadlock due to lack of resources. It is an interesting example, because in this system the agent falls into the resource deadlock, but no server falls into the communication error. What’s more, each agent can fall into a deadlock separately, but a set of more than one process never falls into a common deadlock. 4 servers, 2 agents.
	“2sem” – 2 semaphores, (Section 5.1) two agents from their own servers invoke P and V on two semaphores, if they call agreeably - no deadlock occurs (“2sem-agr”). Otherwise they call P crosswise – the deadlock is obvious (“2sem-cross”). 5 servers, 3 agents. The deadlock is partial, because the third process doing something else is added.
	“PhX” – Dijkstra philosophers [Dijkstra, 1959] (Section. 5.2), X is their cardinality; every philosopher agent resides on its own server-chair and calls two fork servers: left and right. Chairs and forks are servers (2X), philosophers are agents (X). Server deadlock is partial (chair servers are not deadlocked), while agent deadlock is total.
	In addition, three deadlock-free solutions from Section 5.2 are verified: asymmetrical – philosophers take their forks in undefined order, and two of them take in specified order: one take his left fork first, while the other one takes his right fork first (“PhX-asym” – 2X servers, X agents); with butlers (“PhX-butlers” – 2X+2 servers, X agents); taking 2 forks or none (“PhX-2orNo” – 2X+1 servers, X agents). Butlers and locker for taking 2 forks at once are additional servers.
	“PCX” – Karlsruhe Production Cell [Daszczuk, 2019a] (Section 5.6), a set of devices supplying blanks (agents) to be forged in the press, and then taking them back, X is the number of blanks. Blanks are not forged in fact, so they are recycled back in the loop. With proper control no deadlock occurs. Every device in the cell is a server (11 in total), and every blank is an agent. In addition, some technical agents are used to return the devices to the rest position after transporting a blank. There are X+6 agents in total.
	If the above system is tested in an open loop (“PCXopen”), in which the blanks are taken from the container are they are dropped out after forging, a deadlock occurs because the robot exchanges the forged blank with the next one, and the last blank has no pair to exchange with. The press falls into the server deadlock, and, consequently, all devices equipped with technical agents fall into the deadlock. The deadlock is partial because other devices simply remain idle. Each blank falls into the agent deadlock (because the order in which the blanks are entered into a system is arbitrary), but separately. Never two or more blanks fall into the common deadlock, because only one blank is stuck in the press. Therefore, the agent deadlock is total if X=1, and partial if X>1.
	“Intersection” – Section 5.3: 4 crossing quarters and 4 commuter roads are modeled. Vehicles (agents) can take any direction: left, right, straight or turn back. The full model exceeds available memory, which is why the simplified models are verified: with all vehicles driving straight (“Cross-straight”), falling into a deadlock, and all vehicles driving right (“Cross-right”), without deadlock. Every quarter and every commuter road is a server, the vehicles are modeled as agents. Thus, the server deadlock in the former model is partial (commuter roads do not fall into a deadlock), and the agent deadlock is total (all four vehicles fall).
	“AVGS” – Automated Vehicle Guidance System [Czejdo et al., 2016] (Section 5.4), the vehicles (agents) are led by road segment controllers (servers). The aim of each vehicle is to achieve the opposite utmost position, but common two-way segments may lead to a deadlock. The basic solution for 6 servers and 2 agents is deadlock-prone. As with “Cross-straight”, the server deadlock is partial (only two road segments holding the vehicles are involved, others are idle) and the agent deadlock is total.
	Some other deadlock-free structures of AVGS are used: backing up (“AVGS-goBack” – 6 servers, 2 agents), using the overtaking shunt (“AVGS-turnout” – 4 servers, 2 agents) and changing the vehicles’ decision using alternative paths (“AVGS-twoWays” – 4 servers, 2 agents).
	“buf” – bounded buffer (Section 9.1) with X elements, Y users (“buf-XxY” [Daszczuk, 2019b]) – users are both producers and consumers, switching between the roles randomly. If everyone chooses to get from an empty buffer, or if everyone chooses to put to a full buffer, a deadlock occurs.   
The second group of benchmarks contains models that cannot be exhaustively verified (the reachability space exceeds the available memory), but the result is known in advance, because they are extensions of problems in first group:  “PhX” – for X=6 and more philosophers, “PCX”  - for X=4 and more blanks, “PCXopen” – for X=7 or more blanks, “Cross-all” for road crossing with vehicles taking arbitrary direction: left, right, straight or turn back.
The third group of examples are student solutions of synchronization exercises. The result is unknown in advance in these cases. Some of them cannot be verified exhaustively. 
Results
The results of deadlock detection are collected in Table 11.1. The deadlock is investigated for every process separately, so number of steps visited by the vagabonds and verification time are given in the average for one server/agent (except for the total deadlock detection). The column “type” specifies the type of deadlock – communication deadlock of servers or resource deadlock of agents. The letter “t” means finding a total deadlock. All numbers are rounded to 1 digit after point, and all times are rounded to the full seconds. 
In some examples, exhaustive verification is compared with 2-vagabonds.
Table 11.1 – deadlock detection
Model	type	Exhaustive search	2-vagabonds
		Configuration space (thousands)	space creation time [h:m:s]	verif. Time for 1 node/ agent
[h:m:s]	D*N 
(thousands)	Avg steps in verification 1st vagabond 
(thousands)	Avg steps in verification 2nd vagabond 
(thousands)	verif. Time for 1 node/ agent
[h:m:s] 
1 	servers	0.0	1	0	1.7	1.3	0.4	0
1 	agents	0.0	1	0	1.2	0.1	1.2	1
1 	agents t	0.0	1	0	1.2	1.2	0.2	1
2sem-cross	servers	1.2	1	0	6.3	0.1	6.3	1
2sem-cross	servers t	1.2	1	0	6.3	0.1	6.3	1
2sem-cross	agents	1.2	1	0	4.6	0.1	4.6	1
2sem-cross	agents t	1.2	1	0	4.6	0.1	4.6	2
Ph3	servers	1.2	1	0	27.4	0.1	0.3	1
Ph3	servers t	1.2	1	0	27.4	0.4	0.2	0
Ph3	agents	1.2	1	0	17.8	0.0	0.0	0
Ph3	agents t	1.2	1	0	17.8	0.2	0.2	1
Ph4	servers	12.7	17	0	47.4	0.5	3.4	6
Ph4	servers t	12.7	17	0	47.4	0.9	0.6	1
Ph4	agents	12.7	17	0	31.0	0.2	1.5	3
Ph4	agents t	12.7	17	0	31.0	0.1	0.0	0
Ph5	servers	135.2	1:06:07	2	150.5	0.2	0.8	1
Ph5	servers t	135.2	1:06:07	0	150.5	0.3	0.2	1
Ph5	agents	135.2	1:06:07	4	100.3	0.2	2.3	3
Ph5	agents t	135.2	1:06:07	0	100.3	0.2	0.5	0
Ph10	servers				988.0	5.7	241.7	1:05
Ph10	servers t				988.0	26.9	12.2	12
Ph10	agents				653.6	6.7	660.2	3:30
Ph10	agents t				653.6	60.5	29.4	23
Ph15	servers				2 211.6	14.8	2 258.8	2:34:44
Ph15	agents				1 459.2	32.0	6 091.4	31:50
Ph18	servers				4 801.7	36.3	9 245.4	12:56:28
Ph18	agents				3 160.1	15.2	1 532.0	3:22:08
PC5open	servers				576.0	0.2	0.3	1
PC5open	agents				489.6	0.2	0.3	1
PC10open	servers				1 364.2	0.4	0.5	1
PC10open	agents				1 698.2	0.4	0.5	3
PC15open	servers				2 786.4	0.7	0.6	1
PC15open	agents				4 540.8	0.7	0.7	7
Cross-straight	servers	47.4	4:42	0	794.1	0.1	0.1	0
Cross-straight	agents	47.4	4:42	0	506.9	0.2	0.2	1
Cross-all	servers				865.5	0.3	0.1	1
Cross-all	agents				547.6	0.8	1.7	6
AVGS	servers	0.0	3	0	5.8	0.0	0.0	0
AVGS	agents	0.0	3	0	4.5	0.0	0.0	1
Buf-3x3	servers	0.5	0	0	5.3	0.0	0.0	0
Buf-3x3	agents	0.5	0	0	4.8	0.0	0.0	0
Buf-6x6	servers	109.4	1:08:48	0	65.7	0.3	0.1	0
Buf-6x6	agents	109.4	1:08:48	0	82.9	0.2	0.0	0
Buf-10x10	servers				430.1	0.2	0.0	1
Buf-10x10	agents				706.6	0.6	0.2	2

Table 11.2 contains the results of verifying deadlock-free processes. Some benchmarks are included in both tables 11.1 and 11.2, because in these cases we have processes falling into a deadlock and deadlock-free ones in the same model. The column containing the number of steps for the 1st vagabond is suppressed, because in deadlock-free search this number of steps is exactly maximum number of steps (D*N).
Table 11.2 – Safety from deadlock
Model	type	Exhaustive search	2-vagabonds
		Configuration space (thousands)	space creation time [h:m:s]	verification time for 1 node/agent
[h:m:s]	D*N
= steps in verification 1st vagabond (thousands)	Avg steps in verification 2nd vagabond (thousands)	verification time for 1 node/agent
[h:m:s] 
1 	servers	0.0	1	0	1.7	0.0	0
2sem-agr	servers	0.1	1	0	6.3	0.0	0
Ph3	servers	1.2	1	0	27.4	0.0	1
Ph4	servers	12.7	17	0	47.4	0.0	2
Ph5	servers	135.2	1:06:07	0	150.5	0.0	11
Ph10	servers				988.0	0.0	4:15
Ph15	servers				2 211.6	0.0	14:49
Ph3-2orNo	servers	3.2	4	0	81.4	64.8	5:34
Ph3-2orNo	agents	3.2	4	0	44.9	145.0	11:21
Ph3-asym	servers	0.6	0	0	22.8	24.3	1:05
Ph3-asym	agents	0.6	0	0	15.6	39.6	2:05
Ph3-butlers	servers	10.3	10	0	66.8	13.2	27
Ph3-butlers	agents	10.3	10	0	34.6	28.8	1:04
Ph4-2orNo	servers	31.5	2:46	0	184.7	123.8	9:40
Ph4-2orNo	agents	31.5	2:46	0	109.8	455.6	32:25
Ph4-asym	servers	6.1	3	0	40.8	80.8	2:48
Ph4-asym	agents	6.1	3	0	27.7	159.4	2:46
Ph4-butlers	servers	250.3	2:58:50	0	175.1	44.0	1:24
Ph4-butlers	agents	250.3	2:58:50	0	96.8	102.7	3:41
Ph5-2orNo	servers	295.0	4:48:03	31	430.6	243.2	18:44
Ph4-2orNo	agents	295.0	4:48:03	19	252.7	1 183.1	1:21:49
Ph5-asym	servers	63.6	11:14	0	86.7	738.0	13:02
Ph5-asym	agents	63.6	11:14	1	86.7	722.5	12:43
Ph5-butlers	servers				441.6	159.8	5:32
Ph5-butlers	agents				259.2	362.9	10:10
PC3	servers	117.5	1:03:04	1	282.6	1 108.2	29:39
PC3	agents	117.5	1:03:04	44	273.8	3 899.9	1:59:29
PC4	servers				431.1	23.4	47
PC4	agents				260.3	2 036.5	33:16
PC5	servers				588.8	1 285.3	25:14
PC5	agents				515.2	4 736.5	1:12:09
Cross-right	servers	74.0	18:21	0	794.1	73.2	10:0
Cross-right	agents	74.0	18:21	0	506.9	405.8	18:11
AVGS-goBack	servers	0.4	3	0	112.5	1.1	23
AVGS-goBack	agents	0.4	3	0	51.1	15.6	1:19
AVGS-turnout	servers	0.1	0	0	12.7	7.7	4
AVGS-turnout	agents	0.1	0	0	7.7	9.2	29
AVGS-twoWays	servers	0.2	0	0	17.6	0.2	3
AVGS-twoWays	agents	0.2	0	0	11.1	3.4	17

Table 11.3 contains the results of the termination checking. Both positive and negative examples are included. Negative result outcomes from falling a process in the set into a deadlock or infinite looping without termination.
Table 11.3 – termination
Model	Yes/Not	Exhaustive search	2-vagabonds
		Configuration space (thousands)	space creation time [h:m:s]	verification time for 1 node/agent
[h:m:s]	D*N
= steps in verification 1st vagabond (thousands)	verification time for 1 node/agent
[h:m:s] 
1 	Yes/Not	0.0	1	0	1.2	0
2sem-agr	Yes	0.1	1	0	4.6	28
Ph3	Not	1.2	1	0	17.8	1
Ph4	Not	12.7	17	1	31.0	3
Ph5	Not	135.2	1:06:07	2:29	100.3	16
Ph10	Not				653.6	1:44
Ph15	Not				1 459.2	47:12
Ph3-2orNo	Not				44.9	11:22
Ph3-asym	Not				15.6	1:54
Ph3-butlers	Not				34.6	1:07
Ph4-2orNo	Not				109.8	32:25
Ph4-asym	Not				27.7	4:11
Ph4-butlers	Not				96.8	3:42
Ph5-2orNo	Not				86.7	1:21:58
Ph5-asym	Not				109.8	12:53
Ph5-butlers	Not				259.2	10:16
AVGS	Not	0.0	3	0	11.1	0
AVGS-goBack	Yes	0.4	3	0	51.1	20
AVGS-turnout	Yes	0.1	0	0	7.7	3
AVGS-twoWays	Yes	0.2	0	0	11.1	16
Buf-3x3	Not	0.5	0	0	4.8	0
Buf-6x6	Not	109.4	1:08:48	60	82.9	0
Buf-10x10	Not				706.6	2

Table 11.4 shows the results of student exercise verification. In such cases, the result is not known in advance. “Servers dd” denotes node deadlock search while “Agents dd” denotes agent deadlock search.
Table 11.4 – student exercises
student	type	result	D*N
	steps in verification 1st vagabond (thousands)	steps in verification 2nd vagabond (thousands)	verification time for 1 node/agent
[h:m:s] 
						
Stud 1	Servers dd	partial dd	787.3	393.8	1 721.0	16:47
Stud 1	Agents dd	total dd	387.0	0.2	1.8	2
Stud 2	Servers dd	partial dd	5 888.0	3 728.0	0.9	18:10
Stud 2	Agents dd	total dd	4 416.0	0.2	1.8	3
Stud 3	Servers dd	safe	988.0	988.0	3 728.0	46:41
Stud 3	Agents dd	safe	4557.8	557.8	6 810.1	1:29:57
Stud 4	Servers dd	safe	930.8	930.8	33 0306.3	23:46:39
Stud 4	Agents dd	safe	160.0	160.0	732.9	15:13

One of the main assumptions in design of 2-vagabonds algorithm is avoiding repeatedly investigating of leader subpaths. Fig. 11.2 illustrates this. The number of steps in the algorithm runs is divided into segments of length being consecutive powers of two, minus numbers of steps in previous segments. This gives “nominal” numbers of steps in segments 1,1,2,4,8,16,32,… . The numbers of steps in other algorithms give the same powers of 2, multiplied by the number ants in ACO/ individuals in GA etc. For example, the ACO algorithm running 10 ants forth and back 100 times has the following numbers of steps in the segments: 1000, 1000, 2000, 4000, 8000, etc. Genetic algorithm with 100 individuals and 100 generations has: 10000, 10000, 20000, 40000, 80000, etc. For the mentioned algorithms, the numbers of steps divided by nominal numbers of steps gives equal numbers in all segments, for example for a single path 1,1,1,1,1,1,… . Exemplary segments from 2-vagabonds verification of 3 philosophers in server deadlock verification contain 3,5,7,19,41,23,9 steps in individual segments. These values divided by nominal numbers of steps (1,1,2,4,8,16,32) give 3,5,4,5,5,1,0 (rounded to integers). Taking the number of steps in the first segment as 1, we get numbers of steps in consecutive as segments shown in Fig. 11.2, separately for 1st vagabond, absolute paths of 2nd vagabond and relative paths for 2nd vagabond. The absolute path consists of a subpath from the initial configuration T0 to starting configuration Tstart of 2nd vagabond plus the own path of 2nd vagabond. The relative path is the own 2nd vagabond path. The plots show that in some cases the numbers of steps decrease: this results from many short loops. In other cases, the assumption of avoiding frequent investigation of leader subpaths is fulfilled (the plots grow, than fall, or grow to their end). Plots for absolute path in 2nd vagabond grow rapidly, sometimes up to thousands.
Verifications of server deadlock (Servers dd), server-deadlock free (Servers not dd) and agent deadlock (Agent dd) are presented for 3, 10 and 15 philosophers in Fig. 11.2. 
 
 
 
Fig. 11.2. Number of steps in individual segments in various verifications.
Parallel verification
In sequential implementation, the 1st vagabond starts the 2nd one in certain situations, and waits for the result of 2nd vagabond run, then continues or cuts 1st vagabond progress depending on the result of 2nd vagabond search. However, various types of concurrent computations can be applied.
	First and second vagabond can run in parallel. When the second vagabond search is to be launched, and the previous one is not finished yet, the first vagabond is suspended.
	Alternatively for suspending first vagabond, a buffer between first and second vagabond can be established. This prevents the second vagabond from starting frequently, which is expensive (starting a new process or thread). The solution with a buffer between one 1st type vagabond and one 2nd type vagabond is used in our implementation of the algorithm in the Dedan program.
	An important feature of the 2-vagabonds algorithm is that multiple vagabonds of 1st and 2nd type can be launched. They run independently, except that finding a deadlock (or lack of termination) by a single vagabond should stop the run of all vagabonds. Of course, a number of vagabonds highly exceeding the number of available processors is useless.
	The configurations in the search path are elaborated on the run, therefore the input of the algorithm consists only of the definition of a set of actions. The input can be easily spread over a set of distributed computers to run several vagabonds in parallel. Both 1st and 2nd type vagabonds can be started in distributed way. Again, the whole set of vagabonds must be stopped after identifying the deadlock (or lack of termination). This solution is planned as the next step of the development of Dedan.
Limitations
The exhaustive search is proof of the verified feature. A non-exhaustive search may, in its nature, leave given features unverified. The methods mentioned in related work (Section 11.1) leave some uncertainty. If we treat finding a deadlock or a distributed termination as a positive result, false positive cannot happen. If a deadlock or termination is found, it is proved. However, a false negative may happen, i.e., existing deadlock or termination may not be found. We never have proof that the entire reachability space is searched, even if we tested more states than fully connected graph of possible configurations:
	N_max=∏_(k=1)^n▒〖〖card(s〗_k)〗*∏_(k=1)^m▒〖〖card(a〗_k)〗	(11.2)
If we want to be sure that all reachable configurations are searched, we must build a full reachability space and mark every visited configuration. In the case of a partial deadlock and partial termination, we can also be sure that every reachable transition (an action between a given pair of configurations) is visited. This makes heuristic search senseless.
The search for partial features (deadlock and termination) gives another dimension of uncertainty: false positive is also possible. Recall that in the deadlock detection, after finding a configuration if which a process is not enabled, we search for a configuration in which it is enabled in the future. If we fail to find such a configuration, the decision is made on deadlock freeness of this fragment of reachability space (and the search is continued if D*N is not reached). 
For an exhaustive search, the memory size is the main limitation. We can use reduction techniques, for example symbolic model checking, compositional model checking, abstraction techniques, bounded model checking, etc., We can also use partial order reduction. All those treatments, as well as increasing the memory size, shift the size limit of the verified models, but it always exists. The time of building the reachability space is also important, but one can say that we only need to wait enough time.
In the non-exhaustive model checking, we switch memory limits to time limits. The question is: how long can we wait for the result? The longer we wait, the greater is our sureness that the result is right. To get more confidence in the result, we should extend the verification time. Look at deadlock detection in the case of philosophers problem: we tested a partial deadlock for every process (server or agent) in the sequence. We can ask for searching a more general deadlock, in which all the forks participate (chairs are not prone to deadlock). Or, alternatively, we can test the total deadlock of all agents (philosophers). In our formalism, the total deadlock (or deadlock concerning all processes of a given type, such as for the forks) is simply a partial deadlock in which a set of processes take part (possibly all). 
Surprisingly, the verification of common deadlock of all forks or all philosophers gives a false negative result (deadlock freeness is reported) for 15 philosophers. This is due to the fact that finding a configuration in which all processes are disabled is easier when the set is smaller. We can comfort ourselves that finding a partial deadlock is an important result, because each type of deadlock should be analyzed and repaired (both partial and total). We can also trust that by eliminating the partial deadlock we also remove the possible deadlock comprising more processes, maybe a total deadlock. Otherwise, we can increase the factor D. However, hasty changing of D should be avoided because it affects the verification time, mainly in deadlock-free examples.
We must remember that if multiple processes fall in partial single-process deadlocks, they not necessarily fall into a common deadlock. This concerns especially deadlocks owing from lack of resources, as in example “1”. This example shows that every agent is prone to deadlock, but never together.
In our algorithm we use the function for N (equation 11.1) which grows much slower than Nmax (equation 11.2), due to the use of logarithms. The use of logarithms results from the assumption that in a set of many processes, the dependencies between them do not form a large network of relationships. It is evident, however, that in some cases this function would give to small N, because generally Nmax grows exponentially with number of servers and agents, while N grows logarithmically. Therefore, we should increase the D factor to be more certain about verification results. We must also remember that finding partial deadlocks gives a more reliable result.
The time complexity of the proposed 2-vagabonds algorithm (for the sequential version) depends on N and the factor D. For 1 vagabond (total deadlock detection) it is O(D*N). For partial deadlock detection it is O((D*N)2), because for every configuration of the 1st search, the 2nd vagabond can search D*N configurations. For termination detection, the last search for a terminating action may exceed D*N with one more D*N, and the second vagabond searches similarly to deadlock detection, so the complexity is again O((D*N)2) (factor 2 is rejected). 
It is difficult to compare results with other algorithms. First of all, the IMDS formalism is addressed to distributed systems, which is why each system must be built from independent servers communicating via messages. The global state of the system is not available for individual servers making their own decisions. Such benchmarks as Solitaire Game [Gradara et al., 2006], mentioned in many papers, cannot be examined in IMDS formalism. Another commonly used example – philosophers [Dijkstra, 1959] – must be rebuilt to the form of a distributed system: forks are distributed servers, and philosophers must start from some servers, which is why a set of new servers called chairs is added (Fig. 5.6). Such a model ceases to be directly comparable, because its structure is different.
Second: our algorithm is addressed to detect partial deadlock/termination. Total deadlock/ termination can be identified, but in the sense of a partial deadlock/termination, which comprises a set of processes, giving the full set. In the case of other algorithms, only total deadlock is examined due to their nature.
Third: all benchmarks used in the mentioned papers [Francesca et al., 2011] [Godefroid and Khurshid, 2002] [Gradara et al., 2006] [Chicano and Alba, 2008] [Alba and Chicano, 2007] [Yousefian et al., 2014] [Pira et al., 2017] (and others) show how quickly a deadlock can be found in the system that is known for its falling into a deadlock. Systems known to be safe or systems unknown to be safe/unsafe are not tested. Such an approach is appropriate for evaluation of the algorithm and the verification software. However, in practice, we need deadlock-free systems, proven by a model checker, rather than confirming that a large number of philosophers (say, 1000) fall into a deadlock. None of the above papers describes how long it takes to judge that a verified system is safe from deadlock. Such a comparison would be very interesting when comparing various non-exhaustive algorithms.
Table 11.5 compares various heuristic-based methods of deadlock detection with their maximum number of surveyed philosophers. 
Table 11.5. Dijsktra’s philosophers in comparison of non-exhaustive search methods
Paper	Modeling language	technique	No. of philosophers	Verification time
[h:m:s]
[Francesca et al., 2011]
CCS	ACO	15	?
[Francesca et al., 2011]
CCS	A*	12	?
[Godefroid and Khurshid, 2002]
C	GA	(52% runs)    17 	2:57
[Godefroid and Khurshid, 2002]
C	GA (mutation only)	(52% runs)    17	2:16
[Gradara et al., 2006]
CCS	A*	12	?
[Gradara et al., 2006]
CCS	Greedy	40	?
[Alba and Chicano, 2007]
Promela	ACO	8	1:12:14
[Yousefian et al., 2014]
GTSa 	GA	30	40:09
[Yousefian et al., 2014]
GTSa 	A*	8	24:37
[Pira et al., 2017]
GTSa 	GA +machine learning	100	56
[Pira et al., 2017]
GTSa 	GA	20	23
[Pira et al., 2017]
GTSa 	A*	10	3:57
This monograph	IMDS	2-vagabonds	18b	84:18:51
This monograph	IMDS	2-vagabonds	12c	6:38:53
a GTS - Graph Transformation System
b partial deadlock of one philosopher, obviously participating in total deadlock 
c total deadlock = partial deadlock of all processes

References
Alba E, and Chicano F. (2007). Ant Colony Optimization for Model Checking. In R. Moreno Díaz, F. Pichler, & A. Quesada Arencibia (Eds.), International Conference on Computer Aided Systems Theory – EUROCAST 2007, Las Palmas, Spain, 12-16 Feb. 2007, LNCS vol. 4739 (pp. 523–530). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-75867-9_66
Alba E, and Troya J M. (1996). Genetic algorithms for protocol validation. In H.-M. Voigt, W. Ebeling, I. Rechenberg, & H.-P. Schwefel (Eds.), International Conference on Parallel Problem Solving from Nature PPSN 1996 — PPSN IV, Berlin, Germany, 22–26 Sept. 1996 (pp. 869–879). Berlin Heidelberg: Springer. doi: 10.1007/3-540-61723-X_1050
Batista G E A P A, Prati R C, and Monard M C. (2004). A study of the behavior of several methods for balancing machine learning training data. ACM SIGKDD Explorations Newsletter, 6(1), 20–29. doi: 10.1145/1007730.1007735
Chicano F, and Alba E. (2008). Ant colony optimization with partial order reduction for discovering safety property violations in concurrent models. Information Processing Letters, 106(6), 221–231. doi: 10.1016/j.ipl.2007.11.015
Clarke E M, Grumberg O, and Long D E. (1994). Model checking and abstraction. ACM Transactions on Programming Languages and Systems, 16(5), 1512–1542. doi: 10.1145/186025.186051
Clarke E M, Long D E, and McMillan K L. (1989). Compositional model checking. In Fourth Annual Symposium on Logic in Computer Science, Pacific Grove, CA, 5-8 June 1989 (pp. 353–362). IEEE Comput. Soc. Press. doi: 10.1109/LICS.1989.39190
Clarke E, McMillan K, … Hartonas-Garmhausen V. (1996). Symbolic model checking. In R. Alur & T. A. Henzinger (Eds.), 8th International Conference on Computer Aided Verification - CAV ’96, New Brunswick, NJ, 31 July – 3 Aug. 1996 (pp. 419–422). Berlin Heidelberg: Springer. doi: 10.1007/3-540-61474-5_93
Czejdo B, Bhattacharya S, … Daszczuk W B. (2016). Improving Resilience of Autonomous Moving Platforms by real-time analysis of their Cooperation. Autobusy-TEST, 17(6), 1294–1301. url: http://www.autobusy-test.com.pl/images/stories/Do_pobrania/2016/nr 6/logistyka/10_l_czejdo_bhattacharya_baszun_daszczuk.pdf
Daszczuk W B. (2018). Siphon-based deadlock detection in Integrated Model of Distributed Systems (IMDS). In Federated Conference on Computer Science and Information Systems, 3rd Workshop on Constraint Programming and Operation Research Applications (CPORA’18), Poznań, Poland, 9-12 Sept. 2018 (pp. 425–435). IEEE. doi: 10.15439/2018F114
Daszczuk W B. (2019a). Asynchronous Specification of Production Cell Benchmark in Integrated Model of Distributed Systems. In R. Bembenik, L. Skonieczny, G. Protaziuk, M. Kryszkiewicz, & H. Rybinski (Eds.), 23rd International Symposium on Methodologies for Intelligent Systems, ISMIS 2017, Warsaw, Poland, 26-29 June 2017, Studies in Big Data, vol. 40 (pp. 115–129). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-77604-0_9
Daszczuk W B. (2019b). Fairness in Temporal Verification of Distributed Systems. In W. Zamojski, J. Mazurkiewicz, J. Sugier, T. Walkowiak, & J. Kacprzyk (Eds.), 13th International Conference on Dependability and Complex Systems DepCoS-RELCOMEX, 2-6 July 2018, Brunów, Poland, AISC vol.761 (pp. 135–150). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-91446-6_14
Dijkstra E W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269–271. doi: 10.1007/BF01386390
Francesca G, Santone A, … Villani M L. (2011). Ant Colony Optimization for Deadlock Detection in Concurrent Systems. In 2011 IEEE 35th Annual Computer Software and Applications Conference, Munich, Germany, 18-22 July 2011 (pp. 108–117). IEEE. doi: 10.1109/COMPSAC.2011.22
Gerth R, Kuiper R, … Szreter M. (1999). Partial Order Reductions Preserving Simulations. In Concurrency Specification and Programming (CS&P), Warsaw, Poland, 28-30 Sept. 1999 (pp. 153–171). url: http://www.ipipan.waw.pl/~penczek/WPenczek/papersPS/IPI843-97.ps.gz
Godefroid P, and Khurshid S. (2002). Exploring Very Large State Spaces Using Genetic Algorithms. In J.-P. Katoen & P. Stevens (Eds.), International Conference on Tools and Algorithms for the Construction and Analysis of Systems -TACAS 2002, Grenoble, France, 8–12 April 2002, LNCS vol. 2280 (pp. 266–280). Berlin Heidelberg: Springer. doi: 10.1007/3-540-46002-0_19
Gradara S, Santone A, and Villani M L. (2006). DELFIN+: An efficient deadlock detection tool for CCS processes. Journal of Computer and System Sciences, 72(8), 1397–1412. doi: 10.1016/j.jcss.2006.03.003
Hatcliff J, Dwyer M B, and Zheng H. (2000). Slicing Software for Model Construction. Higher-Order and Symbolic Computation, 13(4), 315–353. doi: 10.1023/A:1026599015809
Jard C, and Jéron T. (1992). Bounded-memory algorithms for verification on-the-fly. In International Conference on Computer Aided Verification - CAV 1991, Aalborg, Denmark, 1–4 July 1991 (pp. 192–202). Berlin Heidelberg: Springer. doi: 10.1007/3-540-55179-4_19
Milner R. (1980). A Calculus of Communicating Systems, LNCS vol. 92. (R. Milner, Ed.) (Vol. 92). Berlin, Heidelberg: Springer Berlin Heidelberg. doi: 10.1007/3-540-10235-3
Pira E, Rafe V, and Nikanjam A. (2017). Deadlock detection in complex software systems specified through graph transformation using Bayesian optimization algorithm. Journal of Systems and Software, 131(Sept.), 181–200. doi: 10.1016/j.jss.2017.05.128
Santone A. (2002). Automatic verification of concurrent systems using a formula-based compositional approach. Acta Informatica, 38(8), 531–564. doi: 10.1007/s00236-002-0084-5
Stirling C, and Walker D. (1991). Local model checking in the modal mu-calculus. Theoretical Computer Science, 89(1), 161–177. doi: 10.1016/0304-3975(90)90110-4
Yousefian R, Rafe V, and Rahmani M. (2014). A heuristic solution for model checking graph transformation systems. Applied Soft Computing, 24(Nov.), 169–180. doi: 10.1016/j.asoc.2014.06.055


12.	Conclusions and further work
Communication duality, expressed as the server view and the agent view of the verified system, is the sound effect of the author’s work. In the specification, it is simply grouping of actions in servers or in agents. The two views are the system decompositions that show message passing and resource sharing aspects of a distributed system. Fig. 12.1 presents the metaphor of the decompositions. In the server view, an observer sees flowers (servers) with a set of bees flying between them and transferring pollen portions (messages). In the agent view, the observer fo-cuses on individual bees traveling between flowers. The application of IMDS formalism highlights locality, autonomy and asynchrony in distributed systems, and distinguishes between features relative to agents behavior and features relative to servers behavior. The author claims that asynchronous specification is better suited for distributed systems than many synchronous modeling formalisms. The IMDS model, introduced in Chapter 3, combines asynchrony with communication duality. The specification formalism that supports communication duality, locality, autonomy and asynchrony in distributed systems, is an important research contribution of the monograph.
The IMDS establishes a global system configuration for building the Labeled Transition System and to perform model checking. However, in the definition of actions, and in the IMDS specifica-tion language, only local state of the server and messages pending at this server are observed. The only way to influence the behavior of the server is to send a message to it, and there is no external control over the server. It autonomously decides which of the pending messages will be accepted and when. Therefore, the formalism is especially tailored to real distributed systems, like Local Area Networks (LANs), internet services, multiagent systems, etc. Modeling truly dis-tributed systems is based on simple protocols between servers, rather than on common varia-bles. Such modeling is appropriate for Internet of Things approach (IoT, [Lee et al., 2013]), where independent devices autonomously negotiate their coordinated behavior using simple protocols. A few examples of systems specified this way are contained in Chapter 5.
Distributed systems specification and verification formalisms typically identify total deadlocks, and sometimes total distributed termination. Some of them allow detection of partial deadlocks and/or termination, but at a expense of limiting the possible system structure or specifying the features manually by the user. An overview of those formalisms is given in Chapter 2. IMDS in-tegrated with model checking provides automatic detection of partial and total deadlocks and partial and total termination by means of general temporal formulas. In addition, communication deadlocks can be identified in the server view while resource deadlocks in the agent view (Section 3.4 and Chapter 4). This feature is very rare among the known formalisms. The auto-matic verification of total/partial properties and differentiation between their kinds is the second main research contribution of the author.
The presented methodology is the basis of the Dedan specification and verification tool. Conver-sion between the views in specification, where the server/agent types and variables are intro-duced, is performed algorithmically in Dedan. The two views allow the observation of the system from the point of view of cooperating servers or from the point of view of traveling agents. In Sections 5.3, 5.4 and 5.5, this is illustrated by examples of transportation systems with automatic vehicle guidance: the server view shows the perspective of cooperating road segment control-lers, while the agent view - from the perspective of vehicles. While the controller view is natural to the computer engineer, the vehicle view might be more natural to the transport specialist. Counterexamples generated by Dedan show the message exchange between the controllers (server view) or vehicle movement using the segments (agent view). A resource deadlock with-out a communication deadlock - an agent which is stuck while all servers work - is presented in the “roundabout” example. 
The Karlsruhe Production Cell benchmark was successfully modeled and verified under Dedan (Section 5.6). The verification of its timed version (using Uppaal) failed due to modeling asyn-chronous communication channels as separate Timed Automata. This largely extends the reachability space of the specification. Such verification should be possible in a future symbolic version of the internal Dedan verifier (explained below), because asynchrony of channels is modeled directly in the LTS of the IMDS specification. In addition, the verification using the timed "2-vagabonds" algorithm seems promising.
To check the deadlocks and termination, a designer should express the system (or – better – its model; or best – the communication skeleton of the system) in terms of IMDS elements: servers’ states, agents’ messages, and actions. The proposed notation is presented informally in Section 3.3, and defined formally in Appendix C. The verification process is carried automatically by the Dedan program, which finds communication deadlocks, resource deadlocks and agents termina-tion. The user does not have to know any temporal logic to verify the model. Counterexamples and witnesses are generated automatically in a readable form and stored in various file formats. In addition, it is possible to simulate the verified system, and to observe the shape of the LTS. Several examples of distributed systems and their verification are presented in Chapter 5. The structure of the Dedan program and the overview of its use are shown in Chapter 6. The specifi-cation of general formulas for deadlock and termination verification (including partial ones) inde-pendently of specific features of a system, is a sound practical contribution. 
Two specification formalisms are proposed, equivalent to IMDS: distributed automata DA3 (in two forms, Chapter 8) and Petri nets with a restricted structure (Chapter 7). The equivalence of the two formalisms with IMDS lays in mapping their basic structures onto structures of IMDS and analogous reachability graphs: LTS for IMDS, reachable markings graph for a Petri net and global node space for distributed automata of both forms. Elements and verification features, wider than deadlock and termination identification, are collected for all three formalisms in Ta-ble 12.1. This variety of specification modes greatly facilitates the analysis of distributed system features.
Table 12.1. Verification facilities in the three equivalent formalisms
Formalism:	IMDS	Petri net	DA3
Main features	Specification, model checking, simulation	Structural properties	Graphical input, simulation
Notions	state	“red” place	•	node (S-DA3)
•	element of global input vector, input/output sym-bol on transitions (A DA3)
	message	“green” place	•	element of input set (S DA3), input/output symbol on transitions
•	node (A-DA3)
	configuration	marking	global node
	action	transition	transition
	initial state	token in red place in initial marking	•	initial node (S DA3)
•	initial element of global input vector (A DA3)
	initial message	token in green place in initial marking	•	initial element of input set (S DA3)
•	initial node (A DA3)
	initial configuration	initial marking	•	initial nodes and initial input sets of all automata (S DA3)
•	initial nodes and initial global input vector (A DA3)
	Labeled Transition System
	Marking reachability graph	Global node space:
•	all states and input sets in global nodes, input and output symbols on transi-tions (S DA3)
•	all messages and global input vector in global nodes, input and output symbols on transitions (A DA3)
Features	•	Resource deadlock    
•	Communication deadlock   
•	Partial deadlock
•	Total deadlock
•	Partial distributed termination
•	Total distributed termina-tion
•	Counterexamples/ witnesses
•	Configuration space inspection
•	Simulation over configuration space	•	Structural properties
•	Unreachable actions
•	Separated components
•	Existence of siphons
•	Many dead-locks
•	Invariants	•	Graphical definition  of a system  
•	Simulation over   individual automata
•	Counterexample projected onto individual automata
•	Counterexample guided simulation

Automation of deadlock detection and termination checking allows the students of ICS, WUT to use the presented methodology. They prepare their solutions to synchronization problems and then verify these solutions using Dedan. This procedure allows the students to analyze the cor-rectness of their ideas, to correct wrong solutions, and to get used to formal verification of soft-ware. Other facilities of the Dedan program support this process: analysis of structural properties in a Petri net equivalent to the IMDS specification, and several modes of simulation of the system under verification. As an additional convenience, students may use other forms of specification, equivalent to IMDS: distributed automata DA3 (described in Chapter 8) and the imperative-style Rybu preprocessor, prepared by the students if ICS, WUT under supervision of the author [Daszczuk et al., 2017].
Because external verifiers are used to verify large systems, the complexity of internal TempoRG verifier is not very important. Explicit reachability space generates known problems with the size of the space and the time of its elaboration [McMillan, 1993]. They depend more on the parallel-ism degree of the modeled system and the way of cooperation within the system than on the size of the specification. The “intersection” example with 4 roads, having 73 lines of source code, has a reachability space that exceeds the possibilities of internal verification. Its size is over 2 million configurations, but it can be checked using an external verifier. On the other hand, one of the students’ solutions to synchronization problems, consisting of almost 6 thousand lines of source code (generated by the Rybu preprocessor), is successfully verified in about half a minute (Section 5.8). The reachability space contains almost 15 thousand configurations. For many internally verified systems, reachability space is generated in a few minutes and verification time is several seconds. 
The Dedan verification environment is under development. In addition to TempoRG verifier, oth-er model checkers are used, including Spin [Holzmann, 1995] [Holzmann, 1997], symbolic NuSMV model checker [Cimatti et al., 2000] and Uppaal [Behrmann, David, et al., 2006]. Model checking with TempoRG on explicit reachability space will be performed with space reduction, which will allow to verify larger systems without the usage of external verifiers (which sometimes show problems with fairness, described in Chapter 9). Typical reachability space reduction tech-niques are based on an independence relation, which is supported externally [Penczek et al., 2000] [Godefroid and Wolper, 1992] [Gerth et al., 1999]. IMDS is attractive in this matter, be-cause the independence relation is natural: actions on separate servers are always independent. In addition, a symbolic representation of a reachability space in Binary Decision Diagrams (BDD) is planned [E.M. Clarke et al., 1999]. This will allow verification of large systems entirely inside the program, without external verifiers.
The behavior of a distributed system can strongly depend on real time dependencies. Time con-straints imposed on action execution or communication delay can change the behavior: some deadlocks can possibly disappear or new deadlocks may possibly arise. Besides, improper timing may prevent a successful distributed termination. Verification with real time constraints is performed externally, using Uppaal verifier [Behrmann, David, et al., 2006], after conversion of the verified system to Timed Automata [Alur and Dill, 1994] [Hui and Chikkagoudar, 2012] (Chapter 10). Time constraints can be imposed on time delays of communication channels, du-ration of actions and time limits of staying in the states. For example, this allows to model and verify urban transportation problems. In the future, discrete time verification will be also applied, using the specification in EmLan language [Krystosik, 2006] [Krystosik and Turlej, 2006]. The timed version of 2-vagabonds non-exhaustive verification algorithm is under tests. The timed specification and verification preserving communication duality, locality, autonomy and asyn-chrony is an important research and practical contribution.
Chapter 11 presents the non-exhaustive 2-vagabonds algorithm for partial deadlock and partial termination verification. The algorithm is tailored especially for distributed IoT systems consisting of a number on servers running a set of cooperating agents. The algorithm was tested on several examples, both falling into a deadlock and safe from deadlock. Some student exercises with a result unknown in advance were also examined. 
The algorithm is the only one known which can non-exhaustively search for partial deadlock and termination. Its construction confirms our assumption: it has only one parameter D controlling the number of steps performed during heuristic search. Also, in many cases it searches leader sub-paths less frequently than the rest of reachability space.
Both algorithms, CBS and 2-vagabonds, are designed for the IMDS specification, but we believe that they can be applied to other formalisms. However, IMDS formalism is the only one which differentiates deadlock from termination independently of the shape of the verified system, and which can identify communication deadlock in the server view and resource deadlock in the agent view [Daszczuk, 2017a]. 
The 2-vagabonds algorithm uses two processes (vagabonds): first puts the hypothesis and the second verifies the hypothesis. Because they work almost independently, various parallel and distributed implementations are possible. Elements of other approaches: ACO, GA, A* and ma-chine learning can increase the performance of 2-vagabonds. We plan to apply these heuristics in our future research. Partial order reductions can also be applied, especially because inde-pendence relation is built in the formalism: actions executed in separate servers are always in-dependent (while actions in the same server are always in conflict).
The future directions of IMDS and Dedan development are:
•	Reachability space reduction and symbolic representation, mentioned above.
•	Checking for assertions expressed in terms of states and messages.
•	Invariant discovery – relations between states and messages held in loops of LTS.
•	Higher level language-based input – elaboration of two languages of distributed systems specification: for the server view - exploiting locality in servers and message passing, and for the agent view - exploiting traveling of agents and resource sharing in the distributed environment. 
•	Code mobility – equipping the agents with their own sets of actions, carried in their “backpacks”, parameterizing their behavior. This will allow modeling of mobile agents and let avoiding the specification of multiple slightly differing server types. An example of such a specification is “dining philosophers“ with asymmetric solution – some philoso-phers take their left forks first and some of them take right forks first.
•	Dynamic creation of processes – a state of new server and/or a message of new agent created in the action [Chrobot and Daszczuk, 2006]. Some problems with the elaboration of the reachability space of such system must be solved ﬁrst. To be statically verified, the LTS of a Petri net corresponding to the IMDS system should be bounded, e.g. by limiting markings to some bound [Wil M. P. van der Aalst, 1998].
•	Non-exhaustive search for partial deadlock detection and partial termination checking in timed systems (with real-time constraints).
•	Probabilistic model checking of models with probabilities of choices between the actions in servers and in agents [Kwiatkowska et al., 2011] [Alexiou et al., 2016].
•	Minor improvements, for example indexing of vectors from 0 and command-line interface to run Dedan from batch.

References
Agarwal R, and Stoller S D. (2006). Run-Time Detection of Potential Deadlocks for Programs with Locks, Semaphores, and Condition Variables. In Proc. of the Workshop on Parallel and Distributed Systems: Testing and Debugging (PADTAD-IV), ISSTA, 2006, Portland, ME, 17-20 July 2006 (pp. 51–59). New York, NY: ACM. doi: 10.1145/1147403.1147413
Alba E, and Chicano F. (2007). Ant Colony Optimization for Model Checking. In R. Moreno Díaz, F. Pichler, & A. Quesada Arencibia (Eds.), International Conference on Computer Aided Systems Theory – EUROCAST 2007, Las Palmas, Spain, 12-16 Feb. 2007, LNCS vol. 4739 (pp. 523–530). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-75867-9_66
Alba E, and Troya J M. (1996). Genetic algorithms for protocol validation. In H.-M. Voigt, W. Ebeling, I. Rechenberg, & H.-P. Schwefel (Eds.), International Conference on Parallel Problem Solving from Nature PPSN 1996 — PPSN IV, Berlin, Germany, 22–26 Sept. 1996 (pp. 869–879). Berlin Heidelberg: Springer. doi: 10.1007/3-540-61723-X_1050
Alexiou N, Basagiannis S, and Petridou S. (2016). Formal security analysis of near field communication using model checking. Computers & Security, 60, 1–14. doi: 10.1016/j.cose.2016.03.002
Allen G E, Zucknick P E, and Evans B L. (2007). A Distributed Deadlock Detection and Resolution Algorithm for Process Networks. In 2007 IEEE International Conference on Acoustics, Speech and Signal Processing - ICASSP ’07, 15-20 April 2007, Honolulu, HI, Vol.2 (p. II-33-II-36). New York, NY: IEEE. doi: 10.1109/ICASSP.2007.366165
Alur R, and Dill D L. (1994). A theory of timed automata. Theoretical Computer Science, 126(2), 183–235. doi: 10.1016/0304-3975(94)90010-8
Arcaini P, Gargantini A, and Riccobene E. (2009). AsmetaSMV: a model checker for AsmetaL models – Tutorial. url: https://air.unimi.it/retrieve/handle/2434/69105/96882/Tutorial_AsmetaSMV.pdf
Arcile J, Czachórski T, … Rataj A. (2016). Modelling and Analysing Mixed Reality Applications. In A. Gruca, A. Brachman, S. Kozielski, & T. Czachórski (Eds.), Man-Machine Interactions 4: 4th International Conference on Man-Machine Interactions, ICMMI 2015 Kocierz Pass, Poland, 6-9 Oct. 2015 (pp. 3–17). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-23437-3_1
Attie P C. (2016). Synthesis of large dynamic concurrent programs from dynamic specifications. Formal Methods in System Design, 47(131), 1–54. doi: 10.1007/s10703-016-0252-9
Baier C, and Katoen J-P. (2008). Principles of Model Checking. Cambridge, MA: MIT Press.
Balan M S. (2009). Serializing the Parallelism in Parallel Communicating Pushdown Automata Systems. Electronic Proceedings in Theoretical Computer Science, 3, 59–68. doi: 10.4204/EPTCS.3.5
Barbey S, Buchs D, and Péraire C. (1998a). A Case Study for Testing Object-Oriented Software: A Production Cell.
Barbey S, Buchs D, and Péraire C. (1998b). Modelling the Production Cell Case Study using the Fusion Method. Lausanne, Switzerland. url: https://infoscience.epfl.ch/record/54618/files/Barbey98-298..ps.gz
Batista G E A P A, Prati R C, and Monard M C. (2004). A study of the behavior of several methods for balancing machine learning training data. ACM SIGKDD Explorations Newsletter, 6(1), 20–29. doi: 10.1145/1007730.1007735
Behrmann G, Cougnard A, … Lime D. (2006). Uppaal-Tiga: Timed Games for Everyone. In Nordic Workshop on Programming Theory (NWPT’06), Reykjavik, Iceland, 18-20 Oct. 2006. url: https://hal.archives-ouvertes.fr/hal-00350470/document
Behrmann G, David A, and Larsen K G. (2006). A Tutorial on Uppaal 4.0. Aalborg, Denmark. url: http://www.it.uu.se/research/group/darts/papers/texts/new-tutorial.pdf
Ben-Abdallah H, and Lee I. (1998). A Graphical Language for Specifying and Analyzing Real-Time Systems. Integrated Computer-Aided Engineering, 5(4), 279–302. url: ftp://ftp.cis.upenn.edu/pub/rtg/Paper/Full_Postscript/icae97.pdf
Beneš N, Černá I, … Zimmerova B. (2008). A Case Study in Parallel Verification of Component-Based Systems. Electronic Notes in Theoretical Computer Science, 220(2), 67–83. doi: 10.1016/j.entcs.2008.11.014
Benghazi Akhlaki K, Capel Tuñón M I, … Mendoza Morales L E. (2007). A methodological approach to the formal specification of real-time systems by transformation of UML-RT design models. Science of Computer Programming, 65(1), 41–56. doi: 10.1016/j.scico.2006.08.005
Bensalem S, Griesmayer A, … Peled D. (2011). Efficient deadlock detection for concurrent systems. In 9th ACM/IEEE International Conference on Formal Methods and Models for Codesign, MEMOCODE 2011, Cambridge, UK, 11-13 July 2011 (pp. 119–129). New York, NY: IEEE. doi: 10.1109/MEMCOD.2011.5970518
Bérard B. (2013). An Introduction to Timed Automata. In Control of Discrete-Event Systems (pp. 169–187). London, UK: Springer-Verlag. doi: 10.1007/978-1-4471-4276-8_9
Bérard B, Bidoit M, … Schnoebelen P. (2001). Systems and Software Verification. Model-Checking Techniques and Tools. Berlin Heidelberg: Springer-Verlag.
Bérard B, Cassez F, … Roux O H. (2005). Comparison of the Expressiveness of Timed Automata and Time Petri Nets. In Third International Conference, FORMATS 2005, Uppsala, Sweden, 26-28 Sept. 2005 (pp. 211–225). Berlin Heidelberg: Springer. doi: 10.1007/11603009_17
Bertino E, Chiola G, and Mancini L V. (1998). Deadlock Detection in the Face of Transaction and Data Dependencies. In 19th International Conference ICATPN’98, Lisbon, Portugal, 22-26 June 1998 (pp. 266–285). Berlin Heidelberg: Springer. doi: 10.1007/3-540-69108-1_15
Beyer D, Lewerentz C, and Noack A. (2003). Rabbit: A Tool for BDD-Based Verification of Real-Time Systems. In Computer Aided Verification, CAV 2003, Boulder, CO, 8-12 July 2003, LNCS 2725 (pp. 122–125). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-540-45069-6_13
Beyer D, and Rust H. (1998). Modeling a Production Cell as a Distributed Real-Time System with Cottbus Timed Automata. In H. König & P. Langendörfer (Eds.), Formale Beschreibungstechniken für verteilte Systeme, 8. GI/ITG-Fachgespräch, Cottbus, Germany, 4-5 June 1998. München, Germany: Shaker Verlag. url: https://www.sosy-lab.org/~dbeyer/Publications/1998-FBT.Modeling_a_Production_Cell_as_a_Distributed_Real-Time_System_with.Cottbus_Timed_Automata.pdf
Björnander S, Seceleanu C, … Pettersson P. (2011). ABV - A Verifier for the Architecture Analysis and Design Language (AADL). In 6th IEEE International Conference on Engineering of Complex Computer Systems, Las Vegas, NV, 27-29 April 2011 (pp. 355–360). IEEE. doi: 10.1109/ICECCS.2011.43
Bollig B, and Leucker M. (2004). Message-Passing Automata Are Expressively Equivalent to EMSO Logic. In 15th International Conference CONCUR 2004 - Concurrency Theory, London, UK, 31 Aug. - 3 Sept. 2004 (pp. 146–160). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-28644-8_10
Bollig B, and Leucker M. (2005). A Hierarchy of Implementable MSC Languages. In Formal Techniques for Networked and Distributed Systems - FORTE 2005, Taipei, Taiwan, 2-5 Oct. 2005 (pp. 53–67). Berlin Heidelberg: Springer. doi: 10.1007/11562436_6
Bowman H. (2001). Time and Action Lock Freedom Properties for Timed Automata. In 21st International Conference on Formal Techniques for Networked and Distributed Systems, FORTE 2001, Cheju Island, Korea, 28-31 Aug. 2001 (pp. 119–134). Boston: Kluwer Academic Publishers. doi: 10.1007/0-306-47003-9_8
Bowman H, Gomez R, and Su L. (2005). A Tool for the Syntactic Detection of Zeno-timelocks in Timed Automata. Electronic Notes in Theoretical Computer Science, 139(1), 25–47. doi: 10.1016/j.entcs.2005.09.006
Brim L, Černá I, … Šimša J. (2006). How to Order Vertices for Distributed LTL Model-Checking Based on Accepting Predecessors. Electronic Notes in Theoretical Computer Science, 135(2), 3–18. doi: 10.1016/j.entcs.2005.10.015
Budde R. (1995). Esterel. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 5 (pp. 75–100). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_49
Burghardt J. (1995). Deductive synthesis. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 17 (pp. 295–309). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_61
Burns A. (2003). How to Verify a Safe Real-Time System - The Application of Model Checking and Timed Automata to the Production Cell Case Study. Real-Time Systems, 24(2), 135–151. doi: 10.1023/A:1021758401878
Caillaud B, Caspi P, … Jard C. (1997). Distributing Automata for Asynchronous Networks of Processors. European Journal of Automation (RAIRO-APII-JESA), 31(3), 503–524.
Capecchi S, Giachino E, and Yoshida N. (2016). Global escape in multiparty sessions. Mathematical Structures in Computer Science, 26(02), 156–205. doi: 10.1017/S0960129514000164
Cardell-Oliver R. (1995). HTTDs and HOL. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 15 (pp. 261–276). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_59
Cassez F, David A, … Lime D. (2005). Efficient On-the-Fly Algorithms for the Analysis of Timed Games. In 16th International Conference on Concurrency Theory (CONCUR’05), San Francisco, CA, 23-26 Aug. 2005, LNCS 3653 (pp. 66–80). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/11539452_9
Cassez F, and Roux O H. (2006). Structural translation from Time Petri Nets to Timed Automata. Journal of Systems and Software, 79(10), 1456–1468. doi: 10.1016/j.jss.2005.12.021
Cattel T. (1995). Process Control Design Using SPIN. In Spin Workshop, Montreal, Canada, 16 Oct. 1995. url: http://spinroot.com/spin/Workshops/ws95/cattel.pdf
Chalopin J, Godard E, … Tel G. (2007). About the Termination Detection in the Asynchronous Message Passing Model. In 33rd Conference on Current Trends in Theory and Practice of Computer Science, Harrachov, Czech Republic, 20-26 Jan. 2007 (pp. 200–211). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-69507-3_16
Chandy K M, and Lamport L. (1985). Distributed snapshots: determining global states of distributed systems. ACM Transactions on Computer Systems, 3(1), 63–75. doi: 10.1145/214451.214456
Chandy K M, Misra J, and Haas L M. (1983). Distributed deadlock detection. ACM Transactions on Computer Systems, 1(2), 144–156. doi: 10.1145/357360.357365
Chang F S-H, and Jackson D. (2006). Symbolic model checking of declarative relational models. In Proceeding of the 28th international conference on Software engineering - ICSE ’06, Shanghai, China, 20-28 May 2006 (pp. 312–320). New York, New York, USA: ACM Press. doi: 10.1145/1134285.1134329
Charlie. (n.d.). Charlie Petri net analyzer. url: http://www-dssz.informatik.tu-cottbus.de/DSSZ/Software/Charlie
Chicano F, and Alba E. (2008). Ant colony optimization with partial order reduction for discovering safety property violations in concurrent models. Information Processing Letters, 106(6), 221–231. doi: 10.1016/j.ipl.2007.11.015
Chieu D Van, and Hung D Van. (2010). An Extension of Mazukiewicz Traces and their Applications in Specification of Real-Time Systems. In 2010 Second International Conference on Knowledge and Systems Engineering, Hanoi, Vietnam, 7-9 Oct. 2010 (pp. 167–171). New York, NY: IEEE. doi: 10.1109/KSE.2010.39
Cho J, Yoo J, and Cha S. (2006). NuEditor – A Tool Suite for Specification and Verification of NuSCR. In SERA 2004: Software Engineering Research and Applications, Los Angeles, CA, 5-7 May 2004, LNCS Vol. 3647 (pp. 19–28). Berlin Heidelberg: Springer. doi: 10.1007/11668855_2
Choudhary A N, Kohler W H, … Towsley D. (1989). A modified priority based probe algorithm for distributed deadlock detection and resolution. IEEE Transactions on Software Engineering, 15(1), 10–17. doi: 10.1109/32.21721
Chrobot S, and Daszczuk W B. (2006). Communication Dualism in Distributed Systems with Petri Net Interpretation. Theoretical and Applied Informatics, 18(4), 261–278. url: https://taai.iitis.pl/taai/article/view/250/taai-vol.18-no.4-pp.261
Chu F, and Xie X-L. (1997). Deadlock analysis of Petri nets using siphons and mathematical programming. IEEE Transactions on Robotics and Automation, 13(6), 793–804. doi: 10.1109/70.650158
Cimatti A, Clarke E, … Roveri M. (2000). NUSMV: A new symbolic model checker. International Journal on Software Tools for Technology Transfer, 2(4), 410–425. doi: 10.1007/s100090050046
Clarke E M, Grumberg O, and Long D E. (1994). Model checking and abstraction. ACM Transactions on Programming Languages and Systems, 16(5), 1512–1542. doi: 10.1145/186025.186051
Clarke E M, Grumberg O, and Peled D. (1999). Model Checking. Cambridge, MA: MIT Press.
Clarke E M, Long D E, and McMillan K L. (1989). Compositional model checking. In Fourth Annual Symposium on Logic in Computer Science, Pacific Grove, CA, 5-8 June 1989 (pp. 353–362). IEEE Comput. Soc. Press. doi: 10.1109/LICS.1989.39190
Clarke E, McMillan K, … Hartonas-Garmhausen V. (1996). Symbolic model checking. In R. Alur & T. A. Henzinger (Eds.), 8th International Conference on Computer Aided Verification - CAV ’96, New Brunswick, NJ, 31 July – 3 Aug. 1996 (pp. 419–422). Berlin Heidelberg: Springer. doi: 10.1007/3-540-61474-5_93
Coffman E G, Elphick M, and Shoshani A. (1971). System Deadlocks. ACM Computing Surveys, 3(2), 67–78. doi: 10.1145/356586.356588
Corbett J C. (1994). An empirical evaluation of three methods for deadlock analysis of Ada tasking programs. In Proceedings of the 1994 international symposium on Software testing and analysis - ISSTA ’94, ), Seattle, WA, 17-19 Aug. 1994 (pp. 204–215). New York, NY: ACM Press. doi: 10.1145/186258.187206
Corbett J C. (1996). Evaluating deadlock detection methods for concurrent software. IEEE Transactions on Software Engineering, 22(3), 161–180. doi: 10.1109/32.489078
Cordeiro L. (2010). SMT-based bounded model checking for multi-threaded software in embedded systems. In Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - ICSE ’10, Cape Town, RSA, 2-8 May 2010 (Vol. 2, pp. 373–376). New York, NY: ACM Press. doi: 10.1145/1810295.1810396
Craig D C, and Zuberek W M. (2008). Two-stage siphon-based deadlock detection in Petri nets. In P. Petratos & P. Dandapami (Eds.), Current Advances in Computing, Engineering and Information Technology (pp. 317–330). Palermo, Italy: Int. Society for Advanced Research.
Cuellar J, and Huber M. (1995). TLT. In C. Lewerentz & T. Lindne (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. (pp. 151–169). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_53
Czejdo B, Bhattacharya S, … Daszczuk W B. (2016). Improving Resilience of Autonomous Moving Platforms by real-time analysis of their Cooperation. Autobusy-TEST, 17(6), 1294–1301. url: http://www.autobusy-test.com.pl/images/stories/Do_pobrania/2016/nr 6/logistyka/10_l_czejdo_bhattacharya_baszun_daszczuk.pdf
Daszczuk W B. (2000). State space reduction for reachability graph of CSM automata, ICS WUT Research Report No 10/2000.
Daszczuk W B. (2001). Evaluation of temporal formulas based on “Checking By Spheres.” In Proceedings Euromicro Symposium on Digital Systems Design, Warsaw, Poland, 4-6 Sept. 2001 (pp. 158–164). IEEE. doi: 10.1109/DSD.2001.952267
Daszczuk W B. (2002). Critical trees: counterexamples in model checking of CSM systems using CBS algorithm, ICS WUT Research Report No.8/2002.
Daszczuk W B. (2003). Verification of Temporal Properties in Concurrent Systems. Warsaw University of Technology. url: https://repo.pw.edu.pl/docstore/download/WEiTI-0b7425b5-2375-417b-b0fa-b1f61aed0623/Daszczuk.pdf
Daszczuk W B. (2008). Deadlock and termination detection using IMDS formalism and model checking, Version 2, ICS WUT Research Report No.2/2008.
Daszczuk W B. (2017a). Communication and Resource Deadlock Analysis using IMDS Formalism and Model Checking. The Computer Journal, 60(5), 729–750. doi: 10.1093/comjnl/bxw099
Daszczuk W B. (2017b). Threefold Analysis of Distributed Systems: IMDS, Petri Net and Distributed Automata DA3. In 37th IEEE Software Engineering Workshop, Federated Conference on Computer Science and Information Systems, FEDCSIS’17, Prague, Czech Republic, 3-6 Sept. 2017 (pp. 377–386). IEEE Comput. Soc. Press. doi: 10.15439/2017F32
Daszczuk W B. (2018a). Siphon-based deadlock detection in Integrated Model of Distributed Systems (IMDS). In Federated Conference on Computer Science and Information Systems, 3rd Workshop on Constraint Programming and Operation Research Applications (CPORA’18), Poznań, Poland, 9-12 Sept. 2018 (pp. 421–431). IEEE. doi: 10.15439/2018F114
Daszczuk W B. (2018b). Specification and Verification in Integrated Model of Distributed Systems (IMDS). MDPI Computers, 7(4), 1–26. doi: 10.3390/computers7040065
Daszczuk W B. (2019a). Asynchronous Specification of Production Cell Benchmark in Integrated Model of Distributed Systems. In R. Bembenik, L. Skonieczny, G. Protaziuk, M. Kryszkiewicz, & H. Rybinski (Eds.), 23rd International Symposium on Methodologies for Intelligent Systems, ISMIS 2017, Warsaw, Poland, 26-29 June 2017, Studies in Big Data, vol. 40 (pp. 115–129). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-77604-0_9
Daszczuk W B. (2019b). Fairness in Temporal Verification of Distributed Systems. In W. Zamojski, J. Mazurkiewicz, J. Sugier, T. Walkowiak, & J. Kacprzyk (Eds.), 13th International Conference on Dependability and Complex Systems DepCoS-RELCOMEX, 2-6 July 2018, Brunów, Poland, AISC vol.761 (pp. 135–150). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-91446-6_14
Daszczuk W B, Bielecki M, and Michalski J. (2017). Rybu: Imperative-style Preprocessor for Verification of Distributed Systems in the Dedan Environment. In KKIO’17 – Software Engineering Conference, Rzeszów, Poland, 14-16 Sept. 2017. Polish Information Processing Society.
Daszczuk W B, Grabski W, … Wytrębowicz J. (2001). System modeling in the COSMA environment. In Proceedings Euromicro Symposium on Digital Systems Design, Warsaw, Poland, 4-6 Sept. 2001 (pp. 152–157). Warsaw, Poland: IEEE Comput. Soc. doi: 10.1109/DSD.2001.952264
Daszczuk W B, and Mieścicki J. (2001). JADE - a platform for research on cooperation of physical and virtual agents, ICS WUT Research Report No 15/2001.
Daszczuk W B, and Mieścicki J. (2014). Chapter 7.2 Principles of PRT Network Simulation. In W. Choromański (Ed.), Ecomobility. Innovative and Ecological Tranport Means (in Polish) (pp. 193–209). Wydawnictwa Komunikacji i Łączności.
Daszczuk W B, Mieścicki J, … Duplicki K. (1998). A System for Identification of Fluidized Bed Furnace at the Institute of Heat Engineering, WUT (In Polish: System identyfikacji paleniska fluidalnego w Instytucie Techniki Cieplnej PW), ICS WUT Research Report No 23/98.
Daszczuk W B, Mieścicki J, … Dobrowolski H. (1998). The organization of Mobile Computing Systems using the GSM network as the communication subsystem, ICS WUT Technical Report No.15/1998.
Daszczuk W B, Mieścicki J, … Świrski K. (1995). System for the Integration of the Block Digital Control System with the Company Network (in Polish: System Integracji Blokowego Cyfrowego Systemu Kontroli i Sterowania z Siecią Zakładową). In Problemy Badawcze Energetyki Cieplnej, Warszawa, 5-8 Grudnia 1995 (p. tom 1, 101-107). Warszawa: Oficyna Wydawnicza Politechniki Warszawskiej.
Daszczuk W B, Mieścicki J, … Wytrębowicz J. (2001). System Level Specification and Verification Using Concurrent State Machines and COSMA Environment. In 8th International Conference on Mixed Design of Integrated Circuits and Systems, MIXDES’01, Zakopane, Poland, 21-23 June 2001 (pp. 525–532).
Daszczuk W B, and Zuberek W M. (2018). Deadlock Detection in Distributed Systems Using the IMDS Formalism and Petri Nets. In W. Zamojski, J. Mazurkiewicz, J. Sugier, T. Walkowiak, & J. Kacprzyk (Eds.), 12th International Conference on Dependability and Complex Systems, DepCoS-RELCOMEX 2017, Brunów, Poland, 2-6 July 2017. AISC vol 582 (pp. 118–130). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-59415-6_12
De Francesco N, Santone A, and Vaglini G. (1998). State space reduction by non-standard semantics for deadlock analysis. Science of Computer Programming, 30(3), 309–338. doi: 10.1016/S0167-6423(97)00017-8
Dedan. (n.d.). url: http://staff.ii.pw.edu.pl/dedan/files/DedAn.zip
Dedan Examples. (n.d.). url: http://staff.ii.pw.edu.pl/dedan/files/examples.zip
Dick G, and Yao X. (2014). Model representation and cooperative coevolution for finite-state machine evolution. In 2014 IEEE Congress on Evolutionary Computation (CEC), Beijing, China, 6-11 July 2014 (pp. 2700–2707). New York, NY: IEEE. doi: 10.1109/CEC.2014.6900622
Diekert V, and Muscholl A. (2012). On Distributed Monitoring of Asynchronous Systems. In 19th International Workshop on Logic, Language, Information and Computation, WoLLIC 2012, Buenos Aires, Argentina, 3-6 Sept. 2012 (pp. 70–84). Berlin Heidelberg: Springer. doi: 10.1007/978-3-642-32621-9_5
Dierks H. (1996). The production cell: A verified real-time system. In 4th International Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems FTRTFT 1996: Uppsala, Sweden, 9-13 Sept. 1996, LNCS 1135 (pp. 208–227). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-61648-9_42
Dijkstra E W. (1959). A note on two problems in connexion with graphs. Numerische Mathematik, 1(1), 269–271. doi: 10.1007/BF01386390
Dijkstra E W. (1971). Hierarchical ordering of sequential processes. Acta Informatica, 1(2), 115–138. doi: 10.1007/BF00289519
Dijkstra E W, and Scholten C S. (1980). Termination detection for diffusing computations. Information Processing Letters, 11(1), 1–4. doi: 10.1016/0020-0190(80)90021-6
Duri S, Buy U, … Shatz S M. (1994). Application and experimental evaluation of state space reduction methods for deadlock analysis in Ada. ACM Transactions on Software Engineering and Methodology, 3(4), 340–380. doi: 10.1145/201024.201038
Ehlers R, Mattmüller R, and Peter H-J. (2010). Combining Symbolic Representations for Solving Timed Games. In K. Chatterjee & T. A. Henzinger (Eds.), 8th International Conference on Formal Modeling and Analysis of Timed Systems, FORMATS 2010, Klosterneuburg, Austria, 8-10 Sept. 2010, LNCS 6246 (pp. 107–121). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-642-15297-9_10
Elmagarmid A K. (1986). A survey of distributed deadlock detection algorithms. ACM SIGMOD Record, 15(3), 37–45. doi: 10.1145/15833.15837
Emerson E A, Mok A K, … Srinivasan J. (1992). Quantitative temporal reasoning. Real-Time Systems, 4(4), 331–352. doi: 10.1007/BF00355298
Enea C, Habermehl P, … Parlato G. (2014). On the Path-Width of Integer Linear Programming. Electronic Proceedings in Theoretical Computer Science, 161, 74–87. doi: 10.4204/EPTCS.161.9
Fahland D, Favre C, … Wolf K. (2011). Analysis on demand: Instantaneous soundness checking of industrial business process models. Data & Knowledge Engineering, 70(5), 448–466. doi: 10.1016/j.datak.2011.01.004
Fernau H, Holzer M, and Freund R. (2001). Hybrid modes in cooperating distributed grammar systems: internal versus external hybridization. Theoretical Computer Science, 259(1–2), 405–426. doi: 10.1016/S0304-3975(00)00022-0
Francesca G, Santone A, … Villani M L. (2011). Ant Colony Optimization for Deadlock Detection in Concurrent Systems. In 2011 IEEE 35th Annual Computer Software and Applications Conference, Munich, Germany, 18-22 July 2011 (pp. 108–117). IEEE. doi: 10.1109/COMPSAC.2011.22
Frossl J, Gerlach J, and Kropf T. (1996). An efficient algorithm for real-time symbolic model checking. In Proceedings ED&TC European Design and Test Conference, Paris, France, 11-14 March 1996 (pp. 15–20). New York, NY: IEEE Comput. Soc. Press. doi: 10.1109/EDTC.1996.494120
Fuchs M, and Philipps J. (1995). Focus. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 11 (pp. 185–197). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_55
Garanina N O, and Bodin E V. (2014). Distributed Termination Detection by Counting Agent. In 23th International Workshop on Concurrency, Specification and Programming, CS&P, Chemnitz, Germany, 29 Sept. - 1 Oct. 2014 (pp. 69–79). Berlin, Germany: Humboldt University. url: http://ceur-ws.org/Vol-1269/paper69.pdf
Garavel H, and Serwe W. (2017). The Unheralded Value of the Multiway Rendezvous: Illustration with the Production Cell Benchmark. Electronic Proceedings in Theoretical Computer Science, 244, 230–270. doi: 10.4204/EPTCS.244.10
Geilen M, and Basten T. (2003). Requirements on the Execution of Kahn Process Networks. In ESOP’03 the 12th European Symposium on Programming, Warsaw, Poland, 7-11 April 2003, LNCS 2618 (pp. 319–334). Berlin, Heidelberg: Springer-Verlag. doi: 10.1007/3-540-36575-3_22
Gerth R, Kuiper R, … Szreter M. (1999). Partial Order Reductions Preserving Simulations. In Concurrency Specification and Programming (CS&P), Warsaw, Poland, 28-30 Sept. 1999 (pp. 153–171).
Glabbeek R J, and Goltz U. (1990). Equivalences and refinement. In LITP Spring School on Theoretical Computer Science La Roche Posay, France, 23–27 April 1990, LNCS 469 (pp. 309–333). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-53479-2_13
Gluchowski P. (2009). Languages of CTL and RTCTL Calculi in Real-Time Analysis of a System Described by a Fault Tree with Time Dependencies. In 2009 Fourth International Conference on Dependability of Computer Systems, DepCoS - RELCOMEX ’09, Brunów, Poland, 30 June - 2 July 2009 (pp. 33–41). New York, NY: IEEE. doi: 10.1109/DepCoS-RELCOMEX.2009.12
Godefroid P, and Khurshid S. (2002). Exploring Very Large State Spaces Using Genetic Algorithms. In J.-P. Katoen & P. Stevens (Eds.), International Conference on Tools and Algorithms for the Construction and Analysis of Systems -TACAS 2002, Grenoble, France, 8–12 April 2002, LNCS vol. 2280 (pp. 266–280). Berlin Heidelberg: Springer. doi: 10.1007/3-540-46002-0_19
Godefroid P, and Wolper P. (1992). Using partial orders for the efficient verification of deadlock freedom and safety properties. In 3rd International Workshop, CAV ’91, Aalborg, Denmark, 1-4 July, 1991, LNCS 575 (pp. 332–342). Berlin Heidelberg: Springer. doi: 10.1007/3-540-55179-4_32
Gómez R, and Bowman H. (2005). Discrete Timed Automata. Technical Report 3-05-2005. Canterbury, UK. url: https://kar.kent.ac.uk/14362/1/TR305.pdf
Gómez R, and Bowman H. (2007). Efficient Detection of Zeno Runs in Timed Automata. In 5th International Conference on Formal Modeling and Analysis of Timed Systems, FORMATS 2007, Salzburg, Austria, 3-5 Oct. 2007, LNCS 4763 (pp. 195–210). Berlin, Heidelberg: Springer. doi: 10.1007/978-3-540-75454-1_15
Grabski W, Daszczuk W B, … Dobrowolski H. (1999). Verification of the event protocol for establishing and disconnecting a connection in the ESS system (in Polish: Weryfikacja zdarzeniowego protokołu nawiązywania i rozłączania połączenia w systemie ESS), ICS WUT Research Report No.10/1999.
Gradara S, Santone A, and Villani M L. (2005). Using heuristic search for finding deadlocks in concurrent systems. Information and Computation, 202(2), 191–226. doi: 10.1016/j.ic.2005.07.004
Gradara S, Santone A, and Villani M L. (2006). DELFIN+: An efficient deadlock detection tool for CCS processes. Journal of Computer and System Sciences, 72(8), 1397–1412. doi: 10.1016/j.jcss.2006.03.003
Greenyer J, Brenner C, … Gressi E. (2013). Incrementally synthesizing controllers from scenario-based product line specifications. In Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering - ESEC/FSE 2013, Sankt Petersburg, Russia, 18-26 Aug. 2013 (pp. 433–443). New York, NY: ACM Press. doi: 10.1145/2491411.2491445
Gros-Desormeaux H, Fouchal H, and Hunel P. (2008). A Comparison of Distributed Test Generation Techniques. In R. Ben Ayed & K. Djemame (Eds.), Second international conference on Verification and Evaluation of Computer and Communication Systems VECoS’08, Leeds, UK , 2-3 July 2008 (pp. 38–49). Swinton, UK: British Computer Society. url: https://dl.acm.org/citation.cfm?id=2227467
Grosu R, Broy M, … Stefănescu G. (1999). What is Behind UML-RT? In H. Kilov, B. Rumpe, & I. Simmonds (Eds.), Behavioral Specifications of Businesses and Systems (pp. 75–90). Boston, MA: Springer US. doi: 10.1007/978-1-4615-5229-1_6
Grover H, and Kumar S. (2013). Analysis of Deadlock Detection And Resolution Techniques in Distributed Database Environment. International Journal of Computer Engineering & Science, 2(1), 17–25. url: www.ijsrp.org/research-paper-0915/ijsrp-p4581.pdf
Guan X, Li Y, … Wang S. (2012). A Literature Review of Deadlock Prevention Policy Based on Petri Nets for Automated Manufacturing Systems. International Journal of Digital Content Technology and Its Applications, 6(21), 426–433. doi: 10.4156/jdcta.vol6.issue21.48
Hadjidj R, Boucheneb H, and Hadjidj D. (2007). Zenoness detection and timed model checking for real time systems. In K. Barkaoui & M. Ioualalen (Eds.), First international conference on Verification and Evaluation of Computer and Communication Systems, VECoS’07, Algiers, Algeria, 5-6 May 2007 (pp. 120–134). Swinton, UK: British Computer Society. url: www.bcs.org/content/conMediaFile/4764
Hatcliff J, Dwyer M B, and Zheng H. (2000). Slicing Software for Model Construction. Higher-Order and Symbolic Computation, 13(4), 315–353. doi: 10.1023/A:1026599015809
Havelund K, and Pressburger T. (2000). Model checking JAVA programs using JAVA PathFinder. International Journal on Software Tools for Technology Transfer (STTT), 2(4), 366–381. doi: 10.1007/s100090050043
Havelund K, and Skakkebæk J U. (1999). Applying Model Checking in Java Verification. In 5th and 6th International SPIN Workshops, Trento, Italy, July 5, 1999, Toulouse, France, 21 and 24 Sept. 1999 (pp. 216–231). London, UK: Springer-Verlag. doi: 10.1007/3-540-48234-2_17
Heiner M, and Heisel M. (1999). Modeling Safety-Critical Systems with Z and Petri Nets. In M. Felici, K. Kanoun, & A. Pasquini (Eds.), SAFECOMP ’99 Proceedings of the 18th International Conference on Computer Safety, Reliability and Security, Toulouse, France, 27-29 Sept. 1999, LNCS Vol. 1698 (pp. 361–374). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48249-0_31
Heiner M, Schwarick M, and Wegener J-T. (2015). Charlie – An Extensible Petri Net Analysis Tool. In 36th International Conference, PETRI NETS 2015, Brussels, Belgium, 21-26 June 2015 (pp. 200–211). Cham, Switzerland: Springer International Publishing. doi: 10.1007/978-3-319-19488-2_10
Heinkel S, and Lindner T. (1995). SDL. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 10 (pp. 171–183). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_54
Heußner A, Poskitt C M, … Morandi B. (2015). Towards Practical Graph-Based Verification for an Object-Oriented Concurrency Model. Electronic Proceedings in Theoretical Computer Science, 181, 32–47. doi: 10.4204/EPTCS.181.3
Hilbrich T, de Supinski B R, … Müller M S. (2013). Distributed wait state tracking for runtime MPI deadlock detection. In Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis on - SC ’13, Denver, CO, 17-21 Nov. 2013 (pp. 1–12). New York, New York, USA: ACM Press. doi: 10.1145/2503210.2503237
Hilbrich T, de Supinski B R, … Müller M S. (2009). A graph based approach for MPI deadlock detection. In Proceedings of the 23rd international conference on Conference on Supercomputing - ICS ’09, Yorktown Heights, NY, 8-12 June 2009 (pp. 296–305). New York, NY: ACM Press. doi: 10.1145/1542275.1542319
Hiraishi H. (2000). Verification of deadlock free property of high level robot control. In Proceedings of the Ninth Asian Test Symposium ATS 2000, Taipei, 4-6 Dec. 2000 (pp. 198–203). New York, NY: IEEE Comput. Soc. doi: 10.1109/ATS.2000.893625
Hoare C A R. (1978). Communicating sequential processes. Communications of the ACM, 21(8), 666–677. doi: 10.1145/359576.359585
Holenderski L. (1995). Lustre. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 6 (pp. 101–112). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_50
Holt R C. (1972). Some Deadlock Properties of Computer Systems. ACM Computing Surveys, 4(3), 179–196. doi: 10.1145/356603.356607
Holzmann G J. (1995). Tutorial: Proving properties of concurrent systems with SPIN. In 6th International Conference on Concurrency Theory, CONCUR’95, Philadelphia, PA, 21–24 Aug. 1995 (pp. 453–455). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-60218-6_34
Holzmann G J. (1997). The model checker SPIN. IEEE Transactions on Software Engineering, 23(5), 279–295. doi: 10.1109/32.588521
Hosseini R, and Haghighat A T. (2005). An Improved Algorithm for Deadlock Detection and Resolution in Mobile Agent Systems. In International Conference on Computational Intelligence for Modelling, Control and Automation and International Conference on Intelligent Agents, Web Technologies and Internet Commerce (CIMCA-IAWTIC’06), Vienna, Austria, 28-30 Nov. 2005, Vol.2 (Vol. 2, pp. 1037–1042). New York, NY: IEEE. doi: 10.1109/CIMCA.2005.1631606
Huang S-T. (1989). Detecting termination of distributed computations by external agents. In [1989] Proceedings. The 9th International Conference on Distributed Computing Systems, Newport Beach, CA, 5-9 June 1989 (pp. 79–84). New York, NY: IEEE Comput. Soc. Press. doi: 10.1109/ICDCS.1989.37933
Huguet S, and Petit A. (1995). Modular constructions of distributing automata. In Mathematical Foundations of Computer Science 1995, 20th International Symposium, MFCS’95, Prague, Czech Republic, 28 Aug. - 1 Sept. 1995 (pp. 467–478). Berlin Heidelberg: Springer. doi: 10.1007/3-540-60246-1_152
Hui P, and Chikkagoudar S. (2012). A Formal Model For Real-Time Parallel Computation. Electronic Proceedings in Theoretical Computer Science, 105, 39–55. doi: 10.4204/EPTCS.105.4
Hung Y-C, and Chen G-H. (2006). Reverse reachability analysis: A new technique for deadlock detection on communicating finite state machines. Software: Practice and Experience, 23(9), 965–979. doi: 10.1002/spe.4380230904
Inverso O, Nguyen T L, … Parlato G. (2015). Lazy-CSeq: A Context-Bounded Model Checking Tool for Multi-threaded C-Programs. In 2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE), Lincoln, NE, 9-13 Nov. 2015 (pp. 807–812). New York, NY: IEEE. doi: 10.1109/ASE.2015.108
Isloor S S, and Marsland T A. (1980). The Deadlock Problem: An Overview. Computer, 13(9), 58–78. doi: 10.1109/MC.1980.1653786
Jacobs J, and Simpson A. (2015). A Formal Model of SysML Blocks Using CSP for Assured Systems Engineering. In Formal Techniques for Safety-Critical Systems, Third International Workshop, FTSCS 2014, Luxembourg, 6-7 Nov. 2014, Communications in Computer and Information Science 476 (pp. 127–141). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-319-17581-2_9
Jard C, and Jéron T. (1992). Bounded-memory algorithms for verification on-the-fly. In International Conference on Computer Aided Verification - CAV 1991, Aalborg, Denmark, 1–4 July 1991 (pp. 192–202). Berlin Heidelberg: Springer. doi: 10.1007/3-540-55179-4_19
Jensen K, and Kristensen L M. (2009). Coloured Petri Nets. Berlin, Heidelberg: Springer-Verlag. doi: 10.1007/b95112
Jia W, and Zhou W. (2005). Distributed Network Systems. From Concepts to Implementations. New York: Springer. doi: 10.1007/b102545
Johnsen E B, Blanchette J C, … Owe O. (2009). Intra-Object versus Inter-Object: Concurrency and Reasoning in Creol. Electronic Notes in Theoretical Computer Science, 243, 89–103. doi: 10.1016/j.entcs.2009.07.007
Joosten S J C, Julien F V, and Schmaltz J. (2014). WickedXmas: Designing and Verifying on-chip Communication Fabrics. In 3rd International Workshop on Design and Implementation of Formal Tools and Systems, DIFTS’14, Lausanne, Switzerland, 20 Oct. 2014 (pp. 1–8). Eindhoven, The Netherlands: Technische Universiteit Eindhoven. url: https://pure.tue.nl/ws/files/3916267/889737443709527.pdf
Karacali B, Kuo-Chung Tai, and Vouk M A. (2000). Deadlock detection of EFSMs using simultaneous reachability analysis. In Proceeding International Conference on Dependable Systems and Networks. DSN 2000, New York, NY, 25-28 June 2000 (pp. 315–324). New York, NY: IEEE Comput. Soc. doi: 10.1109/ICDSN.2000.857555
Karatkevich A, and Grobelna I. (2014). Deadlock detection in Petri nets: One trace for one deadlock? In 2014 7th International Conference on Human System Interactions (HSI), Costa da Caparica, Lisbon, Portugal, 16-18 June 2014 (pp. 227–231). New York, NY: IEEE. doi: 10.1109/HSI.2014.6860480
Katoen J-P. (1999). Concepts, algorithms, and tools for model checking. Erlangen-Nürnberg, Germany.
Kaveh N. (2001). Using Model Checking to Detect Deadlocks in Distributed Object Systems. In W. Emmerich & S. Tai (Eds.), 2nd International Workshop on Distributed Objects, Davis, CA, 2-3 Nov. 2000, LNCS vol.1999 (pp. 116–128). London, UK: Springer-Verlag. doi: 10.1007/3-540-45254-0_11
Kaveh N, and Emmerich W. (2001). Deadlock detection in distribution object systems. In Proceedings of the 8th European software engineering conference held jointly with 9th ACM SIGSOFT international symposium on Foundations of software engineering - ESEC/FSE-9, Vienna, Austria, 10-14 Sept. 2001 (pp. 44–51). New York, NY: ACM Press. doi: 10.1145/503209.503216
Kern C, and Greenstreet M R. (1999). Formal verification in hardware design: a survey. ACM Transactions on Design Automation of Electronic Systems, 4(2), 123–193. doi: 10.1145/307988.307989
Kessler C, and Keller J. (2007). Models for Parallel Computing: Review and Perspectives. In PARS-Mitteilungen, 13-29 Dec. 2007 (pp. 13–29). url: http://www.ida.liu.se/~chrke/modelsurvey.pdf
Kesten Y, Pnueli A, and Raviv L. (1998). Algorithmic verification of linear temporal logic specifications. In 25th International Colloquium, ICALP’98 Aalborg, Denmark, 13–17 July 1998 (pp. 1–16). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/BFb0055036
Klingenbeck S, and Käufl T. (1995). Tatzelwurm. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 14 (pp. 247–259). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_58
Knapp E. (1987). Deadlock detection in distributed databases. ACM Computing Surveys, 19(4), 303–328. doi: 10.1145/45075.46163
Kokash N, and Arbab F. (2008). Formal Behavioral Modeling and Compliance Analysis for Service-Oriented Systems. In F. S. de Boer (Ed.), Formal Methods for Components and Objects - 7th International Symposium, FMCO 2008, Sophia Antipolis, France, 21-23 Oct. 2008, LNCS 5751 (pp. 21–41). Berlin Heidelberg: Springer. doi: 10.1007/978-3-642-04167-9_2
Korf F, and Schlör R. (1995). Symbolic Timing Diagrams. In C. Lewerentz & T. Lindner (Eds.), Formal Development of Reactive Systems. LNCS Vol. 891, chapt. 18 (pp. 311–331). Berlin Heidelberg: Springer. doi: 10.1007/3-540-58867-1_62
Krishnan P. (2000). Distributed Timed Automata. Electronic Notes in Theoretical Computer Science, 28, 5–21. doi: 10.1016/S1571-0661(05)80627-9
Krithivasan K, Balan M S, and Harsha P. (1999). Distributed Processing in Automata. International Journal of Foundations of Computer Science, 10(04), 443–463. doi: 10.1142/S0129054199000319
Krithivasan K, and Ramanujan A. (2013). On The Power of Distributed Bottom-up Tree Automata. International Journal of Advanced Computer Science, 3(4), 184–190. url: http://worldcomp-proceedings.com/proc/p2011/FCS2998.pdf
Krystosik A. (2006). Embedded Systems Modeling Language. In 2006 International Conference on Dependability of Computer Systems, , DepCos-RELCOMEX ’06, Szklarska Poręba, Poland, 25-27 May 2006 (pp. 27–34). Berlin Heidelberg: Springer. doi: 10.1109/DEPCOS-RELCOMEX.2006.21
Krystosik A, and Turlej D. (2006). EMLAN: A language for model checking of embedded systems software. In IFAC Workshop on Programmable Devices and Embedded Systems, Brno, Czech Republic, 14-16 Feb. 2006 (pp. 126–131). Elsevier Science.
Kshemkalyani A D, and Mukesh S. (2008). Distributed Computing. Principles, Algorithms, and Systems. Cambridge, UK: Cambridge University Press.
Kumar D. (1985). A class of termination detection algorithms for distributed computations. In Fifth Conference on Foundations of Software Technology and Theoretical Computer Science, New Delhi, India 16–18 Dec. 1985 (pp. 73–100). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-16042-6_4
Kwiatkowska M, Norman G, and Parker D. (2011). PRISM 4.0: Verification of Probabilistic Real-Time Systems. In 23rd International Conference, CAV 2011, Snowbird, UT, 14-20 July 2011 (pp. 585–591). Berlin Heidelberg: Springer. doi: 10.1007/978-3-642-22110-1_47
Lanese I, and Montanari U. (2006). Hoare vs Milner: Comparing Synchronizations in a Graphical Framework With Mobility. Electronic Notes in Theoretical Computer Science, 154(2), 55–72. doi: 10.1016/j.entcs.2005.03.032
Larsen P G, Fitzgerald J S, and Riddle S. (2009). Practice-oriented courses in formal methods using VDM++. Formal Aspects of Computing, 21(3), 245–257. doi: 10.1007/s00165-008-0068-5
Laskowski E, Tudruj M, … Toursel B. (2005). Java Byte Code Scheduling Based on the Most-Often-Used-Paths in Programs with Branches. In The 4th International Symposium on Parallel and Distributed Computing (ISPDC’05), Lille, France, 4-6 July 2005 (pp. 21–27). New York, NY: IEEE. doi: 10.1109/ISPDC.2005.31
Latvala T, Biere A, … Junttila T. (2004). Simple Bounded LTL Model Checking. In A. J. Hu & A. K. Martin (Eds.), International Conference on Formal Methods in Computer-Aided Design, Austin, TX, 15-17 Nov. 2004, LNCS 3312 (pp. 186–200). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-30494-4_14
Lee G M, Crespi N, … Boussard M. (2013). Internet of Things. In Evolution of Telecommunication Services, LNCS 7768 (pp. 257–282). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-642-41569-2_13
Leibfried T F. (1989). A deadlock detection and recovery algorithm using the formalism of a directed graph matrix. ACM SIGOPS Operating Systems Review, 23(2), 45–55. doi: 10.1145/858344.858348
Lewerentz C, and Lindner T (Eds.). (1995). Formal Development of Reactive Systems, LNCS 891. Berlin, Heidelberg: Springer-Verlag. doi: 10.1007/3-540-58867-1
Li T, Ellis C S, … Sorin D J. (2005). Pulse : A Dynamic Deadlock Detection Mechanism Using Speculative Execution. In USENIX Annual Technical Conference, Anaheim, CA, 10-15 April 2005 (pp. 31–44). Berkeley, CA: USENIX Association. url: http://usenix.org/legacy/publications/library/proceedings/usenix05/tech/general/full_papers/li/li.pdf
Lime D, and Roux O H. (2006). Model Checking of Time Petri Nets Using the State Class Timed Automaton. Discrete Event Dynamic Systems, 16(2), 179–205. doi: 10.1007/s10626-006-8133-9
Longley D, and Shain M. (1986). Dictionary of information technology. London: Macmillan Press.
López-Grao J-P, and Colom J-M. (2010). The Resource Allocation Problem in Software Applications: A Petri Net Perspective. In S. Donatelli (Ed.), RAPNeC-2010 Recent Advances in Petri Nets and Concurrency., Edition: Volume 827 of CEUR Workshop Proceedings (pp. 219–233). CEUR. url: http://ceur-ws.org/Vol-827/19_Juan-PabloLopez-Grao_article.pdf
Ma C, and Wonham W M. (2005). The Production Cell Example. Chapter 5. In Nonblocking Supervisory Control of State Tree Structures. Lecture Notes in Control and Information Science 317 (pp. 127–144). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/11382119_5
Ma G. (2007). Model checking support for CoreASM: model checking distributed abstract state machines using Spin, MSc Thesis. Simon Fraser University, Burnaby, Canada. url: http://summit.sfu.ca/system/files/iritems1/8056/etd2938.pdf
Madhusudan P, and Parlato G. (2011). The tree width of auxiliary storage. In Proceedings of the 38th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages - POPL ’11, Austin, TX, 26-28 Jan. 2011 (pp. 283–294). New York, New York, USA: ACM Press. doi: 10.1145/1926385.1926419
Magee J, and Kramer J. (1999). Concurrency: Models and Programs - From Finite State Models to Java Programs. Chichester: John Wiley.
Martens M. (2009). Establishing Properties of Interaction Systems, PhD Thesis. University of Mannheim. url: http://ub-madoc.bib.uni-mannheim.de/2629/1/DrArbeitMyThesis.pdf
Masticola S P, and Ryder B G. (1990). Static Infinite Wait Anomaly Detection in Polynomial Time. In 1990 International Conference on Parallel Processing, Urbana-Champaign, IL, 13-17 Aug. 1990 (p. Vol.2, 78-87). University Park, PA: Pennsylvania State University Press. url: https://rucore.libraries.rutgers.edu/rutgers-lib/57963/
Matocha J, and Camp T. (1998). A taxonomy of distributed termination detection algorithms. Journal of Systems and Software, 43(3), 207–221. doi: 10.1016/S0164-1212(98)10034-1
Mattern F. (1987). Algorithms for distributed termination detection. Distributed Computing, 2(3), 161–175. doi: 10.1007/BF01782776
Mattern F. (1989). Global quiescence detection based on credit distribution and recovery. Information Processing Letters, 30(4), 195–200. doi: 10.1016/0020-0190(89)90212-3
May D. (1983). OCCAM. ACM SIGPLAN Notices, 18(4), 69–79. doi: 10.1145/948176.948183
Mazuelo C L. (2008). Automatic Model Checking of UML models. Universitat Berlin. url: http://www.iam.unibe.ch/tilpub/2008/lar08.pdf
McMillan K L. (1993). Symbolic Model Checking. Norwell, MA: Kluwer Academic Publishers.
Mieścicki J. (2006). The use of model checking and the COSMA environment in the design of reactive systems. Annales UMCS, Informatica Vol. AI, 4AI, 244–253. doi: 10.17951/ai.2006.4.1.244-253
Mieścicki J, Baszun M, … Czejdo B. (1996). Verification of Concurrent Engineering Software Using CSM Models. In 2nd World Conf. on Integrated Design and Process Technology, Austin, TX, 1-4 Dec. 1996 (pp. 322–330). Dallas, TX: SDPS.
Mieścicki J, Czejdo B, and Daszczuk W B. (2004). Model Checking In The COSMA Environment as a Support For The Design of Pipelined Processing. In European Congress on Computational Methods in Applied Sciences and Engineering ECCOMAS 2004, Jyväskylä, Finland, 24-28 July 2004. Jyväskylä, Finland.
Mieścicki J, and Daszczuk W B. (2006). Behavioral and real-time verification of a pipeline in the COSMA environment. Annales UMCS, Informatica Vol. AI, 4AI, 254–265. doi: 10.17951/ai.2006.4.1.254-265
Mieścicki J, Daszczuk W B, … Adamiec R. (1992). KURMAN: The system supporting the design of multidimensional automated control systems (in Polish KURMAN: System wspomagający projektowanie wielowymiarowych układów automatycznej regulacji), ICS WUT Research Report No 10/92.
Mieścicki J, Dobrowolski H, and Daszczuk W B. (2003). Model checking of multi-agent system’s communication protocols specified using the Z notation, ICS WUT Research Report No.17/2003.
Mieścicki J, Flisiak D, … Daszczuk W B. (1998). Specification and verification of SMS-based data stream protocol, ICS WUT Research Report No 16/98.
Mieścicki J, Kurman K J, and Daszczuk W B. (1995). MIKOZ: The method for identification and coordination of feedback interactions in the regulation of continuous technological processes (in Polish: MIKOZ: Metoda identyfikacji i koordynacji oddziaływań zwrotnych), ICS WUT Research Report No. 26/95.
Miller S P, Whalen M W, and Cofer D D. (2010). Software model checking takes off. Communications of the ACM, 53(2), 58–64. doi: 10.1145/1646353.1646372
Milner R. (1983). Calculi for synchrony and asynchrony. Theoretical Computer Science, 25(3), 267–310. doi: 10.1016/0304-3975(83)90114-7
Milner R. (1984). A Calculus of Communicating Systems. Berlin Heidelberg: Springer-Verlag.
Mitchell D P, and Merritt M J. (1984). A distributed algorithm for deadlock detection and resolution. In Proceedings of the third annual ACM symposium on Principles of distributed computing - PODC ’84, Vancouver, Canada, 27-29 Aug. 1984 (pp. 282–284). New York, NY: ACM Press. doi: 10.1145/800222.806755
Mohalik S, and Ramanujam R. (2002). Distributed automata in an assumption-commitment framework. Sadhana, 27(2), 209–250. doi: 10.1007/BF02717184
Moy Y, Ledinot E, … Monate B. (2013). Testing or Formal Verification: DO-178C Alternatives and Industrial Experience. IEEE Software, 30(3), 50–57. doi: 10.1109/MS.2013.43
Mukund M. (2012). Automata on Distributed Alphabets. In Modern Applications of Automata Theory (pp. 257–288). Co-Published with Indian Institute of Science (IISc), Bangalore, India. doi: 10.1142/9789814271059_0009
Muscholl A. (2015). Automated Synthesis of Distributed Controllers. In Automata, Languages, and Programming - 42nd International Colloquium, {ICALP} 2015, Kyoto, Japan, 6-10 July 2015, Part {II} (pp. 11–27). doi: 10.1007/978-3-662-47666-6_2
Nardone R, Gentile U, … Mazzocca N. (2016). Modeling Railway Control Systems in Promela (pp. 121–136). doi: 10.1007/978-3-319-29510-7_7
NASA. (2007). NASA Systems Engineering Handbook. NASA. url: http://www.acq.osd.mil/se/docs/NASA-SP-2007-6105-Rev-1-Final-31Dec2007.pdf
Natarajan N. (1986). A distributed scheme for detecting communication deadlocks. IEEE Transactions on Software Engineering, SE-12(4), 531–537. doi: 10.1109/TSE.1986.6312900
Nguyen H H C, Le V S, and Nguyen T T. (2014). Algorithmic approach to deadlock detection for resource allocation in heterogeneous platforms. In 2014 International Conference on Smart Computing, Hong Kong, 3-5 Nov. 2014 (pp. 97–103). New York, NY: IEEE. doi: 10.1109/SMARTCOMP.2014.7043845
Ni Q, Sun W, and Ma S. (2009). Deadlock Detection Based on Resource Allocation Graph. In 2009 Fifth International Conference on Information Assurance and Security, Xian, China, 18-20 Aug. 2009 (pp. 135–138). IEEE. doi: 10.1109/IAS.2009.64
Niebert P. (1995). A ν-calculus with local views for systems of sequential agents. In 20th International Symposium on Mathematical Foundations of Computer Science MFCS ’95, Prague, Czech Republic, 28 Aug. - 1 Sept. 1995 (pp. 563–573). London, UK: Springer-Verlag. doi: 10.1007/3-540-60246-1_161
Olson A G, and Evans B L. (2005). Deadlock Detection For Distributed Process Networks. In ICASSP ’05. IEEE International Conference on Acoustics, Speech, and Signal Processing, Philadelphia, PA, 18-23 March 2005, Vol.V (Vol. 5, pp. 73–76). New York, NY: IEEE. doi: 10.1109/ICASSP.2005.1416243
Park Y C, and Scheuermann P. (1991). A deadlock detection and resolution algorithm for sequential transaction processing with multiple lock modes. In 1991 The Fifteenth Annual International Computer Software & Applications Conference, Tokyo, Japan, 11-13 Sept. 1991 (pp. 70–77). New York, NY: IEEE Comput. Soc. Press. doi: 10.1109/CMPSAC.1991.170154
Păun G. (1995). Grammar systems: A grammatical approach to distribution and cooperation. In Automata, Languages and Programming (pp. 429–443). Newark, NJ: Gordon and Breach Science Publishers, Inc. doi: 10.1007/3-540-60084-1_94
Pedersen M H, Christiansen M K, and Glæsner T. (2000). Solving the Priority Inversion Problem in legOS. Aalborg, Denmark. url: http://www.it.uu.se/edu/course/homepage/realtid/p2ht08/lego/prioinvers.pdf
Penczek W, Szreter M, … Kuiper R. (2000). Improving Partial Order Reductions for Universal Branching Time Properties. Fundamenta Informaticae, 43(1–4), 245–267. doi: 10.3233/FI-2000-43123413
Peri S, and Mittal N. (2004). On Termination Detection in an Asynchronous Distributed System. In 17th ISCA International Conference on Parallel and Distributed Computing Systems (PDCS), San Francisco, CA, 15-17 Sept. 2004 (pp. 209–215). url: http://www.iith.ac.in/~sathya_p/index_files/PDCS-Transtd.pdf
Perna J, and George C. (2006). Model checking RAISE specifications. url: http://i.unu.edu/media/unu.edu/publication/1550/report331.pdf
Petit A. (1993). Recognizable trace languages, distributed automata and the distribution problem. Acta Informatica, 30(1), 89–101. doi: 10.1007/BF01200264
Petrovic T, Bogdan S, and Sindicic I. (2009). Determination of circular waits in multiple-reentrant flowlines based on machine-job incidence matrix. In European Control Conference (ECC) 2009, Budapest, Hungary, 23-26 Aug. 2009 (pp. 4463–4468). New York, NY: IEEE. url: http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7075103
Pira E, Rafe V, and Nikanjam A. (2017). Deadlock detection in complex software systems specified through graph transformation using Bayesian optimization algorithm. Journal of Systems and Software, 131(Sept.), 181–200. doi: 10.1016/j.jss.2017.05.128
Pnueli A, and Sa’ar Y. (2008). All You Need Is Compassion. In 9th International Conference on Verification, Model Checking, and Abstract Interpretation, VMCAI 2008, San Francisco, CA, 7-9 Jan. 2008 (pp. 233–247). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-540-78163-9_21
Podelski A, and Rybalchenko A. (2003). Software Model Checking of Liveness Properties via Transition Invariants, Research Report MPI–I–2003–2–00, Max Planck Institite fur Informatik, December 2003. url: https://www7.in.tum.de/~rybal/papers/MPI-I-2003-2-004.liveness-via-transition-invariants.pdf
Popescu C, and Martinez Lastra J L. (2010). Formal Methods in Factory Automation. In J. Silvestre-Blanes (Ed.), Factory Automation (pp. 463–475). Rijeka, Croatia: InTech. doi: 10.5772/9526
Priority Inversion and Deadlock. Whitepaper. (2011). url: http://code-time.com/pdf/Priority Inversion and Deadlock.pdf
Puhakka A, and Valmari A. (2000). Livelocks, Fairness and Protocol Verification. In 16th World Conf. on Software: Theory and Practice, Beijing, China, 21-25 Aug. 2000, IFIP (pp. 471–479). Laxenburg, Austria: International Federation for Information Processing. url: http://www.cs.tut.fi/ohj/VARG/publications/00-3.ps
Ramakrishnan S, and McGregor J. (2000). Modelling and Testing OO Distributed Systems with Temporal Logic Formalisms. In 8th International IASTED Conference Applied Informatics’ 2000, Innsbruck, Austria, 14-17 Feb. 2000. url: https://research.monash.edu/en/publications/modelling-and-testing-oo-distributed-systems-with-temporal-logic-
Ray I, and Ray I. (2001). Detecting Termination of Active Database Rules Using Symbolic Model Checking. In 5th East European Conference on Advances in Databases and Information Systems, ADBIS ’01, Vilnius, Lithuania, 25–28 Sept. 2001 (pp. 266–279). London, UK: Springer-Verlag. doi: 10.1007/3-540-44803-9_21
Reniers M A, and Willemse T A C. (2011). Folk Theorems on the Correspondence between State-Based and Event-Based Systems. In 37th Conference on Current Trends in Theory and Practice of Computer Science, Nový Smokovec, Slovakia, 22-28 Jan. 2011 (pp. 494–505). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-642-18381-2_41
Rosa N S, and Cunha P R F. (2004). A Software Architecture-Based Approach for Formalising Middleware Behaviour. Electronic Notes in Theoretical Computer Science, 108, 39–51. doi: 10.1016/j.entcs.2004.01.011
Royer J. (2001). Formal specification and temporal proof techniques for mixed systems. In Proceedings 15th International Parallel and Distributed Processing Symposium. IPDPS 2001, San Francisco, CA, 23-27 April 2001 (pp. 1542–1551). New York, NY: IEEE Comput. Soc. doi: 10.1109/IPDPS.2001.925139
Rozier K Y. (2011). Linear Temporal Logic Symbolic Model Checking. Computer Science Review, 5(2), 163–203. doi: 10.1016/j.cosrev.2010.06.002
Ruf J, and Kropf T. (1999). Modeling and Checking Networks of Communicating Real-Time Processes. In L. Pierre & T. Kropf (Eds.), CHARME’99, Advanced Research Working Conference on Correct Hardware Design and Verification Methods, BadHerrenalb, Germany, 27-29 Sept. 1999, LNCS 1703 (pp. 267–279). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48153-2_20
Ruf J, and Kropf T. (2003). Symbolic Verification and Analysis of Discrete Timed Systems. Formal Methods in System Design, 23(1), 67–108. doi: 10.1023/A:1024437214071
Rybu. (n.d.). https://zyla.neutrino.re/rybu/
Sandholm A B, and Schwartzbach M I. (1997). Distributed Safety Controllers for Web Services. BRICS Report Series, 4(47). doi: 10.7146/brics.v4i47.19268
Santone A. (2002). Automatic verification of concurrent systems using a formula-based compositional approach. Acta Informatica, 38(8), 531–564. doi: 10.1007/s00236-002-0084-5
Savoiu N, Shukla S K, and Gupta R K. (2002). Automated concurrency re-assignment in high level system models for efficient system-level simulation. In Proceedings 2002 Design, Automation and Test in Europe Conference and Exhibition, Paris, France, 4-8 March 2002 (pp. 875–881). IEEE Comput. Soc. doi: 10.1109/DATE.2002.998404
Schaefer I, and Hahnle R. (2011). Formal Methods in Software Product Line Engineering. Computer, 44(2), 82–85. doi: 10.1109/MC.2011.47
Schmid H A, and Best E. (1978). A step towards a solution of the liveness problem in Petri nets. Newcastle upon Tyne. url: http://www.cs.ncl.ac.uk/publications/trs/papers/114.pdf
Scholten C S, and Dijkstra E W. (1982). A Class of Simple Communication Patterns. In Selected Writings on Computing: A personal Perspective (pp. 334–337). New York, NY: Springer New York. doi: 10.1007/978-1-4612-5695-3_60
Schröter C, Schwoon S, and Esparza J. (2003). The Model-Checking Kit. In 24th International Conference ICATPN 2003: Eindhoven, The Netherlands, June 23-27, 2003, LNCS 2697 (pp. 463–472). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-44919-1_29
Schwarick M. (2013). Marcie - An analysis tool for Generalized Stochastic Petri nets. Cottbus. url: http://www-dssz.informatik.tu-cottbus.de/publications/papers/MARCIE_manual_oct_2013.pdf
Sebesta R W. (1996). Concepts of Programming Languages. Reading, MA: Addison-Wesley Publishing Compan.
Sharma N K, and Bhargava B. (1987). A Robust Distributed Termination Detection Algorithm, Report 87-726. West Lafayette, IN. url: http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1626&context=cstech
Shi L, and Liu Y. (2010). Modeling and verification of transmission protocols: A case study on CSMA/CD protocol. In SSIRI-C 2010 - 4th IEEE International Conference on Secure Software Integration and Reliability Improvement Companion, Singapore, 9-11 June 2010 (pp. 143–149). Washington: IEEE Computer Society. doi: 10.1109/SSIRI-C.2010.33
Singhal M. (1989). Deadlock detection in distributed systems. Computer, 22(11), 37–48. doi: 10.1109/2.43525
Sokolsky O, Lee I, and Ben-Abdallah H. (1999). Specification and Analysis of Real-Time Systems with PARAGON (equivalence checking). Philadelphia, PA. url: https://www.cis.upenn.edu/~sokolsky/ase99.pdf
Stirling C, and Walker D. (1991). Local model checking in the modal mu-calculus. Theoretical Computer Science, 89(1), 161–177. doi: 10.1016/0304-3975(90)90110-4
Tai K. (1994). Definitions and Detection of Deadlock, Livelock, and Starvation in Concurrent Programs. In D. P. Agrawal (Ed.), 1994 International Conference on Parallel Processing (ICPP’94), Raleigh, NC, 15-19 Aug. 1994 (pp. 69–72). Boca Raton: CRC Press. doi: 10.1109/ICPP.1994.84
Tricas F, Colom J M, and Merelo J J. (2014). Computing minimal siphons in Petri Net models of resource allocation systems: An evolutionary approach. In CEUR Workshop ProceedingsCEUR Workshop Proceedings, Petri Nets and Software Engineering, Tunis, Tunisia, 23-24 June 2014 (Vol. 1160, pp. 307–322). Tunis. doi: 10.1109/TSMCA.2005.855751
Tricas F, Garcia-Valles F, … Ezpeleta J. (2005). A Petri Net Structure– Based Deadlock Prevention Solution for Sequential Resource Allocation Systems. In 2005 IEEE International Conference on Robotics and Automation, Barcelona, Spain, 18 - 22 April 2005 (pp. 271–277). New York, NY: IEEE. doi: 10.1109/ROBOT.2005.1570131
UML. (n.d.). http://www.uml.org/
Valmari A. (1994). State of the Art Report: STUBBORN SETS. Petri Net Newsletter, 46, 6–14.
Valmari A, and Hansen H. (2010). Can Stubborn Sets Be Optimal? In 31st International Conference, PETRI NETS 2010, Braga, Portugal, 21-25 June 2010 (pp. 43–62). Berlin Heidelberg: Springer. doi: 10.1007/978-3-642-13675-7_5
van der Aalst W M P. (1998). The Application of Petri Nets to Workflow Management. Journal of Circuits, Systems and Computers, 08(01), 21–66. doi: 10.1142/S0218126698000043
van der Aalst W M P. (2000). Workflow Verification: Finding Control-Flow Errors Using Petri-Net-Based Techniques. In W. van der Aalst, J. Desel, & A. Oberweis (Eds.), Business Process Management, LNCS vol.1806 (pp. 161–183). Berlin Heidelberg: Springer. doi: 10.1007/3-540-45594-9_11
van Glabbeek R, Goltz U, and Schicke J-W. (2008). On Synchronous and Asynchronous Interaction in Distributed Systems. In 33rd International Symposium, MFCS 2008, Toruń, Poland, 25-29 Aug. 2008 (pp. 16–35). Berlin Heidelberg: Springer. doi: 10.1007/978-3-540-85238-4_2
Vu L H, Haxthausen A E, and Peleska J. (2015). Formal Modeling and Verification of Interlocking Systems Featuring Sequential Release (pp. 223–238). doi: 10.1007/978-3-319-17581-2_15
Waeselynck H, and Thévenod-Fosse P. (1999). A Case Study in Statistical Testing of Reusable Concurrent Objects. In J. Hlavička, E. Maehle, & A. Pataricza (Eds.), Third European Dependable Computing Conference, Prague, Czech Republic, 15-17 Sept. 1999, LNCS 1667 (pp. 401–418). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/3-540-48254-7_27
Węgrzyn A, Karatkevich A, and Bieganowski J. (2004). Detection of Deadlocks and Traps in Petri Nets by means of Thelen’s Prime Implicant Method. Int. Journal of Ajpplied Math and Computer Science, 14(1), 113–121. url: https://www.amcs.uz.zgora.pl/?action=download&pdf=AMCS_2004_14_1_13.pdf
Winskel G, and Nielsen M. (1995). Models for concurrency. Handbook of logic in computer science (vol.4). (S. Abramsky, D. M. Gabbay, & T. S. E. Maibaum, Eds.). Oxford, UK: Oxford University Press.
Wu N, and Zhou M. (2010). Process vs resource-oriented Petri net modeling of automated manufacturing systems. Asian Journal of Control, 12(3), 267–280. doi: 10.1002/asjc.184
Yang Y, Chen X, and Gopalakrishnan G. (2008). Inspect: A Runtime Model Checker for Multithreaded C Programs, Report UUCS-08-004. Salt Lake City, UT. url: http://www.cs.utah.edu/docs/techreports/2008/pdf/UUCS-08-004.pdf
Yeung C-F, Huang S-L, … Law C-K. (1994). A new distributed deadlock detection algorithm for distributed database systems. In TENCON’94 - 1994 IEEE Region 10’s 9th Annual International Conference on: “Frontiers of Computer Technology”, Singapore, 22-26 Aug. 1994, Vol. 1 (pp. 506–510). IEEE. doi: 10.1109/TENCON.1994.369249
Yousefian R, Rafe V, and Rahmani M. (2014). A heuristic solution for model checking graph transformation systems. Applied Soft Computing, 24(Nov.), 169–180. doi: 10.1016/j.asoc.2014.06.055
Zerzelidis A, and Wellings A J. (2005). Requirements for a real-time .NET framework. ACM SIGPLAN Notices, 40(2), 41. doi: 10.1145/1052659.1052666
Zhang H, Aoki T, and Chiba Y. (2015). A Spin-Based Approach for Checking OSEK/VDX Applications. In C. Artho & P. C. Ölveczky (Eds.), FTSCS 2014: Formal Techniques for Safety-Critical Systems, Luxembourg, 6-7 Nov. 2014 (pp. 239–255). Cham, Switzerland: Springer. doi: 10.1007/978-3-319-17581-2_16
Zhou J, Chen X, … Chen D. (2004). M-Guard: A New Distributed Deadlock Detection Algorithm Based on Mobile Agent Technology. In 2nd international conference on Parallel and Distributed Processing and Applications ISPA’04, Hong Kong, China, 13-15 Dec. 2004 (pp. 75–84). Berlin Heidelberg: Springer-Verlag. doi: 10.1007/978-3-540-30566-8_13
Žic J J. (1994). Time-constrained buffer specifications in CSP + T and timed CSP. ACM Transactions on Programming Languages and Systems, 16(6), 1661–1674. doi: 10.1145/197320.197322
Zielonka W. (1987). Notes on finite asynchronous automata. RAIRO - Theoretical Informatics and Applications, 21(2), 99–135. doi: 10.1051/ita/1987210200991
Zorzo A F, Romanovsky A, … Welch I S. (1999). Using coordinated atomic actions to design safety-critical systems: a production cell case study. Software: Practice and Experience, 29(8), 677–697. doi: 10.1002/(SICI)1097-024X(19990710)29:8<677::AID-SPE251>3.0.CO;2-Z
Zuberek W M. (1999). Petri net models of process synchronization mechanisms. In SMC’99 IEEE International Conference on Systems, Man, and Cybernetics, Tokyo, Japan, 12-15 Oct. 1999 (Vol. 1, pp. 841–847). IEEE, Los Alamitos, CA. doi: 10.1109/ICSMC.1999.814201
Zuberek W M. (2009). Siphon-Based Verification of Component Compatibility. In W. Zamojski (Ed.), 2009 Fourth International Conference on Dependability of Computer Systems, DepCos-RELCOMEX’09, Brunów, Poland, 30 June-2 July 2009 (pp. 123–132). Piscataway, NJ: IEEE. doi: 10.1109/DepCoS-RELCOMEX.2009.35


Appendix A – Acronyms, shortcuts and symbols used in the text
^ – exponent, 2^y – powerset induced by a set y
 – LTL operator: eventually 
 – LTL operator: always
x – integer part of positive x
A – set of agents
A-DA3 – agent DA3
a,a1,a’ – agents belonging to A
AE,AN,AS,AW – approaching roads in “road intersection” example – cardinal directions used
AF – CTL operator – always on a path
AG – CTL operator – always on all paths
ANDL – Abstract Net Description Language - file format for Petri nets 
b – set of vectors of variable values in TA, enabling a transition
B(s) – server process of server s
BDD – Binary Decision Diagrams
BMP – graphical file format
BT-IMDS – timed IMDS with state time bounds and action firing time restrictions
C(a) – agent process of agent a
c – hidden clock used for counting action durations and channel delays in T-IMDS
c0,c1,… - clocks of TA
card(X) – cardinality of set X
CBS – Checking By Spheres – the algorithm of temporal formula evaluation, invented by the author and described in his PhD Thesis
CCS – Calculus of Communicating Systems (formalism invented by Milner)
ch!,ch? – sending and receiving over TA channel ch
Charlie – Petri net analyzer
clk – clock used for counting state time bounds and action firing time restrictions in T-IMDS
constr – set of clock values subranges
CSM – Concurrent State Machines (formalism invented by Jerzy Mieścicki)
CSP – Communicating Sequential Processes (formalism invented by C.A.R. Hoare)
CT-IMDS – timed IMDS with channel time delays
CTL – Computation Tree Logic
Da – true in all configurations where a message of the agent a is pending
DA3 – (D-triple A or DA-cubed) Distributed Asynchronous and Autonomous Automata – a formalism equivalent to IMDS
dda(a) – agent a is in deadlock
dds(s) – server s is in deadlock
Dedan – the program for verification of distributed systems, developed by the author
Delfin+ – deadlock finder based on CCS, invented by Gradara, Santone and Villani
D – multiplier of number of steps in 2-vagabonds algorithm
Ds – atomic Boolean formula true in all configurations where at least one message is pending at the server s
E – set of transitions of TA
E1,E2 – markers placed on upper edge of track in “automatic vehicle guidance system” example
Ea – atomic Boolean formula true in all configurations where an action is prepared with a mes-sage of the agent a
EF – CTL operator – eventually on a path
EmLan – the language for specification of concurrent systems, using discrete time constraints, invented by Artur Krystosik
Es – atomic Boolean formula true in all configurations where at least one action is prepared at the server s 
EX – CTL operator – next on a path
F – function assigning new values to the variables in TA
Fa – atomic Boolean formula true in all configurations where a terminating action is prepared with a message of the agent a
Fi – set of transitions of ith server DA3 automaton {(p1,m/m’,p2) or (p1,m/,p2)}
Gi – set of transitions of ith agent DA3 automaton {(m1,p/p’,m2) or (m1,p/p’,tɐi)}
gs – function mapping actions of server s to time durations (subranges)
gchj –function mapping asynchronous subchannels to time delays (subranges)
H – set of all items (states and messages) PM
ICS – Institute of Computer Science
idle(s) – server s is idle
IMDS – Integrated Model of Distributed Systems – the formalism described in the monograph
J(l) – function mapping TA locations to server clock values subranges 
Jchj(sk) - subchannel time invariant 
Jl(l) – set of clock valuations of location l in TA
Jll(l,l’) - set of clock valuations of transition l,l’ in TA
Js() - action time invariant in server s
JPG – graphical file format
J s – action invariant mapping server’s s clock a subrange
K,K1,K2 – process (set of items)
l0,l1,… - locations of TA (l0 - initial location)
L – set of locations of TA
Lab – set of labels of TA transitions
LANs – Local Area Networks
Ls - set of locations of TA corresponding to server s
Lch –set of locations of asynchronous channel
LTL – Linear Temporal Logic
LTS – Labeled Transition System
M – markers placed in the middle of track in “automatic vehicle guidance system” example
M – set of messages
m,m1,m’ – messages of the form (agent,server,service)=(a,s,r)
M(a) – set of messages of agent a
M(s) – set of messages directed to server s
m0i – initial node of ith agent DA3 automaton (ai,sj,r0j) 
Mi – set of nodes of ith agent DA3 automaton {(ai,sj,rj) or tɐi}
Mini  M – set of initial messages
MPA – Message Passing Automata 
N – set of nodes of LTS
N – number of steps in 2-vagabonds algorithm
nS – number of servers
nA – number of agents
O – set of variables of TA
Ō – vector of values of variables of TA
Ō0 – initial vector of values of variables in TA
{Ō} – set of vectors of variable values in TA
{Ō[x]=r} – vectors in {Ō} containing a value r as xth element 
p0i – initial node of ith server DA3 automaton (si,v0si)
Pi – set of nodes of ith server DA3 automaton {(si,v)}
p,p1,p’ – server states of the form (server,value)=(s,v)
pi – node of ith server DA3 automaton (si,v)
psd(ps,,g()) - location of TA connected with the state ps
P – set of servers’ states
P(s) – set of states of serves s
Pini  P – set of initial states
PDA – Pushdown distributed automata 
PDF – graphical file format
Pi – set of nodes of ith server DA3 automaton {(si,v)}
pi – node of ith server DA3 automaton (si,v)
PNG – graphical file format
Q – set of synchronous UTA channels implementing T-IMDS asynchronous channels
QNE,QNW,QSE,QSW – quarters or crossing in “road intersection” example – cardinal directions used
QSCTL – temporal logic: Computation Tree Logic (CTL) with state quantification and operators relative to component state machines, invented by the author and described in his PhD Thesis
R – set of services
r,r1,r’ – services belonging to R
R1…R6 – resources used in “automatic vehicle guidance system” example
RAG – Resource Allocation Graph 
RPC – Remote Procedure Call
Rybu – imperative language-based preprocessor of the Dedan program
S – set of servers
S-DA3 – server DA3
s,s1,s’ – servers belonging to S
SMV – Symbolic Model Verifier – model checker
Spin – model checker
T – global system configuration TS TM
TA – timed automata
T-IMDS – timed version of IMDS
TCTL – Timed Computation Tree Logic
TempoRG – the verifier developed by the author of this monograph, described in his PhD Thesis
term(a) – agent a terminates
Tini – initial configuration
Tinp(l) – input configuration of action l
TM – set of pending messages {(a,s,r)}
Tout(l) – output configuration of action l
TS – global system state {(s,v)}
TɄ ,TɄ’ – global node of agent DA3 automata (mi, Y; i=1..n)
TɄ0 – initial global node of agent DA3 automata (m0i, Y0; i=1..n)
TƧ ,TƧ’ – global node of server DA3 automata ((pi,Xi))
TƧ0 – initial global node of server DA3 automata ((p0i,X0i))
u – valuation of set of clock variables in TA
u0 – all clocks equal 0
U – set of valid servers’ services {(s,r)}
UML – Unified Modeling Language
Uppaal – model checker
UTA – Uppaal timed automata
V – set of values
v,v1,v’ – values belonging to V
W – set of transitions of LTS
W – set of values of TA variable O
WFG – Wait-For Graph
WUT – Warsaw University of Technology
X0i – initial input set of server DA3 automaton, X0i  2^{m=(a,si,ri)} 
Xi  – input set of server DA3 automaton, Xi  2^{m=(a,si,ri)}
Y0 – initial global input vector of the set of agent DA3 automata Y0[i]=[(si,v0i)] 
Y – global input vector of the set of agent DA3 automata (the same for all ɐ in the system) 
Y[i]=(si,vi)
Y[i] – ith element of global input vector Y 
Ῡp – set of current locations of all UTA server automata
Ῡch – set of current locations of all UTA channel automata
Z – set of clocks of TA
 – succession relation 
 – set of actions {(p,m)  (p’,m’)}   {(p,m)  (p’)}
a – set of actions of agent a
s – set of actions of server s
l – action belonging to 
 - action of TA, other than sending or receiving over a channel
Ʉ – set of agent DA3 automata
ɐ,ɐi – agent DA3 automaton
Ƨ – set of server DA3 automata
ƨ,ƨi – server DA3 automaton
 - transition in TA
d – timed transition in TA
? – channel input transition in TA
!  – channel output transition in TA
 – transition in TA corresponding to action 
ch – transition in TA corresponding message transfer in channel ch

 
Appendix B – IMDS formal definition
P = {p1,p2,…} – the finite set of states (of servers)	
M = {m1,m2,…} – the finite set of messages (of agents)
  (MP) x (MP)  (MP) x (P) – the set of actions	
Pini  P – the set of initial states	
Mini  M – the set of initial messages
H = P M – the set of items	
Tini = Pini Mini – the initial configuration
TH – the configuration
    = ((m,p),(m’,p’))  Tinp(){m,p}, Tout()=Tinp()\{m,p}{m’,p’} - the rule of obtaining Tout() from Tinp() for the action 
    = ((m,p),(p’)),  Tinp(){m,p}, Tout()=Tinp()\{m,p}{p’} – the rule for the agent-terminating action	
LTS = N,n0,W, where:
−	N is the set nodes (configurations {T0,T1,...}, Tini= T0);
−	n0 is the root, n0  N (configuration Tini);
−	W is the set of directed labeled transitions, W  N    N, 
W = { (Tinp(),,Tout()) | }.
S = {s1,s2,…} – finite set of servers	
A = {a1,a2,…} – finite set of agents
P(s) = {p1s,p2s,…}, sS – finite set of states of server s
M(a) = {m1a,m2a,…}, aA – finite set of messages of agent a
M(s) = {m1s,m2s,…}, sS – finite set of messages directed to server s
P = sS P(s), s1,s2S s1s2 P(s1)P(s2)= – every state is attributed to some server	
M = aA M(a)=sS M(s), a1,a2A a1a2 M(a1)M(a2)=, s1,s2S s1s2 M(s1)M(s2)= – every message is attributed to some agent and is directed to some server
    = ((m,p),(m’,p’)),  mM(a)m’M(a), pP(s)p’P(s)  mM(s) - constraints on input and output pairs of the action
B(s) = {  |  = ((p,m),(p’,m’))   = ((p,m),(p’)), pP(s)} – the server process of the server s
C(a) = { |  = ((p,m),(p’,m’))   = ((p,m),(p’)), mM(a)} – the agent process of the agent a
B = {B(s) | sS} – the server view	
C = {C(a) | aA} – the agent view

IMDS as the programming language:
S = {s1,s2,...} – the finite set of servers 
A = {a1,a2,...} – the finite set of agents 
V = {v1,v2,...} – the finite set of values 
R = {r1,r2,...} – the finite set of services 
P  S  V – the set of states 
M  A  S  R – the set of messages
  (MP)  (MP)  (MP)  (P) | (m,p)(m’,p’)  (m,p)(p’), 
m = (a,s,r)  M, p=(s1,v1)  P, m’=(a2,s2,r2)  M, p’=(s3,v3)  P, s1 = s, s3 = s, a2=a
B(s) =	{ |  = (((a,s,r),(s,v)), ((a,s’,r’),(s,v’)))   = (((a,s,r),(s,v)), ((s,v’))), s’S, aA, v,v’V, r,r’R } – the server process of the server sS
C(a) =	{ |  = (((a,s,r),(s,v)), ((a,s’,r’),(s,v’)))   = (((a,s,r),(s,v)), ((s,v’))), s,s’S, v,v’V, r,r’R } – the agent process of the agent aA
Appendix C – IMDS syntax
The IMDS syntax is presented in EBNF notation, with following rules:
LEGEND
Usage	Notation
definition	=
non-terminal symbol	letters and _
alternation	|
optional	[ ... ]
repetition	{ ... }
terminal string	" ... "
keyword	bold
range of literals	..

model = [title] system

title = system sys_id “;”
system = server_view | agent_view
server_view = server_types [ agent_types_list ] 
variables server_view_init
agent_view = server_headers agent_types varibles agent_view_init

server_types = { server_type }
server_type = server_header actions “;”
server_header = server_relations elements
server_relations = server “:”  serv_type_id 
“(“ server_formal_pars “),”
server_formal_pars = formal_pars_servers “;” formal_pars_agents | formal_pars_agents “;” formal_pars_servers
formal_pars_servers = servers servers_formal_pars_list
formal_pars_agents = agents agents_formal_pars_list
servers_formal_pars_list = server_formal_par { “,” server_formal_par }
agents_formal_pars_list = agent_formal_par { “,” agent_formal_par }
server_formal_par =
server_formal_par_id [ “[” vector_size “]” ]  
[ “:” server_type_id ] | 
server_formal_par_id [ “[” vector_size “]” ] “:” “self”
agent_formal_par = agent_formal_par_id [ “[” vector_size “]” ]  
[ “:” agent_type_id ] | 
agent_formal_par_id [ “[” vector_size “]” ] “:” “self”

elements = states services | services states
states = states “{” state_list “},”
services = services “{” service_list “},”
state_list = state_def { “,” state_def }
service_list = service_def> { “,”service_def }
state_def = state_id [ “[” vector_size “]” ]
service_def = service_id> [ “[” vector_size “]” ]

actions = actions “{” action_list “},”
action_list = action { action }
action = [ condition ] [ repeaters ] input -> output “,”
condition = “?” instance_number
repeaters = repeater | repeater repeater | repeater repeater repeater
repeater = “<” repeater_id lower_limit “..” upper_limit “>”
input = “{” message “,” serv_state “}”
output = “{” message “,” serv_state “}” | “{” serv_state “}”
message = agent_term “.” server_term “.” service_term
serv_state = server_term “.” state_term
agent_term = agent_id  [ “[” index “]” ]
server_term = server_id [ “[” index “]” ]

service_term = service_id [ “[” expression “]” ]
state_term = state_id [ “[” expression “]” ]

agent_types_list = agent “:” agent_types_id_list “;”
agent_types_id_list = agent_type_id { “,” agent_type_id }

variables = server_variables agent_variables | 
agent_variables server_variables
server_variables = servers server_variable_list “;”
agent_variables = agents agent_variable_list “;”
server_variable_list = server_decl { “,” server_decl }
server_decl = server_id [ “[” vector_size “]” ]  
[ “:” server_type_id ] 
agent_variable_list =  agent_decl { “,” agent_decl }
agent_decl = agent_id [ “[” vector_size “]” ]  
[ “:” agent_type_id ]

server_view_init = init “->” “{” <server_view_init_list> “}”
server_view_init_list = server_view_init { server_view_init }
server_view_init = server_view_server_init server_view_agent_init | server_view_agent_init server_view_server_init 
server_view_server_init = repeater server_id “[” index “]” 
“(” server_view_parameter_list “).” server_init “,” |
	server_id “(” server_view_parameter_list “).” server_init “,”
server_view_agent_init = repeater agent_id “[” index “]” “.”
agent_init “,” | agent_id “.” agent_init “,”
server_view_parameter_list = server_view_parameter
{ “,” server_view_parameter }
server_view_parameter = server_parameter | agent_parameter
server_parameter = server_id [ “[” index_list “]” ]
agent_parameter = agent_id [ “[” index_list “]” ]
index_list = index { “,” index } | index “..” index
server_init = state_id [ “[” index “]” ]
agent_init = server_id [ “[” index “]” ] “.” 
service_id [ “[” index “]” ]

server_headers = server_header “;” { server_header “;” }
agent_types = agent_type { agent_type }
agent_type = agent_header actions “;”
agent_header = agent “:” agent_type_id “(” formal_pars_servers “),”

agent_view_init = init “->” “{” agent_view_init_list “}”
agent_view_init_list = agent_view_init { agent_view_init }
agent_view_init = agent_view_server_init agent_view_agent_init | agent_view_agent_init agent_view_server_init
agent_view_server_init = repeater server_id “[” index “]” “.”
server_init “,” |
server_id “.” server_init “,”
agent_view_agent_init = repeater agent_id “[” index “]”
“(” agent_view_parameter_list “).” agent_init “,” | 
	agent_id “(” agent_view_parameter_list “).” agent_init “,”
agent_view_parameter_list = agent_view_parameter 
{ “,” agent_view_parameter }
agent_view_parameter = server_parameter

system_id = identifier
server_type_id = identifier
agent_type_id = identifier
server_formal_par_id = identifier
agent_formal_par_id = identifier
server_id = identifier
agent_id = identifier
state_id = identifier
service_id = identifier
repeater_id = identifier
lower_limit = number
upper_limit = number
vector_size = number
instance_number = number
expression = number | repeater_id | number operator number | repeater_id operator number |
	number operator repeater_id
operator = “+” | “-”
number = digit { digit }
identifier = letter { character }
digit = “0” .. ”9”
letter = “A” .. “Z” | “a” .. “z”
character = letter | digit | “_”

Changes in Timed IMDS:
system = server_view 
server_view = server_types [ agent_types_list ] 
variables [ channels ] server_view_init
channels = channels “;” | channels “{” delays “}”
delays = delay [ “,” delay ]
delay = constraint | server_ spec constraint | 
server_spec “->” server_spec constraint
server_spec = server_id [ “[” server_subrange “]” ]
server_ subrange = number | “-” number | number “%” number | 
“-” number “%” number
elements = states services [ bounds ] | services states [ bounds ]
bounds = bounds “{” bound { “,” bound } “}”
bound = [ condition ] “?” clk “(” bound finishing_bracket state_id 
[ “[” index “]” ] “)”
action = [ condition ] [ restriction ] [ reset ] [ repeaters ] 
input -> [ duration ] output “,”
condition = “?” 
restriction = “?” clk 
duration = constraint 
constraint = starting_bracket number [ “,” number ] finishing_bracket
starting_bracket = “(” | “<”
finishing_bracket = “)” | “>”
reset = “!”







